<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RoASt Configuration Wizard</title>
  <script src="js/tailwind.min.js"></script>
  <link href="css/bootstrap.min.css" rel="stylesheet" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet" />
  <style>
    /* === GOALS SIMULATOR STYLES === */
    .simulation-frame {
      border: 1px solid #d1d9e0;
      border-radius: 6px;
      padding: 10px;
      margin: 0 15px 12px 15px;
      background-color: #fcfdff;
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 10px;
      flex-shrink: 0;
      transition: opacity 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.06);
    }

    .simulation-frame:hover {
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.08);
      border-color: #a8b5c1;
    }

    .frame-header {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 5px;
      padding-bottom: 5px;
      border-bottom: 1px solid #eee;
    }

    .drag-handle {
      width: 24px;
      height: 24px;
      background-color: #e9edf0;
      border: 1px solid #c8d1d9;
      border-radius: 4px;
      cursor: move;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      color: #5f6b7a;
      line-height: 1;
      transition: background-color 0.2s, box-shadow 0.2s;
      flex-shrink: 0;
      margin-right: 10px;
    }

    .drag-handle::before {
      content: "â˜°";
      font-weight: bold;
    }

    .drag-handle:hover {
      background-color: #dce3e9;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    .simulation-frame h4 {
      text-align: left;
      margin: 0;
      font-size: 1.05em;
      color: #444;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex-grow: 1;
      padding: 0 5px;
    }

    .close-frame-btn {
      background: linear-gradient(145deg, #ffebee, #ffcdd2);
      color: #c62828;
      border: 2px solid #f48fb1;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      font-weight: 700;
      line-height: 1;
      text-align: center;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 6px rgba(198, 40, 40, 0.2),
        0 1px 3px rgba(198, 40, 40, 0.1);
    }

    .close-frame-btn:hover {
      background: linear-gradient(145deg, #f48fb1, #e57373);
      color: #fff;
      transform: scale(1.1) rotate(90deg);
      box-shadow: 0 4px 12px rgba(198, 40, 40, 0.3),
        0 2px 6px rgba(198, 40, 40, 0.2);
    }

    .rotate-btn {
      background: linear-gradient(145deg, #e3f2fd, #bbdefb);
      color: #1976d2;
      border: 2px solid #90caf9;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      flex-shrink: 0;
      margin-left: 8px;
      padding: 0;
      font-size: 14px;
      font-weight: 600;
      box-shadow: 0 2px 6px rgba(25, 118, 210, 0.2),
        0 1px 3px rgba(25, 118, 210, 0.1);
    }

    .rotate-btn:hover {
      background: linear-gradient(145deg, #90caf9, #64b5f6);
      color: #fff;
      transform: rotate(90deg) scale(1.1);
      box-shadow: 0 4px 12px rgba(25, 118, 210, 0.3),
        0 2px 6px rgba(25, 118, 210, 0.2);
    }

    .simulation-frame .grids-wrapper {
      display: flex;
      overflow-x: auto;
      width: 100%;
      gap: 15px;
      padding-bottom: 15px;
      align-items: flex-start;
      scrollbar-width: thin;
      scrollbar-color: #adb5bd #f1f3f5;
    }

    .simulation-frame .frame-canvas-container {
      text-align: center;
      min-width: 305px;
      flex-shrink: 0;
      position: relative;
      border: 2px solid transparent;
      border-radius: 6px;
      transition: border-color 0.2s ease;
    }

    .simulation-frame .frame-canvas-container h5 {
      font-size: 0.9em;
      color: #666;
      margin-bottom: 4px;
      font-weight: 500;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .simulation-frame canvas {
      border: 1px solid #c8d1d9;
      cursor: pointer;
      background-color: #f8f9fa;
      max-width: 100%;
      height: auto;
      border-radius: 6px;
      display: block;
      margin: 0 auto;
    }

    .simulation-frame .boundary-info {
      font-family: monospace;
      font-size: 0.8em;
      color: #5f6b7a;
      margin-top: 5px;
      text-align: center;
    }

    .add-grid-btn-container {
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 100px;
      height: 335px;
      padding-left: 10px;
    }

    .add-grid-btn {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: 3px dashed #adb5bd;
      background: linear-gradient(145deg, #f8f9fa, #e9ecef);
      color: #495057;
      font-size: 28px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      box-shadow: 0 2px 6px rgba(173, 181, 189, 0.2),
        0 1px 3px rgba(173, 181, 189, 0.1);
    }

    .add-grid-btn:hover {
      background: linear-gradient(145deg, #e9ecef, #dee2e6);
      border-color: #6c757d;
      color: #343a40;
      transform: scale(1.08);
    }

    .grid-delete-btn {
      position: absolute;
      top: 6px;
      right: 6px;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 2px solid #dc3545;
      background: linear-gradient(145deg, #ffffff, #f8f9fa);
      color: #dc3545;
      font-size: 13px;
      font-weight: 700;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.8;
      transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      z-index: 10;
    }

    .grid-delete-btn:hover {
      opacity: 1;
      background: linear-gradient(145deg, #dc3545, #c82333);
      color: white;
      transform: scale(1.15) rotate(180deg);
    }

    .dragging-source-canvas {
      opacity: 0.6;
      border-style: dashed;
    }

    .drop-target-canvas {
      box-shadow: 0 0 12px rgba(30, 200, 30, 0.8);
      border-color: #4caf50;
    }

    .simulation-frame.dragging {
      opacity: 0.3;
      border-style: dashed;
      box-shadow: none;
      background-color: #eef2f5;
    }

    .drop-indicator {
      height: 6px;
      background-color: #4a90e2;
      margin: -2px 15px 10px 15px;
      border-radius: 3px;
      flex-shrink: 0;
      box-shadow: 0 1px 3px rgba(0, 0, 200, 0.3);
    }

    /* Palette Items */
    .palette-robot {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      cursor: grab;
      border: 2px solid #555;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;
      flex-shrink: 0;
      color: white;
      font-weight: 700;
      font-size: 14px;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    .palette-robot:hover {
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
    }

    .palette-robot:active {
      cursor: grabbing;
      transform: scale(1.1);
    }

    .palette-waypoint {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      cursor: grab;
      border: 2px solid #555;
      background-color: #0c2c67;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;
      flex-shrink: 0;
    }

    .palette-waypoint::after {
      content: "";
      width: 22px;
      height: 22px;
      background-image: url('data:image/svg+xml;utf8,<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="%23ffffff"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg>');
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
    }

    .palette-exclusive-point {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      cursor: grab;
      border: 2px solid #555;
      background-color: #0c2c67;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;
      flex-shrink: 0;
    }

    .palette-exclusive-point::after {
      content: "";
      width: 22px;
      height: 22px;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="%23fff" viewBox="0 0 16 16"><path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/></svg>');
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
    }

    .palette-waypoint:hover,
    .palette-exclusive-point:hover {
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
    }

    .palette-waypoint:active,
    .palette-exclusive-point:active {
      cursor: grabbing;
      transform: scale(1.1);
    }

    /* Wall Palette Items */
    .palette-wall-horizontal,
    .palette-wall-vertical {
      width: 30px;
      height: 30px;
      cursor: grab;
      border: 2px solid #333;
      background-color: #f0f0f0;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;
      flex-shrink: 0;
    }

    .palette-wall-horizontal::after {
      content: "";
      width: 20px;
      height: 4px;
      background-color: #333;
      border-radius: 2px;
    }

    .palette-wall-vertical::after {
      content: "";
      width: 4px;
      height: 20px;
      background-color: #333;
      border-radius: 2px;
    }

    .palette-wall-horizontal:hover,
    .palette-wall-vertical:hover {
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
      background-color: #e0e0e0;
    }

    .palette-wall-horizontal:active,
    .palette-wall-vertical:active {
      cursor: grabbing;
      transform: scale(1.1);
    }

    /* === END GOALS SIMULATOR STYLES === */

    /* Professional font setup */
    body {
      font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: linear-gradient(135deg, #f5f7fa 0%, #e8eef5 100%);
    }

    /* Custom styles for the modal */
    .modal-backdrop {
      transition: opacity 0.3s ease;
      backdrop-filter: blur(4px);
    }

    .modal-content {
      transition: all 0.3s ease;
    }

    /* Enhanced card styles */
    .main-card {
      background: white;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1),
        0 2px 4px -1px rgba(0, 0, 0, 0.06), 0 0 0 1px rgba(0, 0, 0, 0.05);
      transition: box-shadow 0.3s ease;
    }

    .main-card:hover {
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
        0 4px 6px -2px rgba(0, 0, 0, 0.05), 0 0 0 1px rgba(0, 0, 0, 0.05);
    }

    /* Input focus enhancement */
    input:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    /* Button enhancements */
    button {
      transition: all 0.2s ease;
    }

    button:active {
      transform: scale(0.98);
    }

    /* --- STYLES COPIED FROM 2ND FILE (for Page 2) --- */
    #page-2 {
      --cell-size: 30px;
      --grid-gap: 1.5rem;
    }

    #output-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: var(--grid-gap);
      padding: 1.5rem;
      background: linear-gradient(to bottom, #f8fafc, #f1f5f9);
      border-radius: 0.75rem;
      border: 2px solid #e2e8f0;
      margin-top: 1.5rem;
    }

    .grid-wrapper {
      background: white;
      border-radius: 0.75rem;
      border: 2px solid #e5e7eb;
      padding: 1.25rem;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      display: flex;
      flex-direction: column;
      align-items: center;
      transition: all 0.3s ease;
    }

    .grid-wrapper:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
    }

    .grid-wrapper.leader-config {
      border: 3px solid #dc3545;
      box-shadow: 0 0 16px rgba(220, 53, 69, 0.25),
        0 4px 12px rgba(0, 0, 0, 0.12);
      background: linear-gradient(to bottom, #ffffff, #fff5f5);
    }

    .grid-wrapper.excluded {
      opacity: 0.35;
      position: relative;
      filter: grayscale(0.5);
    }

    .grid-wrapper.excluded::after {
      content: "âœ—";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 5rem;
      color: #dc3545;
      font-weight: 900;
      pointer-events: none;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .grid-title {
      font-size: 0.95rem;
      font-weight: 600;
      text-align: center;
      margin-bottom: 0.875rem;
      color: #1f2937;
      letter-spacing: -0.01em;
    }

    .leader-marker {
      color: #dc3545;
      font-weight: 900;
      margin-left: 0.25rem;
      font-size: 1.5rem;
    }

    .view-canvas {
      border: 2px solid #d1d5db;
      border-radius: 6px;
      background-color: #fafbfc;
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
    }

    /* Section headers */
    .section-header {
      font-size: 1.25rem;
      font-weight: 600;
      color: #111827;
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 2px solid #e5e7eb;
    }

    /* Form field groups */
    .field-group {
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 0.5rem;
      padding: 1rem;
      transition: all 0.2s ease;
    }

    .field-group:hover {
      border-color: #d1d5db;
      background: #f3f4f6;
    }

    /* Enhanced stepper */
    .stepper-step {
      transition: all 0.3s ease;
    }

    /* Badge styles */
    .badge {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.75rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .badge-primary {
      background: #dbeafe;
      color: #1e40af;
    }

    .badge-success {
      background: #d1fae5;
      color: #065f46;
    }

    .badge-warning {
      background: #fef3c7;
      color: #92400e;
    }

    /* --- END STYLES FROM 2ND FILE --- */

    /* === RESPONSIVE STYLES FOR SMALL SCREENS === */
    @media (max-width: 768px) {

      /* Goals Simulator - Stack grids vertically */
      .grids-wrapper {
        display: flex !important;
        flex-direction: column !important;
        align-items: center !important;
        overflow-x: visible !important;
      }

      .frame-container {
        margin: 0 0 15px 0 !important;
        width: 100% !important;
        max-width: 350px !important;
      }

      /* Reduce canvas size for small screens */
      .view-canvas {
        max-width: 100% !important;
        height: auto !important;
      }

      /* Robot palette - wrap items */
      .robot-palette {
        flex-wrap: wrap !important;
        justify-content: center !important;
        gap: 8px !important;
      }

      /* Simulation frames */
      .simulation-frame {
        margin: 0 5px 12px 5px !important;
      }

      /* Grid wrapper responsive */
      #output-container {
        grid-template-columns: 1fr !important;
        padding: 1rem !important;
        gap: 1rem !important;
      }

      /* Progress bar - compact for mobile */
      nav[aria-label="Progress"] {
        width: 100% !important;
        overflow-x: auto !important;
        padding: 0.25rem 0 !important;
      }

      nav[aria-label="Progress"] .flex {
        gap: 0.5rem !important;
        min-width: min-content !important;
      }

      /* Stepper - hide text labels, show only numbers */
      nav[aria-label="Progress"] span.text-xs,
      nav[aria-label="Progress"] span.text-sm {
        display: none !important;
      }

      /* Stepper circles - smaller */
      nav[aria-label="Progress"] .w-7.h-7 {
        width: 1.75rem !important;
        height: 1.75rem !important;
        font-size: 0.75rem !important;
      }

      /* Arrows between steps - smaller */
      nav[aria-label="Progress"] svg.w-3 {
        width: 0.5rem !important;
        height: 0.5rem !important;
      }

      /* Header - stack on small screens */
      #main-container-card>div.flex.flex-col.lg\\:flex-row {
        flex-direction: column !important;
        align-items: flex-start !important;
        gap: 1rem !important;
      }

      /* Center progress bar on mobile */
      nav[aria-label="Progress"] {
        align-self: center !important;
      }

      /* Main title */
      h1 {
        font-size: 1.75rem !important;
      }

      /* Form inputs - full width */
      input,
      select,
      textarea {
        width: 100% !important;
      }

      /* Buttons - stack vertically */
      .flex.gap-3.justify-end {
        flex-direction: column !important;
        gap: 0.5rem !important;
      }

      .flex.gap-3.justify-end button {
        width: 100% !important;
      }

      /* Modal adjustments */
      .modal-content {
        margin: 1rem !important;
        max-height: 90vh !important;
        overflow-y: auto !important;
      }

      /* Color pickers - smaller grid */
      .grid.grid-cols-2 {
        grid-template-columns: 1fr !important;
      }

      /* Frame header - wrap if needed */
      .frame-header {
        flex-wrap: wrap !important;
      }

      .frame-header h4 {
        font-size: 0.9em !important;
      }

      /* Reduce padding */
      .main-card {
        padding: 1rem !important;
      }

      /* Goals simulator column */
      #simulator-column {
        padding: 0.5rem !important;
      }

      /* Add grid button */
      .add-grid-btn {
        width: 40px !important;
        height: 40px !important;
      }
    }

    @media (max-width: 480px) {

      /* Extra small screens */
      body {
        font-size: 14px !important;
      }

      h1 {
        font-size: 1.5rem !important;
      }

      .frame-container {
        max-width: 280px !important;
      }

      /* Robot palette items smaller */
      .palette-robot,
      .palette-waypoint,
      .palette-exclusive,
      .palette-wall {
        width: 36px !important;
        height: 36px !important;
        font-size: 14px !important;
      }

      /* Smaller canvas */
      canvas {
        transform: scale(0.85) !important;
        transform-origin: top left !important;
      }

      /* Compact frame header */
      .drag-handle {
        width: 20px !important;
        height: 20px !important;
        margin-right: 5px !important;
      }

      .close-frame-btn,
      .rotate-btn {
        width: 24px !important;
        height: 24px !important;
        font-size: 12px !important;
      }

      /* Stepper numbers only */
      nav[aria-label="Progress"] {
        transform: scale(0.9) !important;
      }
    }

    /* === END RESPONSIVE STYLES === */
  </style>
</head>

<body class="bg-gradient-to-br from-gray-50 to-gray-100 min-h-screen">
  <div class="w-full px-4 sm:px-6 lg:px-8 py-4 sm:py-8">
    <div id="main-container-card" class="main-card p-6 sm:p-10 rounded-2xl w-full mx-auto transition-all duration-300">
      <div class="flex flex-col lg:flex-row items-center mb-6 pb-4 border-b border-gray-200 gap-4">
        <!-- Title Section -->
        <div class="flex-shrink-0 lg:flex-1">
          <h1 class="text-3xl font-bold text-gray-900">RoASt Configuration Wizard</h1>
        </div>

        <!-- Progress Bar Section -->
        <nav aria-label="Progress" class="flex justify-center flex-shrink-0">
          <div class="flex items-center gap-2 sm:gap-4">
            <div id="step-1" class="flex items-center gap-2">
              <div
                class="flex items-center justify-center w-7 h-7 rounded-full bg-gray-300 text-gray-600 font-semibold text-xs">
                1
              </div>
              <span class="text-xs sm:text-sm font-medium text-gray-600">Parameters</span>
            </div>
            <svg class="w-3 h-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
            </svg>
            <div id="step-2" class="flex items-center gap-2">
              <div
                class="flex items-center justify-center w-7 h-7 rounded-full bg-gray-300 text-gray-600 font-semibold text-xs">
                2
              </div>
              <span class="text-xs sm:text-sm font-medium text-gray-600">Initial Configurations</span>
            </div>
            <svg class="w-3 h-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
            </svg>
            <div id="step-3" class="flex items-center gap-2">
              <div
                class="flex items-center justify-center w-7 h-7 rounded-full bg-gray-300 text-gray-600 font-semibold text-xs">
                3
              </div>
              <span class="text-xs sm:text-sm font-medium text-gray-600">Goal Simulator</span>
            </div>
            <svg class="w-3 h-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
            </svg>
            <div id="step-4" class="flex items-center gap-2">
              <div
                class="flex items-center justify-center w-7 h-7 rounded-full bg-gray-300 text-gray-600 font-semibold text-xs">
                4
              </div>
              <span class="text-xs sm:text-sm font-medium text-gray-600">Export</span>
            </div>
          </div>
        </nav>

        <!-- Load Button Section -->
        <div class="flex-shrink-0 lg:flex-1 lg:flex lg:justify-end">
          <input type="file" id="loadConfigInput" accept=".json" class="hidden" />
          <button type="button" id="loadConfigBtn"
            class="px-4 py-2 bg-gray-700 text-white rounded-lg hover:bg-gray-800 text-sm font-medium shadow-sm hover:shadow-md transition-all">
            <svg class="inline-block w-4 h-4 mr-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
            </svg>
            Load Config
          </button>
        </div>
      </div>

      <form id="config-form" class="space-y-8">
        <div id="page-1" data-page="1">
          <!-- Edit Mode Note -->
          <p id="preset_edit_note"
            class="mb-6 text-sm text-amber-700 bg-amber-50 border border-amber-200 rounded-md p-2"
            style="display: none;">
            â“˜ Turn to edit mode if you want to modify. Add <code class="bg-amber-100 px-1 rounded">?edit=true</code> to
            the URL.
          </p>

          <!-- Page 1 Header with Help Button -->
          <div class="flex items-center justify-between mb-6">
            <div>
              <h2 class="text-2xl font-semibold text-gray-900">Algorithm Parameters</h2>
              <p class="text-gray-600 mt-1">Configure your robot algorithm settings</p>
            </div>
            <button type="button" id="parametersHelpBtn" class="btn btn-info btn-sm"
              style="padding: 5px 10px; font-size: 0.9em" title="Open help guide">
              Instructions
            </button>
          </div>

          <!-- Execution Preset Selection -->
          <div class="mb-8 p-6 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-xl border-2 border-blue-200">
            <label for="algorithm_preset" class="block text-sm font-bold text-gray-900 mb-3">
              <svg class="inline-block w-5 h-5 mr-2 -mt-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
              </svg>
              Execution Preset
            </label>
            <select id="algorithm_preset"
              class="block w-full rounded-lg border-2 border-blue-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 py-3 px-4 text-base font-medium bg-white"
              style="max-width: 100%;">
              <option value="0" selected>Algorithm 1 - Leader-based with obstacle O</option>
              <option value="1">Algorithm 2 - Cooperative with obstacle O</option>
              <option value="custom">Custom Configuration</option>
            </select>
            <p id="preset_description" class="mt-2 text-sm text-gray-600"></p>
          </div>

          <h3 class="section-header mt-8 mb-4">Basic Configuration</h3>
          <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-6">
            <div class="field-group">
              <label for="number_of_robots" class="block text-sm font-semibold text-gray-700 mb-2">
                Number of Robots
                <span id="badge_number_of_robots"
                  class="ml-2 inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800"
                  style="display: none">Fixed</span>
              </label>
              <input type="number" id="number_of_robots"
                class="mt-1 block w-full rounded-lg border-2 border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 py-2.5 px-3 text-base"
                placeholder="e.g., 2" />
            </div>

            <div class="field-group">
              <label for="visibility_range" class="block text-sm font-semibold text-gray-700 mb-2">
                Visibility Range
                <span id="badge_visibility_range"
                  class="ml-2 inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800"
                  style="display: none">Fixed</span>
              </label>
              <input type="number" id="visibility_range"
                class="mt-1 block w-full rounded-lg border-2 border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 py-2.5 px-3 text-base"
                placeholder="e.g., 1" />
            </div>

            <div class="md:col-span-1 lg:col-span-1 field-group">
              <label for="existing_algorithm_path" class="block text-sm font-semibold text-gray-700 mb-2">
                Algorithm Path
                <span id="badge_existing_algorithm_path"
                  class="ml-2 inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800"
                  style="display: none">Fixed</span>
              </label>
              <input type="text" id="existing_algorithm_path"
                class="mt-1 block w-full rounded-lg border-2 border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 py-2.5 px-3 text-base"
                placeholder="/src/data/algo1.json" />
            </div>



            <div class="md:col-span-1 lg:col-span-1 field-group" style="display: none;">
              <label for="generation_mode_select" class="block text-sm font-semibold text-gray-700 mb-2">Generation Mode
                <span id="badge_generation_mode_select"
                  class="ml-2 inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800"
                  style="display: none;">
                  Fixed
                </span>
              </label>
              <select id="generation_mode_select"
                class="mt-1 block w-full rounded-lg border-2 border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 py-2.5 px-3 text-base bg-white">
                <option>All</option>
                <option selected>ProgressiveValidationByLevels</option>
                <!--option>ProgressiveValidationByMaxActivations</option-->
                <!--option>ProgressiveValidationByLimitTime</option-->
              </select>
            </div>

            <div id="generation_mode_value_container" class="md:col-span-1 lg:col-span-1 field-group"
              style="display: block">
              <label for="generation_mode_value" id="generation_mode_value_label"
                class="block text-sm font-semibold text-gray-700 mb-2">Max Generation Level
                <span id="badge_generation_mode_value"
                  class="ml-2 inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800"
                  style="display: none;">
                  Fixed
                </span>
              </label>
              <input type="number" id="generation_mode_value"
                class="mt-1 block w-full rounded-lg border-2 border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 py-2.5 px-3 text-base"
                placeholder="e.g., 5" value="5" />
              <p class="mt-1 text-xs text-gray-500 italic">Note: 0 means unlimited levels</p>
            </div>

            <div
              class="relative flex items-start p-4 rounded-lg border-2 border-gray-200 hover:border-blue-300 transition-colors field-group bg-white">
              <div class="flex h-5 items-center">
                <input id="opacity" type="checkbox"
                  class="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500" />
              </div>
              <div class="ml-3 text-sm">
                <label for="opacity" class="font-semibold text-gray-700 cursor-pointer">
                  Opacity
                  <span id="badge_opacity"
                    class="ml-2 inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800"
                    style="display: none">Fixed</span>
                </label>
              </div>
            </div>


          </div>

          <h3 class="section-header mt-8 mb-4">Obstacle Configuration</h3>
          <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
            <div class="field-group" style="display: none;">
              <label for="obstacle_type" class="block text-sm font-semibold text-gray-700 mb-2">
                Obstacle Type
                <span id="badge_obstacle_type"
                  class="ml-2 inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800"
                  style="display: none">Fixed</span>
              </label>
              <select id="obstacle_type"
                class="mt-1 block w-full rounded-lg border-2 border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 py-2.5 px-3 text-base bg-white">
                <option value="O" selected>O - Custom Obstacle</option>
                <option value="W">W - Wall Obstacle</option>
              </select>
              <p class="mt-2 text-xs text-gray-500">
                Select 'W' for wall obstacles or 'O' for custom obstacles
              </p>
            </div>

            <div
              class="relative flex items-start p-4 rounded-lg border-2 border-gray-200 hover:border-blue-300 transition-colors field-group bg-white">
              <div class="flex h-5 items-center">
                <input id="is_obstacle_opaque" type="checkbox"
                  class="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500" />
              </div>
              <div class="ml-3 text-sm">
                <label for="is_obstacle_opaque" class="font-semibold text-gray-700 cursor-pointer">Obstacle Opaque
                  <span id="badge_is_obstacle_opaque"
                    class="ml-2 inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800"
                    style="display: none">Fixed</span></label>
                <p class="text-xs text-gray-500 mt-1">
                  Automatically enabled when Wall obstacle is selected
                </p>
              </div>
            </div>
          </div>

          <div class="mt-4 p-4 bg-blue-50 border-2 border-blue-200 rounded-xl">
            <p class="text-sm text-blue-900">
              <strong>ðŸ“Œ Note:</strong> <span class="font-semibold">O</span> is reserved for obstacle and its color is
              <strong>orange</strong>.
            </p>
          </div>



          <h3 class="section-header mt-8 mb-4">Robot Colors & Configuration</h3>
          <div class="space-y-6">
            <div class="space-y-3 field-group bg-white p-6 rounded-xl border-2 border-gray-200">
              <div class="flex items-center justify-between mb-3">
                <label class="block text-sm font-semibold text-gray-700">
                  Algorithm Colors
                  <span id="badge_color_letters_input"
                    class="ml-2 inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800"
                    style="display: none">Fixed</span>
                </label>
                <button type="button" id="add_color_btn"
                  class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 text-sm font-medium shadow-sm hover:shadow-md transition-all flex items-center gap-2 disabled:bg-gray-400 disabled:cursor-not-allowed disabled:hover:bg-gray-400 disabled:hover:shadow-sm">
                  <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
                  </svg>
                  Add Color
                </button>
              </div>
              <p class="text-sm text-gray-600">
                Click "Add Color" to define robot colors with character-color pairs
              </p>

              <!-- Hidden input to maintain compatibility -->
              <input type="hidden" id="color_letters_input" />

              <div id="color_picker_container"
                class="mt-4 grid grid-cols-1 md:grid-cols-2 gap-3 max-h-60 overflow-y-auto p-1"></div>

              <p class="mt-3 text-xs text-gray-500">
                Note: 'O' is often reserved for obstacles (e.g., orange),
                'W' for walls (black), and 'X' for invisible zones.
              </p>
            </div>
          </div>

          <div class="pt-8 mt-8 border-t border-gray-200 flex justify-end">
            <button type="button" id="next-btn"
              class="group w-full sm:w-auto flex items-center justify-center py-3 px-8 border border-transparent rounded-lg shadow-md text-base font-semibold text-white bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all">
              Continue to Initial Configurations Editor
              <svg class="ml-2 w-5 h-5 group-hover:translate-x-1 transition-transform" fill="none" stroke="currentColor"
                viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
              </svg>
            </button>
          </div>
        </div>

        <div id="page-2" data-page="2" style="display: none">
          <div class="space-y-6">
            <!-- Edit Mode Note -->
            <p id="initial_config_edit_note"
              class="text-sm text-amber-700 bg-amber-50 border border-amber-200 rounded-md p-2" style="display: none;">
              â“˜ Turn to edit mode if you want to modify. Add <code class="bg-amber-100 px-1 rounded">?edit=true</code>
              to the URL.
            </p>

            <!-- Page 2 Header with Help Button -->
            <div class="flex items-center justify-between mb-6">
              <div>
                <h2 class="text-2xl font-semibold text-gray-900">
                  Initial Configuration Generator
                </h2>
                <p class="text-gray-600 mt-1">
                  Create and configure robot initial positions
                </p>
              </div>
              <button type="button" id="initialConfigHelpBtn" class="btn btn-info btn-sm"
                style="padding: 5px 10px; font-size: 0.9em" title="Open help guide">
                Instructions
              </button>
            </div>

            <!-- Initial Configuration Editor Section (Collapsible) -->
            <div class="bg-white border-2 border-gray-300 rounded-lg">
              <div class="flex items-center justify-between px-4 py-3 bg-gray-50 rounded-t-lg">
                <h3 class="text-sm font-semibold text-gray-900">
                  Initial Configuration Editor
                  <span class="text-xs text-gray-500 ml-2">(Robot Palette, Movement Patterns & Leader Colors)</span>
                  <span id="badge_initial_config_editor"
                    class="ml-2 inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800"
                    style="display: none">Fixed</span>
                </h3>
                <button type="button" id="toggleInitialConfigBtn"
                  class="px-3 py-1.5 text-sm font-medium transition-colors rounded-md">
                  â–¼ Show
                </button>
              </div>

              <div id="initialConfigContent" style="display: none;" class="p-4 space-y-6">
                <!-- Robot Palette -->
                <div class="bg-gradient-to-br from-blue-50 to-indigo-50 p-3 rounded-lg border border-blue-200">
                  <div class="flex items-center justify-between mb-2">
                    <div>
                      <h4 class="text-sm font-semibold text-gray-900">Robot Palette</h4>
                      <p class="text-xs text-gray-600">Drag robots to grids below</p>
                    </div>
                    <div class="text-xs text-gray-500">
                      Grid size:
                      <span id="gridSizeDisplay" class="font-semibold text-blue-700">Dynamic</span>
                    </div>
                  </div>
                  <div id="robotPalette" class="flex flex-wrap gap-2">
                    <!-- Will be populated dynamically -->
                  </div>
                </div>

                <!-- Interactive Grids Section -->
                <div>
                  <div class="flex items-center justify-between mb-3">
                    <h4 class="text-sm font-semibold text-gray-900">
                      Movement Patterns
                      <span class="text-xs text-gray-500">(Movement direction: Left â†’ Right)</span>
                    </h4>
                    <div class="flex items-center gap-2">
                      <button type="button" id="addGridBtn" class="btn btn-primary btn-sm"
                        style="padding: 5px 10px; font-size: 0.9em" title="Add new movement pattern">
                        + Add Pattern
                      </button>
                    </div>
                  </div>
                  <div id="interactiveGridsContainer"
                    class="flex flex-row flex-wrap gap-4 p-4 bg-gray-50 rounded-lg min-h-[300px] border-2 border-dashed border-gray-300">
                    <!-- Movement pattern grids will be added here -->
                  </div>
                </div>

                <!-- Leader Colors Section -->
                <div class="bg-gray-50 p-4 rounded-lg border">
                  <h4 class="text-sm font-semibold text-gray-900 mb-2">
                    Leader Colors
                  </h4>
                  <p class="text-xs text-gray-500 mb-3">
                    Select which robot colors can be leaders
                  </p>
                  <div id="leaderColorsContainer" class="flex flex-wrap gap-4">
                    <!-- Will be populated dynamically from Page 1 colors -->
                  </div>
                </div>

                <!-- Generated Data Section (Collapsible) -->
                <details class="bg-white border rounded-lg">
                  <summary class="px-4 py-3 cursor-pointer text-sm font-medium text-gray-700 hover:bg-gray-50">
                    View Generated JSON Data
                  </summary>
                  <div class="px-4 pb-4 pt-2">
                    <label for="robotData" class="block text-xs font-medium text-gray-600 mb-2">Auto-generated from
                      visual editor</label>
                    <textarea id="robotData" rows="4"
                      class="block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 font-mono text-xs bg-gray-50"
                      readonly></textarea>
                  </div>
                </details>
              </div>
            </div>

            <!-- Initial Configurations section header -->
            <div class="flex items-center justify-between mb-2">
              <div>
                <h3 class="text-sm font-semibold text-gray-900">
                  Initial Configurations
                  <span id="badge_list_of_initial_positions"
                    class="ml-2 inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800"
                    style="display: none;">
                    Fixed
                  </span>
                  <span id="config-status-label" class="ml-2 px-2 py-1 text-xs font-medium rounded"
                    style="display: none;"></span>
                </h3>
                <p class="text-xs text-gray-500 mt-1">
                  Auto-generated from movement patterns and leader colors
                </p>
              </div>
              <button type="button" id="resetInitialConfigBtn"
                class="px-3 py-1.5 text-xs bg-gray-600 text-white rounded-md hover:bg-gray-700 font-medium transition-colors"
                style="display: none;" onclick="resetInitialConfigurationsFromPreset()">
                Reset from Preset
              </button>
            </div>

            <div>
              <label for="list_of_initial_positions" class="block text-sm font-medium text-gray-700 sr-only">List of
                Initial Positions (JSON)</label>
              <textarea id="list_of_initial_positions" rows="10"
                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 font-mono text-sm"
                style="display: none"></textarea>
            </div>

            <div id="output-container" class="mt-6"></div>
          </div>

          <div class="pt-8 mt-6 border-t border-gray-200 flex flex-col-reverse sm:flex-row justify-between gap-4">
            <button type="button" id="prev-btn-page2"
              class="group w-full sm:w-auto flex items-center justify-center py-3 px-8 border-2 border-gray-300 rounded-lg shadow-sm text-base font-semibold text-gray-700 bg-white hover:bg-gray-50 hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all">
              <svg class="mr-2 w-5 h-5 group-hover:-translate-x-1 transition-transform" fill="none"
                stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
              </svg>
              Previous
            </button>
            <button type="button" id="generate-btn"
              class="group w-full sm:w-auto flex items-center justify-center py-3 px-8 border border-transparent rounded-lg shadow-md text-base font-semibold text-white bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all">
              Continue to goals Editor
              <svg class="ml-2 w-5 h-5 group-hover:translate-x-1 transition-transform" fill="none" stroke="currentColor"
                viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
              </svg>
            </button>
          </div>

          <!-- Hidden textarea to store moving_on_space_pattern data -->
          <textarea id="moving_on_space_pattern" class="hidden"></textarea>
        </div>
      </form>

      <div id="page-3" data-page="3" class="mt-10" style="display: none">
        <!-- Edit Mode Note -->
        <p id="goals_edit_note" class="mb-6 text-sm text-amber-700 bg-amber-50 border border-amber-200 rounded-md p-2"
          style="display: none;">
          â“˜ Turn to edit mode if you want to modify. Add <code class="bg-amber-100 px-1 rounded">?edit=true</code> to
          the URL.
        </p>

        <!-- Page 3 Header with Help Button -->
        <div class="flex items-center justify-between mb-6">
          <div>
            <h2 class="text-2xl font-semibold text-gray-900">Goals Configuration Editor</h2>
            <p class="text-gray-600 mt-1">Use the interactive simulator to set up the goals. You can drag robots to
              position them, define boundaries, and create waypoints for your simulation scenarios.</p>
          </div>
          <button type="button" id="goalsHelpBtn" class="btn btn-info btn-sm"
            style="padding: 5px 10px; font-size: 0.9em" title="Open help guide">
            Instructions
          </button>
        </div>

        <div id="goals-simulator-container"
          class="w-full h-[800px] bg-white rounded-xl border-2 border-gray-200 overflow-hidden shadow-sm mb-6">
          <!-- Embedded Goals Simulator -->
          <div class="simulator-main-container" style="
                display: flex;
                flex-grow: 1;
                gap: 0;
                max-height: 100%;
                overflow: hidden;
                position: relative;
                height: 100%;
              ">
            <div id="simulator-column" style="
                  flex: 1;
                  display: flex;
                  flex-direction: column;
                  border: 1px solid #d1d9e0;
                  border-radius: 8px;
                  background-color: #ffffff;
                  overflow-y: auto;
                  position: relative;
                  padding-bottom: 15px;
                  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
                  scrollbar-width: thin;
                  scrollbar-color: #adb5bd #f1f3f5;
                ">
              <div class="robot-palette" style="
                    display: flex;
                    justify-content: center;
                    gap: 15px;
                    margin-bottom: 0;
                    align-items: center;
                    flex-shrink: 0;
                    position: sticky;
                    top: 0;
                    background-color: white;
                    z-index: 20;
                    padding: 12px 15px;
                    border-bottom: 1px solid #e4e9ed;
                    flex-wrap: wrap;
                  ">
                <div class="palette-robot" data-color="L" style="background-color: #ff0000" title="Red Robot ('L')">
                  L
                </div>
                <div class="palette-robot" data-color="R" style="background-color: #008000" title="Green Robot ('R')">
                  R
                </div>
                <div class="palette-robot" data-color="F" style="background-color: #0000ff" title="Blue Robot ('F')">
                  F
                </div>
                <div class="palette-robot" data-color="O" style="background-color: #ffa500" title="Obstacle ('O')">
                  O
                </div>
                <div class="palette-waypoint" data-type="waypoint" title="Waypoint"></div>
                <div class="palette-exclusive-point" data-type="exclusive_point" title="Exclusive Point"></div>
                <!-- Walls hidden 
                  <div
                    class="palette-wall-horizontal"
                    data-type="wall_horizontal"
                    title="Horizontal Wall"
                  ></div>
                  <div
                    class="palette-wall-vertical"
                    data-type="wall_vertical"
                    title="Vertical Wall"
                  ></div>
                  -->
                <div style="flex-grow: 1;"></div>
                <button id="resetConfigBtn" class="btn btn-danger btn-sm" style="
                      padding: 5px 10px;
                      font-size: 0.9em;
                    " title="Reset to default goals">
                  Reset Goals
                </button>
                <button id="addFrameBtn" class="btn btn-primary btn-sm" style="padding: 5px 10px; font-size: 0.9em"
                  title="Add new simulation frame">
                  + Add Goal
                </button>
              </div>
            </div>

            <div class="resize-handle" id="resizeHandle" style="
                  width: 8px;
                  background: linear-gradient(
                    to right,
                    #e9ecef,
                    #dee2e6,
                    #e9ecef
                  );
                  cursor: col-resize;
                  position: relative;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  border-left: 1px solid #dee2e6;
                  border-right: 1px solid #dee2e6;
                  transition: background 0.2s ease;
                  user-select: none;
                ">
              <button class="toggle-editor-btn" id="toggleEditorBtn" style="
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    width: 28px;
                    height: 44px;
                    background: linear-gradient(145deg, #ffffff, #f0f2f5);
                    border: 2px solid #dee2e6;
                    border-radius: 14px;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 13px;
                    font-weight: 600;
                    color: #6c757d;
                    z-index: 10;
                  " title="Toggle editor panel">
                â—‚
              </button>
            </div>

            <div id="editor-column" style="
                  flex: 1;
                  display: none;
                  flex-direction: column;
                  padding: 15px;
                  border: 1px solid #d1d9e0;
                  border-radius: 8px;
                  background-color: #ffffff;
                  overflow: hidden;
                  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
                ">
              <div class="editor-controls" style="
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 1px;
                    flex-shrink: 0;
                  ">
                <label for="simulationConfigList" style="
                      width: 340px;
                      margin-bottom: 0;
                      font-weight: 600;
                      color: #333;
                      font-size: 1em;
                    ">Active Simulation Config (JSON):</label>
                <div class="editor-btn-group" style="
                      display: flex;
                      justify-content: flex-end;
                      align-items: center;
                      gap: 10px;
                      width: 100%;
                    ">
                  <button id="copyConfigBtn" class="btn btn-secondary btn-sm" title="Copy JSON to clipboard">
                    Copy
                  </button>
                </div>
              </div>
              <textarea id="simulationConfigList" rows="20" spellcheck="false" readonly style="
                    flex-grow: 1;
                    width: 100%;
                    font-family: 'Courier New', Courier, monospace;
                    font-size: 0.9em;
                    border: 1px solid #ddd;
                    resize: none;
                    background-color: #f9fafb;
                    white-space: pre;
                    overflow-wrap: normal;
                    overflow: auto;
                    padding: 12px;
                    border-radius: 6px;
                    color: #333;
                    line-height: 1.4;
                  "></textarea>
            </div>
          </div>
        </div>

        <div class="pt-8 mt-6 border-t border-gray-200 flex flex-col-reverse sm:flex-row justify-between gap-4">
          <button type="button" id="prev-btn-page3"
            class="group w-full sm:w-auto flex items-center justify-center py-3 px-8 border-2 border-gray-300 rounded-lg shadow-sm text-base font-semibold text-gray-700 bg-white hover:bg-gray-50 hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all">
            <svg class="mr-2 w-5 h-5 group-hover:-translate-x-1 transition-transform" fill="none" stroke="currentColor"
              viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
            </svg>
            Previous
          </button>
          <button type="button" id="next-btn-page3"
            class="group w-full sm:w-auto flex items-center justify-center py-3 px-8 border border-transparent rounded-lg shadow-md text-base font-semibold text-white bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all">
            Continue to Summary
            <svg class="ml-2 w-5 h-5 group-hover:translate-x-1 transition-transform" fill="none" stroke="currentColor"
              viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
            </svg>
          </button>
        </div>
      </div>

      <div id="page-4" data-page="4" class="mt-10" style="display: none">
        <div class="flex items-center justify-between mb-6">
          <div>
            <h2 class="text-2xl font-semibold text-gray-900">
              Generated Configuration
            </h2>
            <p class="text-gray-600 mt-1">
              Review and export your configuration
            </p>
          </div>
          <span class="badge badge-success">Step 4 of 4</span>
        </div>

        <!-- Summary View -->
        <div id="json-summary"
          class="bg-gradient-to-br from-white to-gray-50 border-2 border-gray-200 rounded-xl p-6 mb-6 shadow-sm">
          <div class="flex items-center justify-between mb-5">
            <h3 class="text-lg font-semibold text-gray-900">
              Configuration Summary
            </h3>
            <span class="badge badge-primary">Ready</span>
          </div>
          <div id="summary-content" class="space-y-2 text-sm bg-white p-4 rounded-lg border border-gray-200"></div>

          <div class="mt-5 p-4 bg-blue-50 rounded-lg border border-blue-100 flex items-start gap-3">
            <svg class="w-5 h-5 text-blue-600 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor"
              viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
            <div class="text-sm text-blue-800">
              <strong>Next Step:</strong> Place the downloaded <code
                class="bg-blue-100 px-1 py-0.5 rounded text-blue-900 font-mono text-xs">config.json</code> file in your
              RoASt root directory (at the same level as the <code
                class="bg-blue-100 px-1 py-0.5 rounded text-blue-900 font-mono text-xs">src</code> folder).
            </div>
          </div>

          <button id="toggle-details-btn"
            class="mt-5 px-5 py-2.5 bg-blue-600 text-white rounded-lg hover:bg-blue-700 text-sm font-semibold shadow-sm hover:shadow-md transition-all">
            Show Full JSON
          </button>
        </div>

        <!-- Full JSON View (hidden by default) -->
        <div id="json-details" class="relative mb-6" style="display: none">
          <div class="max-h-[600px] overflow-y-auto rounded-xl bg-gray-900 shadow-lg">
            <pre
              class="text-white p-6 overflow-x-auto font-mono text-sm leading-relaxed"><code id="json-output"></code></pre>
          </div>
          <button id="copy-btn"
            class="absolute top-4 right-6 bg-gray-700 text-gray-300 hover:bg-gray-600 py-2 px-4 rounded-lg text-xs font-semibold shadow-md hover:shadow-lg transition-all">
            ðŸ“‹ Copy
          </button>
        </div>

        <div
          class="pt-8 mt-6 border-t border-gray-200 flex flex-col-reverse sm:flex-row gap-4 justify-between items-center">
          <button type="button" id="prev-btn-page4"
            class="group w-full sm:w-auto flex items-center justify-center py-3 px-8 border-2 border-gray-300 rounded-lg shadow-sm text-base font-semibold text-gray-700 bg-white hover:bg-gray-50 hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all">
            <svg class="mr-2 w-5 h-5 group-hover:-translate-x-1 transition-transform" fill="none" stroke="currentColor"
              viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
            </svg>
            Back to Simulator
          </button>

          <button id="download-btn"
            class="group w-full sm:w-auto flex items-center justify-center py-3 px-8 border border-transparent rounded-lg shadow-md text-base font-semibold text-white bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all">
            <svg class="mr-2 w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
            </svg>
            Download config.json
          </button>
        </div>
      </div>
    </div>
  </div>

  <div id="dragGhost" style="
        position: fixed;
        pointer-events: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        z-index: 10000;
        display: none;
        border: 2px solid rgba(0, 0, 0, 0.8);
        opacity: 0.9;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      "></div>
  <div id="boundaryGhost" style="
        position: fixed;
        pointer-events: none;
        z-index: 10000;
        display: none;
        background-color: rgba(50, 120, 255, 0.5);
        opacity: 0.7;
      "></div>

  <!-- Help Modal -->
  <div id="goalsHelpModal"
    style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); backdrop-filter: blur(8px); z-index: 10000; overflow-y: auto;">
    <div
      style="position: relative; margin: 50px auto; max-width: 800px; background-color: white; border-radius: 8px; box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);">
      <div
        style="background: #4a5568; color: white; padding: 16px 20px; display: flex; justify-content: space-between; align-items: center; border-radius: 8px 8px 0 0;">
        <h2 style="margin: 0; font-size: 18px; font-weight: 600;">Goals Editor Help</h2>
        <button id="closeHelpModal"
          style="background: transparent; border: none; color: white; font-size: 28px; cursor: pointer; padding: 0; width: 28px; height: 28px; line-height: 1; opacity: 0.8;"
          onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.8'">&times;</button>
      </div>
      <div
        style="padding: 24px; max-height: calc(100vh - 200px); overflow-y: auto; line-height: 1.6; color: #333; font-size: 14px;">

        <h3 style="font-size: 16px; font-weight: 600; margin: 0 0 12px 0; color: #2d3748;">Page 3 Instructions: Goals
        </h3>
        <p style="margin: 0 0 16px 0;">Create the specific scenarios your robots need to solve.</p>

        <div
          style="background: #f7fafc; padding: 14px; border-radius: 6px; margin-bottom: 14px; border-left: 3px solid #4a5568;">
          <strong style="display: block; margin-bottom: 6px; color: #2d3748;">How to Define a Goal:</strong>
          <ol style="margin: 0; padding-left: 20px;">
            <li style="margin-bottom: 6px;">Click <strong>+ Add Goal</strong> to start a new scenario.</li>
            <li style="margin-bottom: 6px;">Place robots on the <strong>Start</strong> grid and the
              <strong>Target</strong> grid.
            </li>
            <li style="margin-bottom: 6px;">Set <strong>Boundaries</strong> by dragging the dashed lines.</li>
            <li style="margin-bottom: 6px;">Add <strong>Waypoints</strong> (locations to visit) or <strong>Exclusive
                Points</strong> (locations to avoid) if needed.</li>
          </ol>
        </div>

        <p style="margin: 0 0 0 0;">Once finished, click <strong>Continue</strong> to generate your final
          <code>config.json</code> file.
        </p>
      </div>
    </div>
  </div>

  <!-- Initial Configuration Editor Help Modal -->
  <div id="initialConfigHelpModal"
    style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); backdrop-filter: blur(8px); z-index: 10000; overflow-y: auto;">
    <div
      style="position: relative; margin: 50px auto; max-width: 800px; background-color: white; border-radius: 8px; box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);">
      <div
        style="background: #4a5568; color: white; padding: 16px 20px; display: flex; justify-content: space-between; align-items: center; border-radius: 8px 8px 0 0;">
        <h2 style="margin: 0; font-size: 18px; font-weight: 600;">Initial Configuration Editor Help</h2>
        <button id="closeInitialConfigHelpModal"
          style="background: transparent; border: none; color: white; font-size: 28px; cursor: pointer; padding: 0; width: 28px; height: 28px; line-height: 1; opacity: 0.8;"
          onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.8'">&times;</button>
      </div>
      <div
        style="padding: 24px; max-height: calc(100vh - 200px); overflow-y: auto; line-height: 1.6; color: #333; font-size: 14px;">

        <h3 style="font-size: 16px; font-weight: 600; margin: 0 0 12px 0; color: #2d3748;">Page 2 Instructions: Initial
          Configurations</h3>
        <p style="margin: 0 0 16px 0;">Define how your robots are positioned at the start of the simulation.</p>

        <div
          style="background: #f7fafc; padding: 14px; border-radius: 6px; margin-bottom: 14px; border-left: 3px solid #4a5568;">
          <strong style="display: block; margin-bottom: 6px; color: #2d3748;">How to Use the Editor:</strong>
          <ol style="margin: 0; padding-left: 20px;">
            <li style="margin-bottom: 6px;">Click <strong>â–¼ Show</strong> to open the visual editor.</li>
            <li style="margin-bottom: 6px;">Click <strong>+ Add Pattern</strong> to create a new movement scenario.</li>
            <li style="margin-bottom: 6px;"><strong>Drag and Drop</strong> robots from the palette onto the grids.</li>
            <li style="margin-bottom: 6px;">Select <strong>Leader Colors</strong> to specify which robots drive the
              meaningful movement.</li>
          </ol>
        </div>

        <p style="margin: 0 0 0 0;">The system automatically generates specific initial positions based on your
          patterns. You can review them in the list below the editor.</p>
      </div>
    </div>
  </div>

  <!-- Parameters (Page 1) Help Modal -->
  <div id="parametersHelpModal"
    style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); backdrop-filter: blur(8px); z-index: 10000; overflow-y: auto;">
    <div
      style="position: relative; margin: 50px auto; max-width: 800px; background-color: white; border-radius: 8px; box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);">
      <div
        style="background: #4a5568; color: white; padding: 16px 20px; display: flex; justify-content: space-between; align-items: center; border-radius: 8px 8px 0 0;">
        <h2 style="margin: 0; font-size: 18px; font-weight: 600;">Parameters Configuration Help</h2>
        <button id="closeParametersHelpModal"
          style="background: transparent; border: none; color: white; font-size: 28px; cursor: pointer; padding: 0; width: 28px; height: 28px; line-height: 1; opacity: 0.8;"
          onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.8'">&times;</button>
      </div>
      <div
        style="padding: 24px; max-height: calc(100vh - 200px); overflow-y: auto; line-height: 1.6; color: #333; font-size: 14px;">

        <h3 style="font-size: 16px; font-weight: 600; margin: 0 0 12px 0; color: #2d3748;">General Purpose</h3>
        <p style="margin: 0 0 16px 0;">This tool helps you create a configuration file (config.json) for the RoASt
          algorithm synthesizer. You will define robot parameters, initial positions, and goals across 4 simple steps.
        </p>

        <h3 style="font-size: 16px; font-weight: 600; margin: 20px 0 12px 0; color: #2d3748;">Page 1 Instructions:
          Parameters</h3>
        <p style="margin: 0 0 16px 0;">Configure the fundamental settings for your robot swarm:</p>

        <ul style="margin: 0; padding-left: 20px;">
          <li style="margin-bottom: 8px;"><strong>Execution Preset:</strong> Select a pre-defined execution config and
            modify it as needed.</li>
          <li style="margin-bottom: 8px;"><strong>Basic Config:</strong> Set the number of robots (e.g., 2), their
            visibility range, and the max generation level.</li>
          <li style="margin-bottom: 8px;"><strong>Obstacle Config:</strong> Choose between Custom Obstacles ('O') or
            Walls ('W').</li>
          <li style="margin-bottom: 8px;"><strong>Robot Colors:</strong> Assign a unique character (e.g., F, L) and
            color to each robot type.</li>
        </ul>

        <div
          style="background: #ebf8ff; padding: 12px; border-radius: 6px; margin-top: 20px; border-left: 4px solid #4299e1;">
          <strong>Tip:</strong> Start with an execution preset to see a working example, then modify it to fit your
          needs!
        </div>
      </div>
    </div>
  </div>

  <div id="error-modal" class="fixed inset-0 z-50 flex items-center justify-center p-4" style="display: none">
    <div id="modal-backdrop" class="fixed inset-0 bg-black bg-opacity-60 modal-backdrop"></div>

    <div class="modal-content bg-white rounded-2xl shadow-2xl w-full max-w-md z-10 transform scale-95 opacity-0">
      <div class="p-6">
        <div class="flex items-start">
          <div
            class="flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-red-100 sm:mx-0 sm:h-10 sm:w-10">
            <svg class="h-6 w-6 text-red-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"
              stroke-width="2" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round"
                d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z" />
            </svg>
          </div>
          <div class="ml-4 text-left flex-1">
            <h3 class="text-lg font-semibold leading-6 text-gray-900">
              Validation Error
            </h3>
            <div class="mt-2">
              <p id="modal-message" class="text-sm text-gray-600 leading-relaxed"></p>
            </div>
          </div>
        </div>
      </div>
      <div class="bg-gray-50 px-6 py-4 sm:flex sm:flex-row-reverse rounded-b-2xl border-t border-gray-200">
        <button id="modal-close-btn" type="button"
          class="w-full inline-flex justify-center rounded-lg border border-transparent shadow-sm px-6 py-2.5 bg-blue-600 text-base font-semibold text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 sm:ml-3 sm:w-auto sm:text-sm transition-all">
          OK
        </button>
      </div>
    </div>
  </div>

  <!-- Add Color Modal -->
  <div id="add-color-modal" class="fixed inset-0 z-50 flex items-center justify-center p-4" style="display: none">
    <div id="add-color-backdrop" class="fixed inset-0 transition-opacity duration-300 opacity-0"
      style="backdrop-filter: blur(4px); background-color: rgba(0, 0, 0, 0.3);"></div>

    <div
      class="relative bg-white rounded-2xl shadow-2xl w-full max-w-md transform transition-all duration-300 scale-95 opacity-0"
      style="z-index: 51">
      <div class="p-6">
        <div class="flex items-start justify-between">
          <h3 class="text-lg font-semibold leading-6 text-gray-900">
            Add Color
          </h3>
          <button type="button" id="add-color-close-btn" class="text-gray-400 hover:text-gray-600 transition-colors">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        <div class="mt-4 space-y-4">
          <div>
            <label for="new-color-char" class="block text-sm font-semibold text-gray-700 mb-2">
              Character
            </label>
            <input type="text" id="new-color-char" maxlength="1" placeholder="e.g., F, L, R"
              class="block w-full rounded-lg border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-center text-lg font-mono" />
            <p id="char-error" class="text-xs text-red-600 mt-1" style="display: none;"></p>
          </div>
          <div>
            <label for="new-color-picker" class="block text-sm font-semibold text-gray-700 mb-2">
              Color
            </label>
            <div class="flex items-center gap-3">
              <input type="color" id="new-color-picker" value="#0000FF"
                class="h-12 w-20 rounded-md border-gray-300 cursor-pointer" />
              <input type="number" id="new-color-decimal" min="0" value="255" placeholder="Decimal value"
                class="flex-1 rounded-lg border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500" />
            </div>
          </div>
        </div>
      </div>

      <div class="bg-gray-50 px-6 py-4 flex justify-end gap-3 rounded-b-2xl border-t border-gray-200">
        <button type="button" id="add-color-cancel-btn"
          class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 text-sm font-medium transition-colors">
          Cancel
        </button>
        <button type="button" id="add-color-confirm-btn"
          class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 text-sm font-medium transition-colors">
          Add
        </button>
      </div>
    </div>
  </div>

  <script src="presets_data.js"></script>
  <script>
    // Global variable to store collected configurations from Page 2
    let collectedConfigurations = [];

    // Global variable for simulator default configuration
    let defaultSimulationConfigList = `{
  "simulation_configs": [
    {
      "is_essential": true,
      "initial_positions": [["R", 0, 1], ["F", -1, 1], ["O", 0, 0]],
      "targets": [[2, [["R", 2, 1], ["F", 1, 1], ["O", 0, 0]], [], []]],
      "boundary": [-2, 3, -1, 2],
      "wall": [null, null]
    }

  ]
}`;

    // Default data from the user's config.json
    const defaultData = algorithmPresets[0].data;

    // --- Modal Functions ---
    const errorModal = document.getElementById("error-modal");
    const modalMessage = document.getElementById("modal-message");
    const modalBackdrop = document.getElementById("modal-backdrop");
    const modalContent = errorModal.querySelector(".modal-content");
    const modalCloseBtn = document.getElementById("modal-close-btn");

    function showModal(message) {
      modalMessage.textContent = message;
      errorModal.style.display = "flex";
      // Trigger transitions
      setTimeout(() => {
        modalBackdrop.classList.remove("opacity-0");
        modalBackdrop.classList.add("opacity-100");
        modalContent.classList.remove("scale-95", "opacity-0");
        modalContent.classList.add("scale-100", "opacity-100");
      }, 10);
    }

    function hideModal() {
      modalBackdrop.classList.remove("opacity-100");
      modalBackdrop.classList.add("opacity-0");
      modalContent.classList.remove("scale-100", "opacity-100");
      modalContent.classList.add("scale-95", "opacity-0");
      setTimeout(() => {
        errorModal.style.display = "none";
      }, 300); // Wait for transition
    }

    modalCloseBtn.addEventListener("click", hideModal);
    modalBackdrop.addEventListener("click", hideModal);

    // --- Helper: Convert hex color to decimal ---
    function hexToDec(hex) {
      return parseInt(hex.replace("#", ""), 16);
    }

    // --- New Color Map from user request ---
    const letterColorMap = {
      L: "#FF0000", // red
      R: "#008000", // green
      F: "#0000FF", // blue
      O: "#FFA500", // orange
      r: "#FF0000", // red
      g: "#008000", // green
      b: "#0000FF", // blue
      o: "#FFA500", // orange
      B: "#0000FF", // blue
      G: "#008000", // green
      Y: "#FFFF00", // yellow
      P: "#800080", // purple
      y: "#FFFF00", // yellow
      p: "#800080", // purple
      W: "#333333",
      w: "#333333",
    };

    // Create a decimal map from the hex map
    const letterDecimalMap = {};
    for (const letter in letterColorMap) {
      letterDecimalMap[letter] = hexToDec(letterColorMap[letter]);
    }

    // --- LOGIC FROM PAGE 2 ---
    // Global store for the generated configurations
    let allLocalConfigs = [];

    // Global variable for current preset selection
    let currentPreset = "0";

    // Global variable for edit mode (will be set from URL parameters)
    let canEdit = true;

    // Track if initial configurations were modified
    let configsWereModified = false;
    let originalPresetConfigs = null;

    // Track if goals need to be reloaded/regenerated when entering Page 3
    let forceGoalsReload = false;

    function generateLocalConfigs(data, visibility, leaderChar) {
      const localConfigs = [];
      if (!data || data.length === 0) return [];

      let min_x = Number.MAX_SAFE_INTEGER,
        max_x = Number.MIN_SAFE_INTEGER;
      let min_y = Number.MAX_SAFE_INTEGER,
        max_y = Number.MIN_SAFE_INTEGER;

      for (const [, x, y] of data) {
        min_x = Math.min(min_x, x - visibility);
        max_x = Math.max(max_x, x + visibility);
        min_y = Math.min(min_y, y - visibility);
        max_y = Math.max(max_y, y + visibility);
      }

      for (let y = min_y; y <= max_y; y++) {
        for (let x = min_x; x <= max_x; x++) {
          if (data.some(([, rx, ry]) => rx === x && ry === y)) continue;

          for (const [, rx, ry] of data) {
            if (Math.abs(x - rx) + Math.abs(y - ry) <= visibility) {
              // Get the obstacle type from Page 1
              const obstacleType = document.getElementById("obstacle_type").value;
              const config = [
                [obstacleType, x, y],
                ...data.map(([l, lx, ly]) => [l.charAt(0), lx, ly]),
              ];

              // Normalize coordinates so obstacle 'O' is at (0,0)
              const obstacle_x = x;
              const obstacle_y = y;
              const normalizedConfig = config.map(([ch, px, py]) => [
                ch,
                px - obstacle_x,
                py - obstacle_y,
              ]);

              const isLeaderConfig = checkLeaderConfiguration(
                normalizedConfig,
                visibility,
                leaderChar
              );
              const robotsCanSeeEachOther =
                checkRobotsVisibility(normalizedConfig);
              localConfigs.push({
                config: normalizedConfig,
                isLeader: isLeaderConfig,
                robotsCanSeeEachOther: robotsCanSeeEachOther,
              });
              break;
            }
          }
        }
      }
      return localConfigs;
    }

    // Helper function to check if a character is an obstacle (O or W)
    function isObstacle(ch) {
      return ch === "O" || ch === "W";
    }

    function checkRobotsVisibility(config) {
      const visibility = parseInt(document.getElementById("visibility_range").value) || 2;
      const isOpaque = document.getElementById("is_obstacle_opaque").checked;

      const obstacle = config.find(([ch]) => isObstacle(ch));
      const robots = config.filter(([ch]) => !isObstacle(ch));

      if (robots.length < 2) return true;

      // Check visibility for each robot - at least one robot must see all others
      for (let i = 0; i < robots.length; i++) {
        const [, x1, y1] = robots[i];
        let canSeeAll = true;

        for (let j = 0; j < robots.length; j++) {
          if (i === j) continue;

          const [, x2, y2] = robots[j];

          // Check distance (Manhattan distance)
          const distance = Math.abs(x1 - x2) + Math.abs(y1 - y2);
          if (distance > visibility) {
            canSeeAll = false;
            break;
          }

          // If obstacle is opaque, check if it blocks the view
          if (isOpaque && obstacle) {
            const [, ox, oy] = obstacle;

            // Check if obstacle is on the line of sight between robots
            // For simplicity, we check horizontal, vertical, and diagonal lines
            const isBlocked = isObstacleBlocking(x1, y1, x2, y2, ox, oy);
            if (isBlocked) {
              canSeeAll = false;
              break;
            }
          }
        }

        // If this robot can see all others, the config is valid
        if (canSeeAll) {
          return true;
        }
      }

      return false; // No robot can see all others
    }

    // Helper function to check if obstacle blocks line of sight between two points
    function isObstacleBlocking(x1, y1, x2, y2, ox, oy) {
      // Check if obstacle is on a straight line (horizontal, vertical, or diagonal)

      // Horizontal line
      if (y1 === y2 && y1 === oy) {
        if (ox > Math.min(x1, x2) && ox < Math.max(x1, x2)) {
          return true;
        }
      }

      // Vertical line
      if (x1 === x2 && x1 === ox) {
        if (oy > Math.min(y1, y2) && oy < Math.max(y1, y2)) {
          return true;
        }
      }

      // Diagonal line (slope = 1)
      if (Math.abs(x2 - x1) === Math.abs(y2 - y1)) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const steps = Math.abs(dx);

        for (let step = 1; step < steps; step++) {
          const ix = x1 + (dx > 0 ? step : -step);
          const iy = y1 + (dy > 0 ? step : -step);
          if (ix === ox && iy === oy) {
            return true;
          }
        }
      }

      return false;
    }

    function checkLeaderConfiguration(config, visibility, leaderChars) {
      const obstacle = config.find(([ch]) => isObstacle(ch));
      if (!obstacle) return false;

      const [, ox, oy] = obstacle;
      const robots = config.filter(([ch]) => !isObstacle(ch));

      // Find all robots that can see the obstacle
      const visibleRobots = robots.filter(([ch, rx, ry]) => {
        const dist = Math.abs(ox - rx) + Math.abs(oy - ry);
        return dist <= visibility;
      });

      // Rule 1: Must have at least one visible robot
      if (visibleRobots.length === 0) return false;

      // Rule 2: ALL visible robots must be Leaders
      const allVisibleAreLeaders = visibleRobots.every(([ch]) =>
        leaderChars.includes(ch)
      );
      if (!allVisibleAreLeaders) return false;

      // Rule 3: ALL visible robots must be at the exact visibility limit (Essential/Boundary condition)
      // AND
      // Rule 4: ALL visible robots must be to the left or same X as obstacle (approaching from left)
      // If rx > ox, the robot is to the right of the obstacle. Since movement is to the right,
      // the robot is moving away from the obstacle and has "passed" it.
      const validPosition = visibleRobots.every(([ch, rx, ry]) => {
        const dist = Math.abs(ox - rx) + Math.abs(oy - ry);
        const isAtLimit = dist === visibility;
        const isNotPast = rx <= ox;
        return isAtLimit && isNotPast;
      });

      if (!validPosition) return false;

      return true;
    }

    /**
     * Checks if a configuration is "essential" (boundary condition).
     * This logic mirrors Rule 3 of checkLeaderConfiguration:
     * ALL visible robots must be at the exact visibility limit.
     */
    function isEssential(config, visibility, leaderChars) {
      const obstacle = config.find(([ch]) => isObstacle(ch));
      if (!obstacle) return false;

      const [, ox, oy] = obstacle;
      const robots = config.filter(([ch]) => !isObstacle(ch));

      // Find all robots that can see the obstacle
      const visibleRobots = robots.filter(([ch, rx, ry]) => {
        const dist = Math.abs(ox - rx) + Math.abs(oy - ry);
        return dist <= visibility;
      });

      if (visibleRobots.length === 0) return false;

      // Check if all visible robots are leaders
      const allVisibleAreLeaders = visibleRobots.every(([ch]) =>
        leaderChars.includes(ch)
      );
      if (!allVisibleAreLeaders) return false;

      // Check if all visible robots are at the exact visibility limit
      const allAtLimit = visibleRobots.every(([ch, rx, ry]) => {
        const dist = Math.abs(ox - rx) + Math.abs(oy - ry);
        return dist === visibility;
      });

      return allAtLimit;
    }

    function createGrid(
      config,
      visibility,
      title,
      standardBounds,
      isLeader = false,
      isExcluded = false,
      showToggle = true
    ) {
      const wrapper = document.createElement("div");
      wrapper.className = "grid-wrapper relative";
      if (isLeader) {
        wrapper.classList.add("leader-config");
      }
      if (isExcluded) {
        wrapper.classList.add("excluded");
      }

      // Add toggle button for essential flag (positioned absolutely in top-right)
      // Only show for initial configurations, not movement patterns
      if (showToggle) {
        const toggleBtn = document.createElement("button");
        toggleBtn.type = "button";
        toggleBtn.className = "absolute top-2 right-2 z-10 px-2 py-1 text-xs rounded transition-colors";
        toggleBtn.dataset.essential = isLeader.toString();

        function updateToggleBtn() {
          const isEssential = toggleBtn.dataset.essential === "true";
          if (isEssential) {
            if (canEdit) {
              toggleBtn.className = "absolute top-2 right-2 z-10 px-2 py-1 text-xs rounded bg-green-600 text-white hover:bg-green-700 transition-colors";
            } else {
              toggleBtn.className = "absolute top-2 right-2 z-10 px-2 py-1 text-xs rounded bg-green-300 text-green-700 transition-colors opacity-60 cursor-not-allowed";
            }
            toggleBtn.textContent = "Essential";
            // Add red animation class to wrapper
            wrapper.classList.add("leader-config");
          } else {
            if (canEdit) {
              toggleBtn.className = "absolute top-2 right-2 z-10 px-2 py-1 text-xs rounded bg-gray-300 text-gray-700 hover:bg-gray-400 transition-colors";
            } else {
              toggleBtn.className = "absolute top-2 right-2 z-10 px-2 py-1 text-xs rounded bg-gray-200 text-gray-500 transition-colors opacity-60 cursor-not-allowed";
            }
            toggleBtn.textContent = "Not Essential";
            // Remove red animation class
            wrapper.classList.remove("leader-config");
          }
        }

        updateToggleBtn();

        toggleBtn.addEventListener("click", () => {
          // Only allow toggling when edit is enabled
          if (!canEdit) {
            return;
          }
          const currentValue = toggleBtn.dataset.essential === "true";
          toggleBtn.dataset.essential = (!currentValue).toString();
          updateToggleBtn();

          // Update status label to indicate modification
          const configStatusLabel = document.getElementById('config-status-label');
          if (configStatusLabel) {
            configStatusLabel.textContent = 'Modified';
            configStatusLabel.className = 'ml-2 px-2 py-1 text-xs font-medium rounded bg-orange-100 text-orange-800';
            configStatusLabel.style.display = 'inline-block';
          }
        });

        wrapper.appendChild(toggleBtn);
      }

      const titleContainer = document.createElement("div");
      titleContainer.className = "mb-2";

      const titleElement = document.createElement("h3");
      titleElement.className = "grid-title";
      titleElement.textContent = title;

      titleContainer.appendChild(titleElement);
      wrapper.appendChild(titleContainer);

      // Use standardized bounds passed as parameter
      const min_x = standardBounds.min_x;
      const max_x = standardBounds.max_x;
      const min_y = standardBounds.min_y;
      const max_y = standardBounds.max_y;

      const width = max_x - min_x;
      const height = max_y - min_y;

      // Create canvas (similar to goals_simulator_v4_viewer)
      const canvas = document.createElement("canvas");
      canvas.className = "view-canvas";
      const cellSize = 25; // FRAME_SCALE from goals_simulator
      const padding = 30;
      canvas.width = width * cellSize + padding * 2;
      canvas.height = height * cellSize + padding * 2;

      const ctx = canvas.getContext("2d");
      const offsetX = padding;
      const offsetY = padding;

      // Helper to convert world coords to canvas coords
      const worldToCanvas = (wx, wy) => ({
        cx: offsetX + (wx - min_x) * cellSize,
        cy: offsetY + (max_y - wy) * cellSize, // Flip Y axis
      });

      // Draw grid lines
      ctx.strokeStyle = "#e8e8e8";
      ctx.lineWidth = 1;
      for (let i = 0; i <= width; i++) {
        const x = offsetX + i * cellSize;
        ctx.beginPath();
        ctx.moveTo(x, offsetY);
        ctx.lineTo(x, offsetY + height * cellSize);
        ctx.stroke();
      }
      for (let i = 0; i <= height; i++) {
        const y = offsetY + i * cellSize;
        ctx.beginPath();
        ctx.moveTo(offsetX, y);
        ctx.lineTo(offsetX + width * cellSize, y);
        ctx.stroke();
      }

      // Draw coordinate labels
      ctx.fillStyle = "#666";
      ctx.font = "10px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      // X-axis labels (bottom)
      for (let wx = min_x; wx <= max_x; wx++) {
        const { cx } = worldToCanvas(wx, min_y);
        ctx.fillText(wx, cx, offsetY + height * cellSize + 15);
      }

      // Y-axis labels (left)
      ctx.textAlign = "right";
      for (let wy = min_y; wy <= max_y; wy++) {
        const { cy } = worldToCanvas(min_x, wy);
        ctx.fillText(wy, offsetX - 10, cy);
      }

      // --- Added Axis Labels ---
      ctx.font = "italic bold 12px Times New Roman";
      ctx.fillStyle = "#000";

      // Draw 'x' at the end of the X-axis
      ctx.textAlign = "left";
      ctx.fillText(
        "x",
        offsetX + width * cellSize + 10,
        offsetY + height * cellSize + 15
      );

      // Draw 'y' at the top of the Y-axis
      ctx.textAlign = "center";
      ctx.fillText("y", offsetX - 10, offsetY - 10);
      // -------------------------

      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      // Draw visibility range for each robot (excluding obstacle)
      const robots = config.filter(([ch]) => !isObstacle(ch));
      ctx.strokeStyle = "#87ceeb"; // Light blue for visibility
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 3]); // Dashed line

      robots.forEach(([ch, rx, ry]) => {
        const { cx, cy } = worldToCanvas(rx, ry);

        // Draw Manhattan distance diamond (not Euclidean circle)
        const visibilityPx = visibility * cellSize;

        // Draw diamond shape representing Manhattan distance
        ctx.beginPath();
        ctx.moveTo(cx, cy - visibilityPx); // Top
        ctx.lineTo(cx + visibilityPx, cy); // Right
        ctx.lineTo(cx, cy + visibilityPx); // Bottom
        ctx.lineTo(cx - visibilityPx, cy); // Left
        ctx.closePath();
        ctx.stroke();
      });

      ctx.setLineDash([]); // Reset to solid line

      // Draw robots and obstacle on nodes (intersections)
      config.forEach(([ch, x, y]) => {
        const { cx, cy } = worldToCanvas(x, y);

        ctx.beginPath();
        ctx.arc(cx, cy, 8, 0, 2 * Math.PI); // radius 8 like goals_simulator

        // Use color from letterColorMap
        const hexColor = letterColorMap[ch] || "#808080";
        ctx.fillStyle = hexColor;
        ctx.fill();

        // Add border
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 2;
        ctx.stroke();

        // Add letter label
        ctx.fillStyle = "#fff";
        ctx.font = "bold 12px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(ch, cx, cy);
      });

      wrapper.appendChild(canvas);
      return wrapper;
    }

    /**
     * Renders all grids and auto-populates the hidden JSON field.
     */
    function renderAllAndPopulate() {
      const outputDiv = document.getElementById("output-container");
      outputDiv.innerHTML = "";

      // **MODIFIED:** Read visibility from Page 1
      const visibilityInput = document.getElementById("visibility_range");
      const visibility = parseInt(visibilityInput.value, 10);
      if (isNaN(visibility)) {
        showModal("Please set a valid 'Visibility Range' on Page 1.");
        visibilityInput.focus();
        return;
      }

      const leaderChars = Array.from(
        document.querySelectorAll(".leader-color-checkbox:checked")
      ).map((cb) => cb.value);
      // Allow empty leader selection - will generate configs without leader validation
      const robotsMustSeeEachOther =
        document.getElementById("is_obstacle_opaque").checked;
      let data;
      try {
        data = JSON.parse(document.getElementById("robotData").value);
      } catch (e) {
        showModal(`Invalid Robot Data JSON: ${e.message}`);
        return;
      }

      // Use fixed bounds based on number of robots * visibility
      const numRobots = parseInt(
        document.getElementById("number_of_robots").value,
        10
      );
      const gridRange = numRobots * visibility;
      const standardBounds = {
        min_x: -gridRange,
        max_x: gridRange,
        min_y: -gridRange,
        max_y: gridRange,
      };

      // Clear and repopulate the global configs array
      allLocalConfigs = [];

      // Add Movement Patterns
      data.forEach((localView, i) => {
        const grid = createGrid(
          localView,
          visibility,
          `Movement Pattern ${i}`,
          standardBounds,
          false,
          false,
          false
        );
        grid.dataset.configType = "movement-pattern";
        outputDiv.appendChild(grid);
      });

      // Check if preset has initial_configurations
      let presetInitialConfigs = null;
      console.log("Current preset value:", currentPreset);
      const index = parseInt(currentPreset, 10);
      console.log("Preset index:", index);
      const preset = algorithmPresets[index];
      console.log("Preset object:", preset);
      if (preset && preset.data && preset.data.initial_configurations) {
        presetInitialConfigs = preset.data.initial_configurations;
        console.log("Found preset initial_configurations:", presetInitialConfigs.length);
      } else {
        console.log("No initial_configurations in preset");
      }

      // Generate or load initial configurations
      const statusLabel = document.getElementById('config-status-label');
      const resetBtn = document.getElementById('resetInitialConfigBtn');

      // Check if configurations should be regenerated due to modifications
      const shouldRegenerate = configsWereModified || !presetInitialConfigs || presetInitialConfigs.length === 0;

      if (presetInitialConfigs && presetInitialConfigs.length > 0 && !configsWereModified) {
        // Use preset initial configurations (unmodified)
        console.log(`Loading ${presetInitialConfigs.length} initial configurations from preset`);

        // Store original preset configs for reset functionality
        if (!originalPresetConfigs) {
          originalPresetConfigs = JSON.parse(JSON.stringify(presetInitialConfigs));
        }

        if (statusLabel) {
          statusLabel.textContent = 'Loaded from Preset';
          statusLabel.className = 'ml-2 px-2 py-1 text-xs font-medium rounded bg-blue-100 text-blue-800';
          statusLabel.style.display = 'inline-block';
        }

        // Hide reset button when using original preset
        if (resetBtn) {
          resetBtn.style.display = 'none';
        }

        presetInitialConfigs.forEach(([config, isEssential], i) => {
          const robotsCanSeeEachOther = checkRobotsVisibility(config);

          // Recalculate leader status based on current leader colors checkboxes
          const isLeaderConfig = checkLeaderConfiguration(config, visibility, leaderChars);

          allLocalConfigs.push({
            config: config,
            isLeader: isLeaderConfig,
            robotsCanSeeEachOther: robotsCanSeeEachOther,
            isEssential: isEssential  // Store the original essential value from config
          });
        });
      } else {
        // Generate initial configurations from movement patterns
        console.log("Generating initial configurations from movement patterns");

        if (statusLabel) {
          if (configsWereModified && presetInitialConfigs && presetInitialConfigs.length > 0) {
            statusLabel.textContent = 'Modified - Regenerated';
            statusLabel.className = 'ml-2 px-2 py-1 text-xs font-medium rounded bg-orange-100 text-orange-800';
          } else {
            statusLabel.textContent = 'Auto-Generated';
            statusLabel.className = 'ml-2 px-2 py-1 text-xs font-medium rounded bg-green-100 text-green-800';
          }
          statusLabel.style.display = 'inline-block';
        }

        // Show reset button if configurations were modified and we have original preset
        if (resetBtn && originalPresetConfigs && canEdit) {
          resetBtn.style.display = 'inline-block';
        }

        data.forEach((localView) => {
          allLocalConfigs.push(
            ...generateLocalConfigs(localView, visibility, leaderChars)
          );
        });
      }

      // Display initial configurations
      allLocalConfigs.forEach((configObj, i) => {
        // Mark as excluded if robots cannot see each other (invalid config)
        const isExcluded = !configObj.robotsCanSeeEachOther;
        // Use the stored isEssential value if available, otherwise fall back to isLeader
        const essentialValue = configObj.hasOwnProperty('isEssential') ? configObj.isEssential : configObj.isLeader;
        const grid = createGrid(
          configObj.config,
          visibility,
          `Initial Config ${i}`,
          standardBounds,
          essentialValue,
          isExcluded,
          true
        );
        grid.dataset.configType = "initial-config";
        outputDiv.appendChild(grid);
      });

      // Store the interactive grids data directly in moving_on_space_pattern
      document.getElementById("moving_on_space_pattern").value =
        document.getElementById("robotData").value;
    }

    /**
     * Generates the final JSON array for list_of_initial_positions
     * based on the generated configs.
     */
    function generatePositionsJSON() {
      const robotsMustSeeEachOther =
        document.getElementById("is_obstacle_opaque").checked;

      const finalConfigs = [];

      allLocalConfigs.forEach((configObj) => {
        // Skip excluded configs if filter is enabled
        if (robotsMustSeeEachOther && !configObj.robotsCanSeeEachOther) {
          return;
        }

        const config = configObj.config;
        const isLeader = configObj.isLeader;
        const oPoint = config.find(([l]) => isObstacle(l));
        if (!oPoint) return;

        const [, ox, oy] = oPoint;
        // Normalize config relative to the obstacle
        const normalizedConfig = config.map(([l, x, y]) => [
          l,
          x - ox,
          y - oy,
        ]);

        finalConfigs.push([normalizedConfig, isLeader]);
      });

      return finalConfigs;
    }

    // --- END OF LOGIC FROM PAGE 2 ---

    /**
     * Generates the web algorithm initial configuration grid
     * based on the first essential collected config
     */
    function generateWebAlgoConfiguration() {
      const numRobots =
        parseInt(document.getElementById("number_of_robots").value, 10) || 3;
      const visibility =
        parseInt(document.getElementById("visibility_range").value, 10) || 1;

      // Calculate grid size: ((NUMBER_OF_ROBOTS + 1) * VISIBILITY_RANGE) * 2 + 1
      const basicGridLen = (numRobots + 1) * visibility * 2 + 1;

      // Add padding for walls and dots
      const totalSize = basicGridLen + 4; // 2 dots + wall on each side

      // Create empty grid filled with dots
      let grid = Array(totalSize)
        .fill()
        .map(() => Array(totalSize).fill("."));

      // Calculate wall boundaries (1 dot padding + wall)
      const wallStart = 1;
      const wallEnd = totalSize - 2;
      const innerStart = 2;
      const innerEnd = totalSize - 3;

      // Add walls
      for (let i = wallStart; i <= wallEnd; i++) {
        for (let j = wallStart; j <= wallEnd; j++) {
          if (
            i === wallStart ||
            i === wallEnd ||
            j === wallStart ||
            j === wallEnd
          ) {
            grid[i][j] = "W";
          }
        }
      }

      // Get the first initial configuration from allLocalConfigs
      let firstEssentialConfig = null;

      console.log("=== Getting first initial config ===");
      console.log(
        "All local configs (initial configurations):",
        allLocalConfigs
      );

      if (allLocalConfigs && allLocalConfigs.length > 0) {
        // Just use the first config, no need to check for essential
        if (allLocalConfigs[0] && allLocalConfigs[0].config && Array.isArray(allLocalConfigs[0].config)) {
          firstEssentialConfig = allLocalConfigs[0].config;
          console.log(
            "Using first initial config:",
            firstEssentialConfig
          );
        }
      } else {
        console.log(
          "No initial configurations available in allLocalConfigs"
        );
      }

      console.log("=== Final first essential config ===");
      console.log(firstEssentialConfig);
      console.log("=====================================");

      // Calculate the center of the grid (both X and Y center)
      const centerX = Math.floor(totalSize / 2);
      const centerY = Math.floor(totalSize / 2);

      console.log("Grid info:", {
        totalSize,
        centerX,
        centerY,
        innerStart,
        innerEnd,
      });
      console.log("First essential config:", firstEssentialConfig);

      if (firstEssentialConfig && Array.isArray(firstEssentialConfig)) {
        console.log("Placing robots from config...");

        // Find the obstacle position in the config to use as reference
        let obstacleX = 0, obstacleY = 0;
        for (const robotData of firstEssentialConfig) {
          if (Array.isArray(robotData) && robotData.length >= 3) {
            const [letter] = robotData;
            if (letter === 'O' || letter === 'W') {
              obstacleX = robotData[1];
              obstacleY = robotData[2];
              console.log(`Found obstacle at (${obstacleX}, ${obstacleY})`);
              break;
            }
          }
        }

        // Now place all robots, adjusting positions so obstacle is at center
        for (let i = 0; i < firstEssentialConfig.length; i++) {
          const robotData = firstEssentialConfig[i];
          console.log("Processing robot data:", robotData);
          if (Array.isArray(robotData) && robotData.length >= 3) {
            const [letter, relX, relY] = robotData;

            // Calculate position relative to obstacle, then place at grid center
            const adjustedX = relX - obstacleX;
            const adjustedY = relY - obstacleY;

            // grid[row][col] where row 0 is at TOP, so Y-axis is inverted
            const gridRow = centerY - adjustedY; // Y coordinate (row) - INVERTED for top-to-bottom grid
            const gridCol = centerX + adjustedX; // X coordinate (column)

            console.log(
              `Robot ${letter}: config(${relX},${relY}) -> adjusted(${adjustedX},${adjustedY}) -> grid[${gridRow}][${gridCol}]`
            );

            // Check bounds within inner area
            if (
              gridRow >= innerStart &&
              gridRow <= innerEnd &&
              gridCol >= innerStart &&
              gridCol <= innerEnd
            ) {
              grid[gridRow][gridCol] = letter;
              console.log(`Placed ${letter} at (${gridRow},${gridCol})`);
            } else {
              console.log(
                `Robot ${letter} out of bounds: (${gridRow},${gridCol}) not in [${innerStart},${innerEnd}]`
              );
            }
          }
        }
      } else {
        console.log("No config found, placing fallback robots for testing");
        // Fallback: place test robots if no config available
        // Place F, L, O in positions similar to your example
        grid[centerY - 1][centerX - 2] = "F"; // F at (-2, -1)
        grid[centerY - 1][centerX] = "L"; // L at (0, -1)
        grid[centerY][centerX] = "O"; // O at (0, 0)
        console.log(
          `Placed fallback robots: F at (${centerY - 1},${centerX - 2
          }), L at (${centerY - 1},${centerX}), O at (${centerY},${centerX})`
        );
      }

      // Convert grid to string
      const configString = grid.map((row) => row.join("")).join("\n");
      console.log("Generated config string:");
      console.log(configString);
      console.log("Config string length:", configString.length);
      console.log(
        "Grid dimensions:",
        `${totalSize}Ã—${totalSize} (${basicGridLen}Ã—${basicGridLen} inner + walls + padding)`
      );

      console.log(
        "Returning config string from generateWebAlgoConfiguration"
      );
      return configString;
    }

    // --- Form Functions ---
    document.addEventListener("DOMContentLoaded", () => {
      // Parse URL parameters
      const urlParams = new URLSearchParams(window.location.search);
      const urlPreset = urlParams.get('preset');
      const urlEdit = urlParams.get('edit');

      // Set global flag to control editability
      canEdit = urlEdit === null || urlEdit === 'true'; // Default to true if not specified

      console.log('URL Parameters:', { preset: urlPreset, edit: urlEdit, canEdit });

      const jsonOutput = document.getElementById("json-output");
      const copyBtn = document.getElementById("copy-btn");
      const downloadBtn = document.getElementById("download-btn");

      const genModeSelect = document.getElementById("generation_mode_select");
      const genModeValueContainer = document.getElementById(
        "generation_mode_value_container"
      );
      const genModeValueInput = document.getElementById(
        "generation_mode_value"
      );

      const colorLettersInput = document.getElementById(
        "color_letters_input"
      );
      const colorPickerContainer = document.getElementById(
        "color_picker_container"
      );

      // --- Preset Data for Each Algorithm ---


      const presetSelect = document.getElementById("algorithm_preset");

      // Populate preset options
      function populatePresetOptions() {
        presetSelect.innerHTML = "";

        algorithmPresets.forEach((preset, index) => {
          const option = document.createElement("option");
          option.value = index;
          option.textContent = preset.title;
          presetSelect.appendChild(option);
        });

        // Set default selection (first one)
        presetSelect.value = "0";
      }

      populatePresetOptions();
      const presetFields = [
        "number_of_robots",
        "visibility_range",
        "existing_algorithm_path",
        "obstacle_type",
        "is_obstacle_opaque",
        "opacity",
        "generation_mode_select",
        "generation_mode_value",
        "list_of_initial_positions",
      ];

      // currentPreset is now declared globally at the top of the script

      function applyAlgorithmPreset(presetName) {
        // Enable/disable fields based on canEdit flag
        presetFields.forEach((fieldId) => {
          const field = document.getElementById(fieldId);
          const badge = document.getElementById(`badge_${fieldId}`);

          if (field) {
            field.disabled = !canEdit;
            if (!canEdit) {
              field.classList.add("bg-gray-100", "cursor-not-allowed");
            } else {
              field.classList.remove("bg-gray-100", "cursor-not-allowed");
            }
          }

          // Show/hide Fixed badge
          if (badge) {
            badge.style.display = canEdit ? "none" : "inline-flex";
          }
        });

        // Enable/disable Add Color button
        const addColorBtn = document.getElementById("add_color_btn");
        if (addColorBtn) {
          addColorBtn.disabled = !canEdit;
        }

        // Show/hide Fixed badge for Algorithm Colors
        const colorLettersBadge = document.getElementById("badge_color_letters_input");
        if (colorLettersBadge) {
          colorLettersBadge.style.display = canEdit ? "none" : "inline-flex";
        }

        // Update delete buttons visibility on color pickers
        updateColorPickerDeleteButtons(!canEdit);

        // Update toggle buttons styling based on canEdit
        const toggleButtons = document.querySelectorAll('button[data-essential]');
        toggleButtons.forEach(btn => {
          if (!canEdit) {
            btn.classList.add('opacity-50', 'cursor-not-allowed');
          } else {
            btn.classList.remove('opacity-50', 'cursor-not-allowed');
          }
        });

        // Apply preset values
        const index = parseInt(presetName, 10);
        const preset = algorithmPresets[index];
        if (preset && preset.data) {
          // Use populateForm to load all the preset data
          populateForm(preset.data);

          // Also update leader colors checkboxes
          populateLeaderColors(preset.data.leader_colors);

          // Load goals from preset if available
          if (preset.data.goals && preset.data.goals.length > 0) {
            window.loadedGoalsData = preset.data.goals;
            console.log("Loaded goals from preset:", window.loadedGoalsData.length);
          }
        }

        // Update obstacle opaque state after applying preset
        updateObstacleOpaque();

        // Update goals simulator state (enable/disable controls)
        updateGoalsSimulatorState();
      }

      presetSelect.addEventListener("change", (e) => {
        currentPreset = e.target.value;
        // Clear any loaded goals data when switching presets
        if (window.loadedGoalsData) {
          delete window.loadedGoalsData;
          console.log("Cleared loaded goals data due to preset change");
        }
        applyAlgorithmPreset(currentPreset);
        updatePresetDescription(currentPreset);
      });

      // Function to update preset description
      function updatePresetDescription(presetName) {
        const descriptionElement = document.getElementById("preset_description");
        if (!descriptionElement) return;

        if (presetName === "custom") {
          descriptionElement.textContent = "Custom loaded configuration";
        } else {
          const index = parseInt(presetName, 10);
          const preset = algorithmPresets[index];
          if (preset && preset.description) {
            descriptionElement.textContent = preset.description;
          } else {
            descriptionElement.textContent = "";
          }
        }
      }

      // --- Obstacle Type Handler ---
      const obstacleTypeSelect = document.getElementById("obstacle_type");
      const obstacleOpaqueCheckbox = document.getElementById("is_obstacle_opaque");

      // Function to update obstacle opaque based on obstacle type
      function updateObstacleOpaque() {
        if (obstacleTypeSelect.value === "W") {
          // Wall obstacle - automatically check and disable the checkbox
          obstacleOpaqueCheckbox.checked = true;
          obstacleOpaqueCheckbox.disabled = true;
          // Also update simulator palette to reflect wall obstacle
          updateSimulatorPalette();
        } else {
          // Custom obstacle - check if edit is enabled
          // Only enable if edit is allowed
          obstacleOpaqueCheckbox.disabled = !canEdit;
          // Update palette for custom obstacle
          updateSimulatorPalette();
        }
      }

      // Add event listener for obstacle type changes
      obstacleTypeSelect.addEventListener("change", () => {
        updateObstacleOpaque();
        // Mark initial configurations as modified to force regeneration
        configsWereModified = true;
        console.log("Obstacle type changed - initial configurations will be regenerated");
      });

      // Add event listener for obstacle opacity changes
      obstacleOpaqueCheckbox.addEventListener("change", () => {
        // Mark initial configurations as modified to force regeneration
        configsWereModified = true;
        console.log("Obstacle opacity changed - initial configurations will be regenerated");
      });

      // Add event listener for visibility range changes
      const visibilityRangeInput = document.getElementById("visibility_range");
      if (visibilityRangeInput) {
        visibilityRangeInput.addEventListener("change", () => {
          configsWereModified = true;
          console.log("Visibility range changed - initial configurations will be regenerated");
        });
      }

      // Initialize obstacle opaque state
      updateObstacleOpaque();

      // Function to update goals simulator state based on preset
      function updateGoalsSimulatorState() {
        const robotPalette = document.querySelector(".robot-palette");
        const goalsFixedLabel = document.getElementById("goals-fixed-label");

        // Always show robot palette, just control draggability
        if (robotPalette) {
          const paletteRobots = robotPalette.querySelectorAll(".palette-robot, .palette-waypoint, .palette-exclusive-point");
          paletteRobots.forEach(el => {
            if (canEdit) {
              el.style.cursor = "grab";
              el.style.opacity = "1";
            } else {
              el.style.cursor = "not-allowed";
              el.style.opacity = "0.5";
            }
          });
        }

        if (goalsFixedLabel) {
          goalsFixedLabel.style.display = canEdit ? "none" : "flex";
        }

        // Update add grid buttons and steps inputs in all frames
        const addGridBtns = document.querySelectorAll(".add-grid-btn");
        addGridBtns.forEach(btn => {
          btn.disabled = !canEdit;
          btn.style.opacity = canEdit ? "1" : "0.5";
          btn.style.cursor = canEdit ? "pointer" : "not-allowed";
        });

        const stepsInputs = document.querySelectorAll(".grid-steps-control input");
        stepsInputs.forEach(input => {
          input.disabled = !canEdit;
          input.style.opacity = canEdit ? "1" : "0.5";
          input.style.cursor = canEdit ? "auto" : "not-allowed";
        });

        // Update addGridBtn on page 2 (Initial Configuration Editor)
        const addGridBtn = document.getElementById("addGridBtn");
        if (addGridBtn) {
          addGridBtn.disabled = !canEdit;
          addGridBtn.style.opacity = canEdit ? "1" : "0.5";
          addGridBtn.style.cursor = canEdit ? "pointer" : "not-allowed";
        }
      }

      // Initial Configuration Editor Toggle Function
      let initialConfigVisible = false;
      const toggleInitialConfigBtn = document.getElementById("toggleInitialConfigBtn");
      const initialConfigContent = document.getElementById("initialConfigContent");

      function toggleInitialConfigEditor() {
        // Only allow toggle if canEdit is true
        if (!canEdit) return;

        initialConfigVisible = !initialConfigVisible;

        if (initialConfigVisible) {
          initialConfigContent.style.display = "block";
          toggleInitialConfigBtn.textContent = "â–² Hide";
        } else {
          initialConfigContent.style.display = "none";
          toggleInitialConfigBtn.textContent = "â–¼ Show";
        }
      }

      // Set up toggle button
      if (toggleInitialConfigBtn) {
        toggleInitialConfigBtn.addEventListener("click", toggleInitialConfigEditor);

        // Control button appearance based on canEdit
        if (!canEdit) {
          // Disabled style - gray colors with reduced opacity
          toggleInitialConfigBtn.className = "px-3 py-1.5 text-sm font-medium rounded-md bg-gray-500 text-gray-200 cursor-not-allowed";
          toggleInitialConfigBtn.style.opacity = "0.6";
          toggleInitialConfigBtn.style.pointerEvents = "none";

          // Show Fixed badge
          const badgeInitialConfigEditor = document.getElementById("badge_initial_config_editor");
          if (badgeInitialConfigEditor) {
            badgeInitialConfigEditor.style.display = "inline-flex";
          }
        } else {
          // Enabled style - blue colors
          toggleInitialConfigBtn.className = "px-3 py-1.5 text-sm font-medium transition-colors rounded-md bg-blue-600 text-white hover:bg-blue-700";
          toggleInitialConfigBtn.style.opacity = "1";
          toggleInitialConfigBtn.style.pointerEvents = "auto";
        }
      }

      // Initialize collapsible state - always start closed
      function initializeInitialConfigState() {
        // Always start closed
        initialConfigVisible = false;
        initialConfigContent.style.display = "none";
        toggleInitialConfigBtn.textContent = "â–¼ Show";
      }

      // Initialize with URL preset or first preset by default
      const presetLockedBadge = document.getElementById("preset_locked_badge");
      if (urlPreset !== null) {
        const presetIndex = parseInt(urlPreset, 10);
        if (!isNaN(presetIndex) && presetIndex >= 0 && presetIndex < algorithmPresets.length) {
          currentPreset = urlPreset;
          presetSelect.value = urlPreset;
        } else {
          currentPreset = "0";
        }
      } else {
        currentPreset = "0";
      }

      // Disable preset dropdown and show note based on canEdit (not preset parameter)
      if (!canEdit) {
        presetSelect.disabled = true;
        const presetEditNote = document.getElementById("preset_edit_note");
        if (presetEditNote) {
          presetEditNote.style.display = "block";
        }

        // Also show edit notes on pages 2 and 3 when preset is loaded
        const initialConfigEditNote = document.getElementById("initial_config_edit_note");
        const goalsEditNote = document.getElementById("goals_edit_note");
        if (initialConfigEditNote) {
          initialConfigEditNote.style.display = "block";
        }
        if (goalsEditNote) {
          goalsEditNote.style.display = "block";
        }
      }

      applyAlgorithmPreset(currentPreset);
      updatePresetDescription(currentPreset);

      // --- New Page State Management ---
      let currentPage = 1;
      let simulatorInitialized = false; // Track if goals simulator has been initialized

      // --- Page & Nav Elements ---
      const page1 = document.getElementById("page-1");
      const page2 = document.getElementById("page-2");
      const page3 = document.getElementById("page-3");
      const page4 = document.getElementById("page-4");
      const nextBtn = document.getElementById("next-btn");
      const prevBtn2 = document.getElementById("prev-btn-page2");
      const prevBtn3 = document.getElementById("prev-btn-page3");
      const nextBtn3 = document.getElementById("next-btn-page3");
      const prevBtn4 = document.getElementById("prev-btn-page4");
      const generateBtn = document.getElementById("generate-btn"); // This is "Generate JSON" / Next on Page 2

      // --- Stepper Elements ---
      const step1 = document.getElementById("step-1");
      const step2 = document.getElementById("step-2");
      const step3 = document.getElementById("step-3");
      const step4 = document.getElementById("step-4");

      // --- Stepper CSS classes ---
      const activeClasses = {
        circle: "bg-blue-600 text-white",
        text: "text-blue-600 font-semibold",
      };
      const inactiveClasses = {
        circle: "bg-gray-300 text-gray-600",
        text: "text-gray-600 font-medium",
      };
      const completedClasses = {
        circle: "bg-green-600 text-white",
        text: "text-green-600 font-medium",
      };

      // Function to update simulator palette with colors from Page 2
      function updateSimulatorPalette() {
        const colorLetters = colorLettersInput.value
          .split(",")
          .map((s) => s.trim())
          .filter((s) => s);
        const paletteContainer = document.querySelector(".robot-palette");
        if (!paletteContainer) return;

        // Clear existing robot palette items (keep waypoint, exclusive, walls)
        const existingRobots =
          paletteContainer.querySelectorAll(".palette-robot");
        existingRobots.forEach((robot) => robot.remove());

        // Get reference to first non-robot element (waypoint)
        const firstSpecialItem =
          paletteContainer.querySelector(".palette-waypoint");

        // Add robot palette items based on Page 2 color letters
        colorLetters.forEach((letter) => {
          const robotDiv = document.createElement("div");
          robotDiv.className = "palette-robot";
          robotDiv.dataset.color = letter;
          robotDiv.style.backgroundColor =
            letterColorMap[letter] || "#808080";
          robotDiv.title = `${letter} Robot`;
          robotDiv.textContent = letter;

          // Insert before waypoint
          if (firstSpecialItem) {
            paletteContainer.insertBefore(robotDiv, firstSpecialItem);
          } else {
            paletteContainer.appendChild(robotDiv);
          }
        });

        // Always add obstacle "O" after robots
        // Add obstacle based on selected type (O or W)
        const obstacleDiv = document.createElement("div");
        obstacleDiv.className = "palette-robot";
        const obstacleType = document.getElementById("obstacle_type").value;
        if (obstacleType === "W") {
          obstacleDiv.dataset.color = "W";
          obstacleDiv.style.backgroundColor = "#000000"; // Black for wall
          obstacleDiv.title = "Obstacle ('W')";
          obstacleDiv.textContent = "W";
        } else {
          // Default to custom obstacle O
          obstacleDiv.dataset.color = "O";
          obstacleDiv.style.backgroundColor = "#ffa500"; // Orange
          obstacleDiv.title = "Obstacle ('O')";
          obstacleDiv.textContent = "O";
        }

        // Insert before waypoint
        if (firstSpecialItem) {
          paletteContainer.insertBefore(obstacleDiv, firstSpecialItem);
        } else {
          paletteContainer.appendChild(obstacleDiv);
        }

        console.log("Updated simulator palette with letters:", colorLetters);
      }

      function updateUI() {
        // Hide all pages
        page1.style.display = "none";
        page2.style.display = "none";
        page3.style.display = "none";
        page4.style.display = "none";

        // Reset all steps to inactive
        [step1, step2, step3, step4].forEach((step) => {
          const circle = step.querySelector("div");
          const label = step.querySelector("span");

          circle.className = `flex items-center justify-center w-8 h-8 rounded-full ${inactiveClasses.circle} font-semibold text-sm`;
          label.className = `text-sm ${inactiveClasses.text}`;
        });

        if (currentPage === 1) {
          page1.style.display = "block";
          // Step 1 Active
          const circle1 = step1.querySelector("div");
          const label1 = step1.querySelector("span");
          circle1.className = `flex items-center justify-center w-8 h-8 rounded-full ${activeClasses.circle} font-semibold text-sm`;
          label1.className = `text-sm ${activeClasses.text}`;
        } else if (currentPage === 2) {
          page2.style.display = "block";
          // Step 1 Completed
          const circle1 = step1.querySelector("div");
          const label1 = step1.querySelector("span");
          circle1.className = `flex items-center justify-center w-8 h-8 rounded-full ${completedClasses.circle} font-semibold text-sm`;
          label1.className = `text-sm ${completedClasses.text}`;
          // Step 2 Active
          const circle2 = step2.querySelector("div");
          const label2 = step2.querySelector("span");
          circle2.className = `flex items-center justify-center w-8 h-8 rounded-full ${activeClasses.circle} font-semibold text-sm`;
          label2.className = `text-sm ${activeClasses.text}`;
        } else if (currentPage === 3) {
          page3.style.display = "block";
          // Steps 1, 2 Completed
          [step1, step2].forEach((step) => {
            const circle = step.querySelector("div");
            const label = step.querySelector("span");
            circle.className = `flex items-center justify-center w-8 h-8 rounded-full ${completedClasses.circle} font-semibold text-sm`;
            label.className = `text-sm ${completedClasses.text}`;
          });
          // Step 3 Active
          const circle3 = step3.querySelector("div");
          const label3 = step3.querySelector("span");
          circle3.className = `flex items-center justify-center w-8 h-8 rounded-full ${activeClasses.circle} font-semibold text-sm`;
          label3.className = `text-sm ${activeClasses.text}`;

          // Initialize or reinitialize embedded goals simulator
          if (typeof window.initializeEmbeddedGoalsSimulator === "function") {
            // When edit is enabled or force reload is requested, reinitialize to load goals
            if (!simulatorInitialized || forceGoalsReload) {
              // Get the correct goals based on current preset BEFORE initializing
              let presetData = null;
              if (currentPreset !== "custom") {
                const index = parseInt(currentPreset, 10);
                const preset = algorithmPresets[index];
                if (preset) presetData = preset.data;
              }

              // Update defaultSimulationConfigList with the correct preset goals BEFORE initialization
              if (presetData && presetData.goals) {
                // This is a global variable
                defaultSimulationConfigList = JSON.stringify(
                  presetData.goals,
                  null,
                  2
                );
                console.log(
                  "=== UPDATED defaultSimulationConfigList for",
                  currentPreset,
                  "==="
                );
                console.log(
                  "Goals count:",
                  presetData.goals.length
                );
                console.log(
                  "First few chars:",
                  defaultSimulationConfigList.substring(0, 100)
                );
              }
              // When edit is enabled, defaultSimulationConfigList was already set in handleFormSubmit
              else if (canEdit) {
                console.log("=== EDIT MODE: Generating goals ===");

                // Generate goals from essential collected configurations
                const collectedConfigs = generatePositionsJSON();
                const essentialConfigs = collectedConfigs.filter(
                  (cfg) => cfg[1] === true
                );

                console.log("Total collected configs:", collectedConfigs.length);
                console.log("Essential configs:", essentialConfigs.length);

                // Generate goals in the correct format
                const customGoals = {
                  simulation_configs: [],
                };

                // If no essential configs, create a default goal with obstacle at (0,0)
                if (essentialConfigs.length === 0) {
                  console.log("No essential configs found - creating default goal");
                  const obstacleType = document.getElementById("obstacle_type").value;

                  const defaultGoal = {
                    initial_positions: [[obstacleType, 0, 0]],
                    targets: [[1, [[obstacleType, 0, 0]], [], []]],
                    boundary: [-6, 6, -6, 6],
                    wall: [null, null],
                  };

                  customGoals.simulation_configs.push(defaultGoal);
                } else {
                  // For each essential collected view, create a goal
                  essentialConfigs.forEach((collectedConfig, index) => {
                    const robotList = collectedConfig[0] || [];
                    const obstacleType = document.getElementById("obstacle_type").value;
                    // robotList already contains the obstacle (normalized), so we don't need to add it again.
                    // However, to be safe and ensure we don't have duplicates or wrong types, 
                    // we can filter out any existing obstacle and add the correct one, 
                    // OR just trust robotList if we are sure it's correct.
                    // Since generatePositionsJSON uses the correct obstacle type, robotList is correct.
                    // We just need to remove the hardcoded ["O", 0, 0] addition.
                    const initial_positions = [...robotList];

                    // Update targets to use the correct obstacle type
                    const targets = [[2, [[obstacleType, 0, 0]], [], []]];
                    const boundary = [-6, 6, -6, 6];

                    const goal = {
                      initial_positions: initial_positions,
                      targets: targets,
                      boundary: boundary,
                      wall: [null, null],
                    };

                    customGoals.simulation_configs.push(goal);
                  });
                }

                console.log("Generated custom goals:", customGoals);

                // Update defaultSimulationConfigList with custom goals
                defaultSimulationConfigList = JSON.stringify(
                  customGoals,
                  null,
                  2
                );

                console.log(
                  "defaultSimulationConfigList length:",
                  defaultSimulationConfigList.length
                );
                try {
                  const parsed = JSON.parse(defaultSimulationConfigList);
                  console.log(
                    "Number of goals:",
                    parsed.simulation_configs?.length || 0
                  );
                } catch (e) {
                  console.error(
                    "Error parsing defaultSimulationConfigList:",
                    e
                  );
                }
              }

              // Check if we have loaded goals from a config file
              if (window.loadedGoalsData) {
                console.log("=== LOADING GOALS FROM CONFIG FILE ===");
                defaultSimulationConfigList = JSON.stringify(
                  { simulation_configs: window.loadedGoalsData },
                  null,
                  2
                );
                console.log("Loaded goals count:", window.loadedGoalsData.length);
                // DON'T delete the loaded data - keep it so it works when navigating back/forth
                // It will be cleared when a new config is loaded or when switching presets
              }

              simulatorInitialized = true;
              forceGoalsReload = false;
              // Initialize/reinitialize the simulator which will parse defaultSimulationConfigList
              window.initializeEmbeddedGoalsSimulator();
              // Update robot palette with colors from Page 2
              updateSimulatorPalette();
              // Update goals simulator state
              updateGoalsSimulatorState();
            } else {
              // Update palette if returning to Page 3
              updateSimulatorPalette();
              // Update goals simulator state
              updateGoalsSimulatorState();
            }
          }
        } else if (currentPage === 4) {
          console.log("=== Entering Page 4 ===");
          console.log("page4 element:", page4);

          page4.style.display = "block";
          console.log("page4.style.display set to block");

          // Steps 1, 2, 3 Completed
          [step1, step2, step3].forEach((step) => {
            const circle = step.querySelector("div");
            const label = step.querySelector("span");
            circle.className = `flex items-center justify-center w-8 h-8 rounded-full ${completedClasses.circle} font-semibold text-sm`;
            label.className = `text-sm ${completedClasses.text}`;
          });
          // Step 4 Active
          const circle4 = step4.querySelector("div");
          const label4 = step4.querySelector("span");
          circle4.className = `flex items-center justify-center w-8 h-8 rounded-full ${activeClasses.circle} font-semibold text-sm`;
          label4.className = `text-sm ${activeClasses.text}`;

          // Generate JSON output now that simulator is loaded
          console.log("=== Page 4: Generating JSON output ===");
          try {
            handleFormSubmit();
            console.log("handleFormSubmit completed successfully");
          } catch (error) {
            console.error("Error in handleFormSubmit on page 4:", error);
            console.error("Error stack:", error.stack);
            // Show error but don't prevent page from displaying
            showModal(`Error generating configuration: ${error.message}`);
            // Set empty JSON output so page still shows
            const jsonOutput = document.getElementById("json-output");
            if (jsonOutput) {
              jsonOutput.textContent = "Error generating configuration. Please check console for details.";
            } else {
              console.error("jsonOutput element not found!");
            }
          }
          console.log("=== Page 4 setup complete ===");
        }
      }
      // --- End Page State Management ---

      // --- Helper: Convert decimal to hex color ---
      function decToHex(dec) {
        return "#" + Number(dec).toString(16).padStart(6, "0");
      }

      // --- Function to update the dynamic color pickers ---
      function updateColorPickers(initialColorMap = {}) {
        const letters = colorLettersInput.value
          .split(",")
          .map((s) => s.trim())
          .filter((s) => s);

        // Store existing values from UI
        const existingValues = {};
        Array.from(colorPickerContainer.children).forEach((child) => {
          const letter = child.dataset.letter;
          const value = child.querySelector(".color-decimal-input").value;
          if (letter) {
            existingValues[letter] = value;
          }
        });

        colorPickerContainer.innerHTML = ""; // Clear old list

        letters.forEach((letter) => {
          // Prioritize UI, then initial data, then new map, then default
          const decimalValue =
            existingValues[letter] ||
            initialColorMap[letter] ||
            letterDecimalMap[letter] ||
            0;
          const hexValue = decToHex(decimalValue);

          const row = document.createElement("div");
          // UI Improvement: Added shadow-sm for a bit more depth on each card
          row.className =
            "flex items-center gap-3 p-2 border rounded-md bg-gray-50 shadow-sm";
          row.dataset.letter = letter;

          const colorDisabledAttr = !canEdit ? "disabled" : "";
          const colorDisabledClass = !canEdit ? "opacity-60 cursor-not-allowed" : "";
          // Decimal inputs editable when canEdit is true
          const decimalReadonlyAttr = !canEdit ? "readonly" : "";
          const decimalDisabledClass = !canEdit ? "opacity-60 cursor-not-allowed bg-gray-100" : "";

          row.innerHTML = `
                        <span class="font-mono font-bold text-lg w-8 text-center text-gray-700">${letter}</span>
                        <input type="color" class="color-picker-input h-10 w-10 rounded-md border-gray-300 ${colorDisabledClass}" value="${hexValue}" ${colorDisabledAttr}>
                        <input type="number" min="0" ${decimalReadonlyAttr} class="color-decimal-input mt-0 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 ${decimalDisabledClass}" value="${decimalValue}">
                        <button type="button" class="delete-color-btn text-red-600 hover:text-red-800 p-1" title="Remove color">
                          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                          </svg>
                        </button>
                    `;

          const colorInput = row.querySelector(".color-picker-input");
          const decimalInput = row.querySelector(".color-decimal-input");

          // Store the color values in the maps
          letterColorMap[letter] = hexValue;
          letterDecimalMap[letter] = decimalValue;

          // Sync color picker to decimal input (only if edit is enabled)
          if (canEdit) {
            colorInput.addEventListener("input", () => {
              decimalInput.value = hexToDec(colorInput.value);
              // Update the letterColorMap immediately
              letterColorMap[letter] = colorInput.value;
              letterDecimalMap[letter] = hexToDec(colorInput.value);
              // Mark configs as modified since color changed
              configsWereModified = true;
            });

            // Sync decimal input to color picker
            decimalInput.addEventListener("input", () => {
              const hexValue = decToHex(decimalInput.value);
              colorInput.value = hexValue;
              letterColorMap[letter] = hexValue;
              letterDecimalMap[letter] = parseInt(decimalInput.value);
              // Mark configs as modified since color changed
              configsWereModified = true;
            });
          }

          // Add delete button handler
          const deleteBtn = row.querySelector(".delete-color-btn");
          deleteBtn.addEventListener("click", () => {
            // Remove from letterColorMap and letterDecimalMap
            delete letterColorMap[letter];
            delete letterDecimalMap[letter];
            // Remove the row
            row.remove();
            // Update hidden input
            updateColorLettersInput();
            // Update Robot Palette and Leader Colors
            populateRobotPalette();
            populateLeaderColors();
          });

          colorPickerContainer.appendChild(row);
        });

        // Always ensure obstacle colors are in the map
        const obstacleType = document.getElementById("obstacle_type")?.value || "O";
        if (obstacleType === "O" && !letterColorMap["O"]) {
          letterColorMap["O"] = "#ffa500"; // Orange
          letterDecimalMap["O"] = 16753920;
        } else if (obstacleType === "W" && !letterColorMap["W"]) {
          letterColorMap["W"] = "#000000"; // Black
          letterDecimalMap["W"] = 0;
        }

        // Update hidden input after populating (don't mark as modified during initial load)
        updateColorLettersInput(false);

        // Update delete buttons visibility based on canEdit
        updateColorPickerDeleteButtons(!canEdit);
      }

      // Function to update the hidden color_letters_input from the current color picker list
      function updateColorLettersInput(markAsModified = true) {
        const letters = Array.from(colorPickerContainer.children).map(
          (child) => child.dataset.letter
        );
        colorLettersInput.value = letters.join(", ");

        // Mark as modified when robot palette changes (only if flag is true)
        if (markAsModified) {
          configsWereModified = true;
        }

        // Update Robot Palette and Leader Colors to reflect current colors
        populateRobotPalette();
        populateLeaderColors();
      }

      // Function to show/hide delete buttons on color pickers
      function updateColorPickerDeleteButtons(hideButtons) {
        const deleteButtons = colorPickerContainer.querySelectorAll(".delete-color-btn");
        deleteButtons.forEach((btn) => {
          if (hideButtons) {
            btn.style.display = "none";
          } else {
            btn.style.display = "block";
          }
        });
      }

      // --- Event listener for Generation Mode select ---
      genModeSelect.addEventListener("change", () => {
        const mode = genModeSelect.value;
        const label = document.getElementById("generation_mode_value_label");

        if (mode === "All") {
          genModeValueContainer.style.display = "none";
        } else {
          genModeValueContainer.style.display = "block";

          // Update label based on mode
          if (mode === "ProgressiveValidationByLevels") {
            label.textContent = "Level";
            genModeValueInput.placeholder = "e.g., 5";
          } else if (mode === "ProgressiveValidationByMaxActivations") {
            label.textContent = "Max Activations";
            genModeValueInput.placeholder = "e.g., 10";
          } else if (mode === "ProgressiveValidationByLimitTime") {
            label.textContent = "Time Limit (minutes)";
            genModeValueInput.placeholder = "e.g., 1";
          }
        }
      });

      // --- Add Color Modal Functionality ---
      const addColorBtn = document.getElementById("add_color_btn");
      const addColorModal = document.getElementById("add-color-modal");
      const addColorBackdrop = document.getElementById("add-color-backdrop");
      const addColorModalContent = addColorModal.querySelector("div.relative");
      const addColorCloseBtn = document.getElementById("add-color-close-btn");
      const addColorCancelBtn = document.getElementById("add-color-cancel-btn");
      const addColorConfirmBtn = document.getElementById("add-color-confirm-btn");
      const newColorChar = document.getElementById("new-color-char");
      const newColorPicker = document.getElementById("new-color-picker");
      const newColorDecimal = document.getElementById("new-color-decimal");
      const charError = document.getElementById("char-error");

      function showAddColorModal() {
        // Reset form
        newColorChar.value = "";
        newColorPicker.value = "#0000FF";
        newColorDecimal.value = "255";
        charError.style.display = "none";
        newColorChar.classList.remove("border-red-500");

        addColorModal.style.display = "flex";
        setTimeout(() => {
          addColorBackdrop.classList.remove("opacity-0");
          addColorBackdrop.classList.add("opacity-100");
          addColorModalContent.classList.remove("scale-95", "opacity-0");
          addColorModalContent.classList.add("scale-100", "opacity-100");
        }, 10);
        newColorChar.focus();
      }

      function hideAddColorModal() {
        addColorBackdrop.classList.remove("opacity-100");
        addColorBackdrop.classList.add("opacity-0");
        addColorModalContent.classList.remove("scale-100", "opacity-100");
        addColorModalContent.classList.add("scale-95", "opacity-0");
        setTimeout(() => {
          addColorModal.style.display = "none";
        }, 300);
      }

      function validateAndAddColor() {
        const char = newColorChar.value.trim().toUpperCase();
        const decimalValue = parseInt(newColorDecimal.value);
        const hexValue = newColorPicker.value.toUpperCase();

        // Validation
        if (!char) {
          charError.textContent = "Please enter a character";
          charError.style.display = "block";
          newColorChar.classList.add("border-red-500");
          return;
        }

        // Check if character is A-Z only
        if (!/^[A-Z]$/.test(char)) {
          charError.textContent = "Character must be A-Z only";
          charError.style.display = "block";
          newColorChar.classList.add("border-red-500");
          return;
        }

        // Check if character is reserved (O for orange obstacle, W for black wall, X for invisible zone)
        if (char === 'O' || char === 'W' || char === 'X') {
          charError.textContent = `Character '${char}' is reserved (O=Obstacle, W=Wall, X=Invisible Zone)`;
          charError.style.display = "block";
          newColorChar.classList.add("border-red-500");
          return;
        }

        // Check if character already exists
        const existingLetters = Array.from(colorPickerContainer.children).map(
          (child) => child.dataset.letter
        );
        if (existingLetters.includes(char)) {
          charError.textContent = `Character '${char}' already exists`;
          charError.style.display = "block";
          newColorChar.classList.add("border-red-500");
          return;
        }

        // Check if color is reserved (orange #FFA500 for O, black #000000 for W)
        const reservedColors = ['#FFA500', '#000000'];
        if (reservedColors.includes(hexValue)) {
          const colorName = hexValue === '#FFA500' ? 'orange' : 'black';
          charError.textContent = `Color ${colorName} is reserved for obstacles`;
          charError.style.display = "block";
          newColorChar.classList.add("border-red-500");
          return;
        }

        // Check if color already exists in other robot colors
        const existingColors = Array.from(colorPickerContainer.children).map(
          (child) => child.querySelector('.color-picker-input').value.toUpperCase()
        );
        if (existingColors.includes(hexValue)) {
          charError.textContent = "This color is already used by another robot";
          charError.style.display = "block";
          newColorChar.classList.add("border-red-500");
          return;
        }

        // Add to letterColorMap
        letterColorMap[char] = hexValue;
        letterDecimalMap[char] = decimalValue;

        // Add to color picker container
        const row = document.createElement("div");
        row.className = "flex items-center gap-3 p-2 border rounded-md bg-gray-50 shadow-sm";
        row.dataset.letter = char;

        const colorDisabledAttr = !canEdit ? "disabled" : "";
        const colorDisabledClass = !canEdit ? "opacity-60 cursor-not-allowed" : "";
        const decimalReadonlyAttr = !canEdit ? "readonly" : "";
        const decimalDisabledClass = !canEdit ? "opacity-60 cursor-not-allowed bg-gray-100" : "";

        row.innerHTML = `
            <span class="font-mono font-bold text-lg w-8 text-center text-gray-700">${char}</span>
            <input type="color" class="color-picker-input h-10 w-10 rounded-md border-gray-300 ${colorDisabledClass}" value="${hexValue}" ${colorDisabledAttr}>
            <input type="number" min="0" ${decimalReadonlyAttr} class="color-decimal-input mt-0 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 ${decimalDisabledClass}" value="${decimalValue}">
            <button type="button" class="delete-color-btn text-red-600 hover:text-red-800 p-1" title="Remove color">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
              </svg>
            </button>
          `;

        const colorInput = row.querySelector(".color-picker-input");
        const decimalInput = row.querySelector(".color-decimal-input");

        // Sync color picker to decimal input (only if edit is enabled)
        if (canEdit) {
          colorInput.addEventListener("input", () => {
            decimalInput.value = hexToDec(colorInput.value);
            letterColorMap[char] = colorInput.value;
            letterDecimalMap[char] = hexToDec(colorInput.value);
            // Mark configs as modified since color changed
            configsWereModified = true;
          });

          // Sync decimal input to color picker
          decimalInput.addEventListener("input", () => {
            const hexValue = decToHex(decimalInput.value);
            colorInput.value = hexValue;
            letterColorMap[char] = hexValue;
            letterDecimalMap[char] = parseInt(decimalInput.value);
            // Mark configs as modified since color changed
            configsWereModified = true;
          });
        }

        // Add delete button handler
        const deleteBtn = row.querySelector(".delete-color-btn");
        deleteBtn.addEventListener("click", () => {
          delete letterColorMap[char];
          delete letterDecimalMap[char];
          row.remove();
          updateColorLettersInput();
        });

        colorPickerContainer.appendChild(row);

        // Update hidden input
        updateColorLettersInput();

        // Close modal
        hideAddColorModal();
      }

      // Event listeners for Add Color modal
      addColorBtn.addEventListener("click", showAddColorModal);
      addColorCloseBtn.addEventListener("click", hideAddColorModal);
      addColorCancelBtn.addEventListener("click", hideAddColorModal);
      addColorBackdrop.addEventListener("click", hideAddColorModal);
      addColorConfirmBtn.addEventListener("click", validateAndAddColor);

      // Sync color picker and decimal input in modal
      newColorPicker.addEventListener("input", () => {
        newColorDecimal.value = hexToDec(newColorPicker.value);
      });

      newColorDecimal.addEventListener("input", () => {
        newColorPicker.value = decToHex(newColorDecimal.value);
      });

      // Clear error when typing
      newColorChar.addEventListener("input", () => {
        charError.style.display = "none";
        newColorChar.classList.remove("border-red-500");
        // Auto-uppercase
        newColorChar.value = newColorChar.value.toUpperCase();
      });

      // Allow Enter key to add color
      newColorChar.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          validateAndAddColor();
        }
      });

      // Function to sync letterColorMap with current color picker values
      function syncLetterColorMap() {
        Array.from(colorPickerContainer.children).forEach((child) => {
          const letter = child.dataset.letter;
          const colorInput = child.querySelector(".color-picker-input");
          if (letter && colorInput) {
            letterColorMap[letter] = colorInput.value;
            letterDecimalMap[letter] = hexToDec(colorInput.value);
          }
        });
        console.log("Updated letterColorMap:", letterColorMap);
      }

      // Function to populate the form with default data
      function populateForm(data) {
        document.getElementById("number_of_robots").value =
          data.number_of_robots;
        document.getElementById("visibility_range").value =
          data.visibility_range;

        // Set color letters input
        document.getElementById("color_letters_input").value =
          data.all_color_letters.join(", ");

        // Parse web_algo_colors to populate pickers
        const colorMap = {};
        if (data.web_algo_colors) {
          data.web_algo_colors.split("\n").forEach((line) => {
            const parts = line.trim().split(":");
            if (parts.length === 2) {
              const letter = parts[0].trim();
              const value = parts[1].trim();
              colorMap[letter] = value;
            }
          });
        }

        // Generate the color pickers with the parsed data
        updateColorPickers(colorMap);

        document.getElementById("existing_algorithm_path").value =
          data.existing_algorithm_path;


        // Load obstacle type
        if (data.obstacle) {
          document.getElementById("obstacle_type").value = data.obstacle;
          updateObstacleOpaque(); // Update the opaque checkbox state based on loaded obstacle type
        }

        // Handle generation_mode
        if (typeof data.generation_mode === "string") {
          genModeSelect.value = data.generation_mode;
          genModeValueContainer.style.display = "none";
          genModeValueInput.value = "";
        } else if (
          typeof data.generation_mode === "object" &&
          data.generation_mode !== null
        ) {
          const key = Object.keys(data.generation_mode)[0]; // e.g., "ProgressiveValidationByLevels"
          const value = data.generation_mode[key];
          genModeSelect.value = key;
          genModeValueInput.value = value;
          genModeValueContainer.style.display = "block";
        } else {
          // Default fallback
          genModeSelect.value = "All";
          genModeValueContainer.style.display = "none";
          genModeValueInput.value = "";
        }

        document.getElementById("opacity").checked = data.opacity;
        document.getElementById("is_obstacle_opaque").checked =
          data.is_obstacle_opaque;


        // Pretty-print JSON for textareas
        // THIS IS THE KEY: Populate the hidden field with default data
        document.getElementById("moving_on_space_pattern").value =
          JSON.stringify(data.moving_on_space_pattern, null, 2);

        // --- NEW: Populate Page 2 Generator Inputs ---
        // Use moving_on_space_pattern for interactive grids
        if (
          data.moving_on_space_pattern &&
          data.moving_on_space_pattern.length > 0
        ) {
          // Check if data has the format [[robot, robot], [robot, robot]] or [[[robot, robot], isLeader], ...]
          const firstItem = data.moving_on_space_pattern[0];
          let robotViews;

          if (
            Array.isArray(firstItem) &&
            firstItem.length === 2 &&
            typeof firstItem[1] === "boolean"
          ) {
            // Old format: [[[robot, robot], isLeader], ...]
            robotViews = data.moving_on_space_pattern.map(
              ([config, isLeader]) => config.slice(1)
            ); // Remove 'O' obstacle
          } else {
            // New format: [[robot, robot], [robot, robot]] - direct robot positions
            robotViews = data.moving_on_space_pattern;
          }

          document.getElementById("robotData").value =
            JSON.stringify(robotViews);
        } else {
          document.getElementById("robotData").value =
            '[[["L",0,0],["F",-2,0]],[["L",0,0],["F",-1,0]]]';
        }

        // Store web_algo_initial_configuration for display on Page 2
        if (data.web_algo_initial_configuration) {
          // Store it in a global variable or data attribute for later use
          window.loadedInitialConfiguration = data.web_algo_initial_configuration;
        }
        // --- END NEW ---
      }

      // Function to handle form submission
      function handleFormSubmit() {
        // Removed (e) and e.preventDefault()

        try {
          // Save collected configurations to global variable
          const collectedConfigsText =
            document.getElementById("collectedConfigs")?.value || "[]";
          try {
            collectedConfigurations = JSON.parse(collectedConfigsText);
            console.log(
              "Saved collected configurations to global variable:",
              collectedConfigurations
            );
          } catch (e) {
            console.warn("Could not parse collected configs:", e);
            collectedConfigurations = [];
          }

          // Generate the web algorithm configuration
          const configText = generateWebAlgoConfiguration();

          // Get non-empty lines for dimension calculation
          const lines = configText
            .split("\n")
            .filter((l) => l.trim().length > 0);
          const numRows = lines.length;
          // Find the maximum length of any line for the end boundary
          const maxCols = lines.reduce(
            (max, line) => Math.max(max, line.length),
            0
          );

          // Prepare goals array from simulator - use Active Simulation Config
          let goalsArray = [];

          // DEBUG: Log what we're checking
          console.log("=== DEBUG: Checking for goals ===");
          console.log("window.activeSimulationConfigs exists:", !!window.activeSimulationConfigs);
          console.log("window.activeSimulationConfigs length:", window.activeSimulationConfigs?.length);
          console.log("window.activeSimulationConfigs content:", window.activeSimulationConfigs);

          // First try to get from the Active Simulation Config (simulationConfigListTextArea)
          if (window.activeSimulationConfigs && window.activeSimulationConfigs.length > 0) {
            console.log("=== Using activeSimulationConfigs for goals ===");
            // Convert activeSimulationConfigs to goals format
            goalsArray = window.activeSimulationConfigs.map((config) => {
              const boundaries = config.boundaries || { xmin: -6, xmax: 6, ymin: -6, ymax: 6 };
              const grids = config.grids || [];
              const gridSteps = config.gridSteps || [];
              const gridWaypoints = config.gridWaypoints || [];
              const gridExclusivePoints = config.gridExclusivePoints || [];
              const walls = config.walls || [];

              let verticalWall = null, horizontalWall = null;
              walls.forEach((wall) => {
                if (wall.type === "vertical") verticalWall = wall.x1;
                else if (wall.type === "horizontal") horizontalWall = wall.y1;
              });

              let initialPositions = [];
              let targets = [];

              if (grids.length > 0) {
                initialPositions = grids[0].map(([color, x, y]) => [color, x, y]);
                for (let i = 1; i < grids.length; i++) {
                  const steps = (gridSteps && gridSteps[i]) || 5;
                  const robots = grids[i].map(([color, x, y]) => [color, x, y]);
                  const exclusivePoints = (gridExclusivePoints[i] || []).map(([x, y]) => [x, y]);
                  const waypoints = (gridWaypoints[i] || []).map(([x, y]) => [x, y]);
                  targets.push([steps, robots, exclusivePoints, waypoints]);
                }
              }

              return {
                initial_positions: initialPositions,
                targets: targets,
                boundary: [boundaries.xmin, boundaries.xmax, boundaries.ymin, boundaries.ymax],
                wall: [verticalWall, horizontalWall],
              };
            });
            console.log("=== Converted goals array ===");
            console.log("goalsArray length:", goalsArray.length);
            console.log("goalsArray:", goalsArray);
          } else if (collectedConfigurations && collectedConfigurations.simulation_configs) {
            // Fallback to collectedConfigurations
            console.log("=== Using collectedConfigurations fallback ===");
            goalsArray = collectedConfigurations.simulation_configs;
          } else {
            console.log("=== WARNING: No goals source found! ===");
          }

          const config = {
            obstacle: "O",
            number_of_robots:
              parseInt(document.getElementById("number_of_robots").value) ||
              0,
            number_of_colors: document
              .getElementById("color_letters_input")
              .value.split(",")
              .map((s) => s.trim())
              .filter((s) => s).length,
            visibility_range:
              parseInt(document.getElementById("visibility_range").value) ||
              0,

            all_color_letters: document
              .getElementById("color_letters_input")
              .value.split(",")
              .map((s) => s.trim())
              .filter((s) => s), // Remove empty strings

            leader_colors: (() => {
              const selected = Array.from(
                document.querySelectorAll(".leader-color-checkbox:checked")
              ).map((cb) => cb.value);

              // If no leaders selected, default to all colors being leaders
              if (selected.length === 0) {
                const allColors = document
                  .getElementById("color_letters_input")
                  .value.split(",")
                  .map((s) => s.trim())
                  .filter((s) => s);
                return allColors;
              }
              return selected;
            })(),

            existing_algorithm_path: document.getElementById(
              "existing_algorithm_path"
            ).value,


            generation_mode: (() => {
              const mode = genModeSelect.value;
              if (mode === "All") {
                return "All";
              } else {
                const valueStr = genModeValueInput.value;
                if (!valueStr) {
                  // Throw error if value is empty but mode is not 'All'
                  throw new Error(
                    `A value is required for Generation Mode: ${mode}`
                  );
                }
                const value = parseInt(valueStr) || 0;
                const obj = {};
                obj[mode] = value;
                return obj;
              }
            })(),

            opacity: document.getElementById("opacity").checked,
            is_obstacle_opaque:
              document.getElementById("is_obstacle_opaque").checked,


            max_combined_goals_execution_length: null,

            // Generate web_algo_colors from the dynamic UI
            web_algo_colors: (() => {
              const lines = [];
              Array.from(colorPickerContainer.children).forEach((child) => {
                const letter = child.dataset.letter;
                const decimalValue = child.querySelector(
                  ".color-decimal-input"
                ).value;
                lines.push(`  ${letter}: ${decimalValue}`);
              });

              // Add obstacle color based on selection
              const obstacleType = document.getElementById("obstacle_type").value;
              if (obstacleType === "O") {
                lines.push(`  O: 16753920`); // Orange
              } else if (obstacleType === "W") {
                lines.push(`  W: 0`); // Black
              }

              return lines.join("\n");
            })(),

            web_algo_initial_configuration: configText,

            // Construct web_algo_walls from config text dimensions
            web_algo_walls: [
              [0, 0],
              [maxCols, numRows],
            ],

            // Parse textareas as JSON - clean format without obstacle or isLeader
            moving_on_space_pattern: (() => {
              const rawPattern = JSON.parse(
                document.getElementById("moving_on_space_pattern").value || "[]"
              );
              // Clean the pattern: remove obstacle and isLeader flags
              if (Array.isArray(rawPattern) && rawPattern.length > 0) {
                const firstItem = rawPattern[0];
                // Check if old format with [config, isLeader]
                if (Array.isArray(firstItem) && firstItem.length === 2 && typeof firstItem[1] === "boolean") {
                  // Old format: extract robot positions (remove obstacle)
                  return rawPattern.map(([config, isLeader]) => {
                    return config.filter(([letter]) => letter !== "O");
                  });
                } else if (Array.isArray(firstItem) && firstItem.length > 0 && Array.isArray(firstItem[0])) {
                  // New format: check if it has obstacle
                  return rawPattern.map((config) => {
                    return config.filter(([letter]) => letter !== "O");
                  });
                }
              }
              return rawPattern;
            })(),

            // Collect initial configurations from Page 2 grids
            initial_configurations: (() => {
              const outputDiv = document.getElementById("output-container");
              if (!outputDiv) return [];

              const gridWrappers = outputDiv.querySelectorAll('.grid-wrapper[data-config-type="initial-config"]');
              const configs = [];

              gridWrappers.forEach((wrapper) => {
                if (wrapper.classList.contains("excluded")) return;

                const toggleBtn = wrapper.querySelector("button[data-essential]");
                const isEssential = toggleBtn ? toggleBtn.dataset.essential === "true" : false;

                // Extract config from the data stored in allLocalConfigs
                const gridIndex = Array.from(gridWrappers).indexOf(wrapper);
                if (gridIndex >= 0 && gridIndex < allLocalConfigs.length) {
                  const configData = allLocalConfigs[gridIndex];
                  if (configData && configData.config) {
                    configs.push([configData.config, isEssential]);
                  }
                }
              });

              return configs;
            })(),

            // Add number_of_goals
            number_of_goals: goalsArray.length,

            // Add goals from simulator
            goals: goalsArray,
          };

          // Custom JSON stringifier for compact array formatting
          let jsonString = JSON.stringify(config, null, 2);

          // Make web_algo_walls compact: [[0,0],[17,17]]
          jsonString = jsonString.replace(
            /"web_algo_walls":\s*\[\s*\[\s*(\d+),\s*(\d+)\s*\],\s*\[\s*(\d+),\s*(\d+)\s*\]\s*\]/g,
            '"web_algo_walls": [[$1, $2], [$3, $4]]'
          );

          // Make moving_on_space_pattern more compact
          jsonString = jsonString.replace(
            /"moving_on_space_pattern":\s*\[([\s\S]*?)\n  \]/,
            (match, content) => {
              const items = [];
              let depth = 0;
              let current = "";
              for (let i = 0; i < content.length; i++) {
                const char = content[i];
                if (char === "[") depth++;
                if (char === "]") depth--;
                current += char;
                if (depth === 0 && char === "]" && content[i + 1] === ",") {
                  items.push(current.trim());
                  current = "";
                  i++; // skip comma
                }
              }
              if (current.trim()) items.push(current.trim());

              const compact = items
                .map((item) => {
                  return item
                    .replace(/\s+/g, " ")
                    .replace(/\[ /g, "[")
                    .replace(/ \]/g, "]")
                    .replace(/\],\s*/g, "], ");
                })
                .join(",\n    ");
              return `"moving_on_space_pattern": [\n    ${compact}\n  ]`;
            }
          );

          // Make initial_configurations compact - each config on one line
          jsonString = jsonString.replace(
            /"initial_configurations":\s*\[([\s\S]*?)\n  \]/,
            (match, content) => {
              const items = [];
              let depth = 0;
              let current = "";
              for (let i = 0; i < content.length; i++) {
                const char = content[i];
                if (char === "[") depth++;
                if (char === "]") depth--;
                current += char;
                // At depth 0, we've closed the outer array of [config, bool]
                if (depth === 0 && char === "]") {
                  items.push(current.trim());
                  current = "";
                  // Skip comma and whitespace
                  while (i + 1 < content.length && (content[i + 1] === "," || content[i + 1].match(/\s/))) {
                    i++;
                  }
                }
              }
              if (current.trim()) items.push(current.trim());

              const compact = items
                .map((item) => {
                  return item
                    .replace(/\s+/g, " ")
                    .replace(/\[ /g, "[")
                    .replace(/ \]/g, "]");
                })
                .join(",\n    ");
              return `"initial_configurations": [\n    ${compact}\n  ]`;
            }
          );

          // Remove is_essential from goals array
          jsonString = jsonString.replace(
            /,?\s*"is_essential":\s*(true|false)/g,
            ''
          );

          // Make goals array more compact - format arrays on single lines
          // Goals is already a direct array of objects, so we just need to compact each object
          jsonString = jsonString.replace(
            /"goals":\s*\[([\s\S]*?)\n  \]/,
            (match, content) => {
              // Process each goal object to make arrays compact
              let result = content.replace(
                /\{\s*\n\s*"initial_positions":\s*\[([\s\S]*?)\],\s*\n\s*"targets":\s*\[([\s\S]*?)\],\s*\n\s*"boundary":\s*\[([\s\S]*?)\],\s*\n\s*"wall":\s*\[([\s\S]*?)\]\s*\n\s*\}/g,
                (configMatch, initPos, targets, boundary, wall) => {
                  // Compact initial_positions array
                  const compactInitPos = initPos.replace(/\s+/g, ' ').replace(/\[ /g, '[').replace(/ \]/g, ']').trim();

                  // Compact targets array
                  const compactTargets = targets.replace(/\s+/g, ' ').replace(/\[ /g, '[').replace(/ \]/g, ']').trim();

                  // Compact boundary array
                  const compactBoundary = boundary.replace(/\s+/g, ' ').trim();

                  // Compact wall array
                  const compactWall = wall.replace(/\s+/g, ' ').trim();

                  return `{\n      "initial_positions": [${compactInitPos}],\n      "targets": [${compactTargets}],\n      "boundary": [${compactBoundary}],\n      "wall": [${compactWall}]\n    }`;
                }
              );
              return `"goals": [${result}\n  ]`;
            }
          );

          jsonOutput.textContent = jsonString;

          // Generate summary view with grid boundaries
          generateSummary(config, maxCols, numRows);

          // Generate summary view with grid boundaries
          generateSummary(config, maxCols, numRows);

          // --- PREPARE DATA FOR SIMULATOR (Page 3) ---
          let simConfigs = [];

          // Helper to convert the preset goals format to the simulator's internal format
          const convertDefaultConfig = (defaultConfig) => {
            return defaultConfig.simulation_configs.map((cfg, index) => {
              // cfg.initial_positions is [[type, x, y], ...]
              // cfg.targets is [[steps, [[type, x, y], ...], [waypoints], [exclusive]], ...]
              // cfg.boundary is [xmin, xmax, ymin, ymax]
              // cfg.wall is [null, null] (ignored for now or mapped)

              const grids = [];
              const gridSteps = [];
              const gridWaypoints = [];
              const gridExclusivePoints = [];

              // Start grid
              grids.push(cfg.initial_positions);
              gridSteps.push(0); // Start has 0 steps
              gridWaypoints.push([]);
              gridExclusivePoints.push([]);

              // Target grids
              cfg.targets.forEach((target) => {
                const steps = target[0];
                const positions = target[1];
                const waypoints = target[2] || [];
                const exclusive = target[3] || [];

                grids.push(positions);
                gridSteps.push(steps);
                gridWaypoints.push(waypoints);
                gridExclusivePoints.push(exclusive);
              });

              // Calculate total steps
              const totalSteps = gridSteps.reduce((a, b) => a + b, 0);

              return {
                id: `sim-config-default-${Date.now()}-${index}`,
                grids: grids,
                steps: totalSteps,
                gridSteps: gridSteps,
                gridWaypoints: gridWaypoints,
                gridExclusivePoints: gridExclusivePoints,
                boundaries: {
                  xmin: cfg.boundary[0],
                  xmax: cfg.boundary[1],
                  ymin: cfg.boundary[2],
                  ymax: cfg.boundary[3],
                },
                walls: [], // Mapping walls if needed, currently empty in default config
                waypoints: [], // Legacy
                exclusive_points: [], // Legacy
              };
            });
          };

          if (currentPreset !== "custom") {
            const preset = algorithmPresets.find(p => p.id === currentPreset);
            if (preset && preset.data && preset.data.goals) {
              simConfigs = convertDefaultConfig(preset.data.goals);
            }
          } else {
            // Custom or other presets: Generate goals from essential collected configurations
            // Use generatePositionsJSON() to get the configs from allLocalConfigs
            const collectedConfigs = generatePositionsJSON();

            // Filter to get only ESSENTIAL configurations (isLeader === true)
            const essentialConfigs = collectedConfigs.filter(
              (cfg) => cfg[1] === true
            );

            console.log("=== CUSTOM MODE: Generating goals ===");
            console.log("Total collected configs:", collectedConfigs.length);
            console.log("Essential configs:", essentialConfigs.length);

            // Generate goals in the correct format for defaultSimulationConfigList
            const customGoals = {
              simulation_configs: [],
            };

            // For each essential collected view, create a goal
            essentialConfigs.forEach((collectedConfig, index) => {
              // collectedConfig format: [robotList, isLeader]
              // robotList is [['L', x, y], ['F', x, y], ...]
              const robotList = collectedConfig[0] || [];

              // Get the obstacle type from the dropdown
              const obstacleChar = document.getElementById("obstacle_type").value;

              // Create initial_positions: robot positions + obstacle at origin
              const initial_positions = [...robotList, [obstacleChar, 0, 0]];

              // Create targets with only obstacle at origin
              const targets = [[2, [[obstacleChar, 0, 0]], [], []]];

              // Set boundary
              const boundary = [-6, 6, -6, 6];

              // Create goal object
              // Note: is_essential is no longer stored in data, it's calculated dynamically
              const goal = {
                initial_positions: initial_positions,
                targets: targets,
                boundary: boundary,
                wall: [null, null],
              };

              customGoals.simulation_configs.push(goal);
            });

            console.log("Generated custom goals:", customGoals);

            // Update defaultSimulationConfigList with custom goals
            defaultSimulationConfigList = JSON.stringify(
              customGoals,
              null,
              2
            );

            // Convert to simulator internal format
            simConfigs = convertDefaultConfig(customGoals);
          }

          // DON'T navigate to Page 3 here - this will be called from updateUI() for page 4
          // The navigation is handled by generateBtn click handler
        } catch (error) {
          console.error("Form Processing Error:", error);
          // Check if it's a JSON error or our custom form error
          const friendlyMessage = error.message.includes("JSON")
            ? `Error parsing JSON input: ${error.message}. Please check fields marked with '(JSON)'. On Page 2, this may mean your 'Robot Data' is invalid.`
            : error.message;
          showModal(friendlyMessage);
          jsonOutput.textContent = "";
        }
      }

      // --- Summary Generation ---
      function generateSummary(config, maxCols, numRows) {
        const summaryContent = document.getElementById("summary-content");
        const items = [
          { label: "Robots", value: config.number_of_robots || 0 },
          { label: "Visibility Range", value: config.visibility_range || 0 },
          {
            label: "Colors",
            value: (config.all_color_letters || []).join(", ") || "None",
          },
          {
            label: "Leader Colors",
            value: (config.leader_colors || []).join(", ") || "None",
          },

          {
            label: "Generation Mode",
            value: (() => {
              if (config.generation_mode === "All") {
                return "All Levels";
              } else if (typeof config.generation_mode === "object") {
                const key = Object.keys(config.generation_mode)[0];
                const value = config.generation_mode[key];
                return `${key}: ${value}`;
              } else {
                return String(config.generation_mode);
              }
            })(),
          },
          {
            label: "Opacity",
            value: config.opacity ? "Enabled" : "Disabled",
          },
          {
            label: "Obstacle Opaque",
            value: config.is_obstacle_opaque ? "Yes" : "No",
          },
          {
            label: "Calculated Grid Boundaries",
            value: `X: ${maxCols || 0}, Y: ${numRows || 0}`,
          },
          {
            label: "Web Algorithm Initial Configuration",
            value: config.web_algo_initial_configuration || "Not generated",
            isGrid: true,
          },
          {
            label: "Movement Patterns",
            value: `${(config.moving_on_space_pattern || []).length} pattern(s)`,
          },
          {
            label: "Number of Goals",
            value: config.number_of_goals || 0,
          },
        ];

        summaryContent.innerHTML = items
          .map((item) => {
            if (item.isGrid && item.value && item.value !== "Not generated") {
              return `
                            <div class="py-2">
                                <span class="font-medium text-gray-700 block mb-2">${item.label}:</span>
                                <pre class="bg-gray-100 p-3 rounded text-xs font-mono whitespace-pre overflow-x-auto border">${item.value}</pre>
                            </div>
                        `;
            } else {
              return `
                            <div class="flex justify-between py-1">
                                <span class="font-medium text-gray-700">${item.label}:</span>
                                <span class="text-gray-900">${item.value}</span>
                            </div>
                        `;
            }
          })
          .join("");
      }

      // Toggle details button
      const toggleBtn = document.getElementById("toggle-details-btn");
      const detailsDiv = document.getElementById("json-details");

      if (toggleBtn && detailsDiv) {
        toggleBtn.addEventListener("click", () => {
          if (detailsDiv.style.display === "none") {
            detailsDiv.style.display = "block";
            toggleBtn.textContent = "Hide Full JSON";
          } else {
            detailsDiv.style.display = "none";
            toggleBtn.textContent = "Show Full JSON";
          }
        });
      }

      // --- Interactive Grid Editor ---
      let selectedRobotLetter = null;
      let interactiveGrids = [];
      let draggedRobot = null;
      let dragSourceCanvas = null;
      let dragSourceKey = null;

      function updateGridSizeDisplay() {
        const numRobots =
          parseInt(document.getElementById("number_of_robots").value) || 2;
        const visibilityRange =
          parseInt(document.getElementById("visibility_range").value) || 1;
        const gridRange = numRobots * visibilityRange;
        const gridSize = gridRange * 2 + 1;
        document.getElementById(
          "gridSizeDisplay"
        ).textContent = `${gridSize}Ã—${gridSize} (from -${gridRange} to +${gridRange})`;
      }

      function populateRobotPalette() {
        const colorLetters = colorLettersInput.value
          .split(",")
          .map((s) => s.trim())
          .filter((s) => s);
        const palette = document.getElementById("robotPalette");
        palette.innerHTML = "";

        colorLetters.forEach((letter) => {
          const canvas = document.createElement("canvas");
          canvas.width = 36;
          canvas.height = 36;
          canvas.className = "cursor-grab active:cursor-grabbing";
          canvas.draggable = true;
          canvas.dataset.letter = letter;

          const ctx = canvas.getContext("2d");

          // Draw robot circle
          ctx.beginPath();
          ctx.arc(18, 18, 12, 0, 2 * Math.PI);
          ctx.fillStyle = letterColorMap[letter] || "#808080";
          ctx.fill();
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 2;
          ctx.stroke();

          // Draw letter
          ctx.fillStyle = "#fff";
          ctx.font = "bold 14px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(letter, 18, 18);

          canvas.addEventListener("dragstart", (e) => {
            draggedRobot = letter;
            dragSourceCanvas = null;
            dragSourceKey = null;
            e.dataTransfer.effectAllowed = "copy";
          });

          canvas.addEventListener("dragend", () => {
            draggedRobot = null;
            dragSourceCanvas = null;
            dragSourceKey = null;
          });

          palette.appendChild(canvas);
        });
      }

      function createInteractiveGrid(index, isEditable = true) {
        // Get dynamic grid size from config
        const numRobots =
          parseInt(document.getElementById("number_of_robots").value) || 2;
        const visibilityRange =
          parseInt(document.getElementById("visibility_range").value) || 1;
        const gridRange = numRobots * visibilityRange;
        const gridSize = gridRange * 2 + 1; // From -range to +range

        const cellSize = 30;
        const padding = 40; // More padding for coordinate labels
        const canvasWidth = (gridSize - 1) * cellSize + padding * 2;
        const canvasHeight = (gridSize - 1) * cellSize + padding * 2;

        const wrapper = document.createElement("div");
        wrapper.className =
          "p-4 bg-white border-2 border-gray-300 rounded-lg relative";
        wrapper.dataset.gridIndex = index;

        // Add X button in top-right corner (only if editable)
        if (isEditable) {
          const closeBtn = document.createElement("button");
          closeBtn.type = "button";
          closeBtn.className =
            "absolute top-2 right-2 w-6 h-6 flex items-center justify-center text-gray-400 hover:text-red-600 hover:bg-red-50 rounded";
          closeBtn.innerHTML = "Ã—";
          closeBtn.style.fontSize = "24px";
          closeBtn.style.lineHeight = "1";
          closeBtn.dataset.index = index;
          closeBtn.addEventListener("click", () => {
            wrapper.remove();
            updateGridData();
          });
          wrapper.appendChild(closeBtn);
        }

        const header = document.createElement("div");
        header.className = "mb-2";
        header.innerHTML = `<span class="font-medium text-gray-700">Movement Pattern ${index}</span>`;
        wrapper.appendChild(header);

        const canvas = document.createElement("canvas");
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        canvas.className = "border-2 border-gray-400 bg-white";
        canvas.dataset.gridIndex = index;

        const ctx = canvas.getContext("2d");
        const robots = new Map(); // Store robots at each position

        const worldToCanvas = (wx, wy) => {
          const centerX = Math.floor(gridSize / 2);
          const centerY = Math.floor(gridSize / 2);
          return {
            cx: padding + (wx + centerX) * cellSize,
            cy: padding + (centerY - wy) * cellSize,
          };
        };

        const canvasToWorld = (cx, cy) => {
          const centerX = Math.floor(gridSize / 2);
          const centerY = Math.floor(gridSize / 2);
          const wx = Math.round((cx - padding) / cellSize) - centerX;
          const wy = centerY - Math.round((cy - padding) / cellSize);
          return { wx, wy };
        };

        const drawGrid = () => {
          ctx.clearRect(0, 0, canvasWidth, canvasHeight);

          const centerX = Math.floor(gridSize / 2);
          const centerY = Math.floor(gridSize / 2);

          // Draw coordinate labels
          ctx.fillStyle = "#666";
          ctx.font = "10px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";

          // X-axis labels (bottom)
          for (let i = 0; i < gridSize; i++) {
            const wx = i - centerX;
            const cx = padding + i * cellSize;
            ctx.fillText(wx, cx, canvasHeight - 10);
          }

          // Y-axis labels (left)
          ctx.textAlign = "right";
          for (let i = 0; i < gridSize; i++) {
            const wy = centerY - i;
            const cy = padding + i * cellSize;
            ctx.fillText(wy, 10, cy);
          }

          // --- Added Axis Labels for Interactive Grid ---
          ctx.font = "italic bold 14px Times New Roman";
          ctx.fillStyle = "#000";

          // 'x' label
          ctx.textAlign = "center";
          ctx.fillText("x", canvasWidth - 15, canvasHeight - 10);

          // 'y' label
          ctx.textAlign = "center";
          ctx.fillText("y", 10, 15);
          // ---------------------------------------------

          // Draw grid lines
          ctx.strokeStyle = "#e8e8e8";
          ctx.lineWidth = 1;
          for (let i = 0; i < gridSize; i++) {
            const pos = padding + i * cellSize;
            // Vertical lines
            ctx.beginPath();
            ctx.moveTo(pos, padding);
            ctx.lineTo(pos, padding + (gridSize - 1) * cellSize);
            ctx.stroke();
            // Horizontal lines
            ctx.beginPath();
            ctx.moveTo(padding, pos);
            ctx.lineTo(padding + (gridSize - 1) * cellSize, pos);
            ctx.stroke();
          }

          // Draw robots on nodes
          robots.forEach((letter, key) => {
            const [wx, wy] = key.split(",").map(Number);
            const { cx, cy } = worldToCanvas(wx, wy);

            ctx.beginPath();
            ctx.arc(cx, cy, 10, 0, 2 * Math.PI);
            ctx.fillStyle = letterColorMap[letter] || "#808080";
            ctx.fill();
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.fillStyle = "#fff";
            ctx.font = "bold 12px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(letter, cx, cy);
          });
        };

        // Drag and drop support
        canvas.addEventListener("dragover", (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = "copy";
        });

        canvas.addEventListener("drop", (e) => {
          e.preventDefault();

          if (!draggedRobot || !isEditable) return;

          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          const { wx, wy } = canvasToWorld(x, y);
          const key = `${wx},${wy}`;

          // Check bounds
          const centerX = Math.floor(gridSize / 2);
          const centerY = Math.floor(gridSize / 2);
          if (Math.abs(wx) <= centerX && Math.abs(wy) <= centerY) {
            // If dragging from another position in a grid, remove it from source
            if (dragSourceCanvas && dragSourceKey) {
              dragSourceCanvas.robotsMap.delete(dragSourceKey);
              dragSourceCanvas.drawGridFunc();
            }

            robots.set(key, draggedRobot);
            drawGrid();
            updateGridData();
          }
        });

        // Enable dragging robots from the grid
        let isDraggingFromGrid = false;
        let dragStartPos = null;
        let currentMousePos = null;

        canvas.addEventListener("mousedown", (e) => {
          if (!isEditable) return;

          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          const { wx, wy } = canvasToWorld(x, y);
          const key = `${wx},${wy}`;

          if (robots.has(key)) {
            const letter = robots.get(key);
            dragStartPos = { wx, wy, key, letter };
            isDraggingFromGrid = true;

            // Remove from canvas
            robots.delete(key);
            drawGrid();

            // Show drag ghost
            const dragGhost = document.getElementById("dragGhost");
            dragGhost.style.backgroundColor =
              letterColorMap[letter] || "#808080";
            dragGhost.style.display = "block";
            dragGhost.style.left = `${e.clientX}px`;
            dragGhost.style.top = `${e.clientY}px`;

            canvas.style.cursor = "grabbing";
            e.preventDefault();
          }
        });

        canvas.addEventListener("mousemove", (e) => {
          if (dragStartPos && isDraggingFromGrid) {
            const dragGhost = document.getElementById("dragGhost");
            dragGhost.style.left = `${e.clientX}px`;
            dragGhost.style.top = `${e.clientY}px`;
          }
        });

        canvas.addEventListener("mouseup", (e) => {
          if (dragStartPos && isDraggingFromGrid) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const dragGhost = document.getElementById("dragGhost");
            dragGhost.style.display = "none";

            // Check if dropped inside canvas
            if (x >= 0 && y >= 0 && x <= canvasWidth && y <= canvasHeight) {
              // Move to new position
              const { wx, wy } = canvasToWorld(x, y);
              const centerX = Math.floor(gridSize / 2);
              const centerY = Math.floor(gridSize / 2);

              if (Math.abs(wx) <= centerX && Math.abs(wy) <= centerY) {
                const newKey = `${wx},${wy}`;
                robots.set(newKey, dragStartPos.letter);
              }
            }
            // If dropped outside, robot stays deleted

            drawGrid();
            updateGridData();
          }
          dragStartPos = null;
          isDraggingFromGrid = false;
          canvas.style.cursor = "";
        });

        canvas.addEventListener("mouseleave", (e) => {
          if (dragStartPos && isDraggingFromGrid) {
            const dragGhost = document.getElementById("dragGhost");
            dragGhost.style.display = "none";

            // Robot already removed from canvas in mousedown
            drawGrid();
            updateGridData();

            dragStartPos = null;
            isDraggingFromGrid = false;
            canvas.style.cursor = "";
          }
        });

        // Support for HTML5 drag from grid
        canvas.addEventListener("dragstart", (e) => {
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          const { wx, wy } = canvasToWorld(x, y);
          const key = `${wx},${wy}`;

          if (robots.has(key)) {
            draggedRobot = robots.get(key);
            dragSourceCanvas = canvas;
            dragSourceKey = key;
            e.dataTransfer.effectAllowed = "move";
          }
        });

        canvas.robotsMap = robots;
        canvas.drawGridFunc = drawGrid;
        drawGrid();

        wrapper.appendChild(canvas);
        return wrapper;
      }

      function updateGridData(markAsModified = true) {
        const grids = document.querySelectorAll(
          "#interactiveGridsContainer canvas"
        );
        const allViews = [];

        grids.forEach((canvas) => {
          const robots = canvas.robotsMap;
          const robotsArray = [];

          robots.forEach((letter, key) => {
            const [x, y] = key.split(",").map(Number);
            robotsArray.push([letter, x, y]);
          });

          if (robotsArray.length > 0) {
            allViews.push(robotsArray);
          }
        });

        document.getElementById("robotData").value = JSON.stringify(allViews);
        document.getElementById("moving_on_space_pattern").value =
          JSON.stringify(allViews);

        // Mark as modified when movement patterns change (only if flag is true)
        if (markAsModified) {
          configsWereModified = true;
        }

        // Auto-generate collected configs
        if (allViews.length > 0) {
          renderAllAndPopulate();
        }
      }

      document.getElementById("addGridBtn").addEventListener("click", () => {
        const container = document.getElementById(
          "interactiveGridsContainer"
        );
        const index = container.children.length;
        const grid = createInteractiveGrid(index, canEdit);
        container.appendChild(grid);

        // Add remove listener
        grid
          .querySelector(".removeGridBtn")
          .addEventListener("click", (e) => {
            e.target.closest(".p-4").remove();
            updateGridData();
          });
      });

      // Function to populate leader colors from Page 1
      function populateLeaderColors(presetLeaderColors = null) {
        // Get only the colors mentioned in the algorithm
        const colorLetters = colorLettersInput.value
          .split(",")
          .map((s) => s.trim())
          .filter((s) => s);
        const container = document.getElementById("leaderColorsContainer");

        // Store current selections (only if they exist in current algorithm colors)
        const currentSelections =
          presetLeaderColors ||
          Array.from(
            container.querySelectorAll('input[type="checkbox"]:checked')
          ).map((cb) => cb.value)
            .filter(val => colorLetters.includes(val)); // Only keep selections that exist in current colors

        container.innerHTML = "";

        // Only show colors that are in the algorithm's color configuration
        colorLetters.forEach((letter) => {
          const div = document.createElement("div");
          div.className = "relative flex items-center";

          const isChecked =
            currentSelections.includes(letter) ||
            (currentSelections.length === 0 && letter === "L");
          const disabledAttr = !canEdit ? "disabled" : "";
          const disabledClass = !canEdit
            ? "cursor-not-allowed opacity-60"
            : "";

          div.innerHTML = `
                        <div class="flex items-center h-5">
                            <input id="leader_${letter}" type="checkbox" value="${letter}" class="leader-color-checkbox h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500 ${disabledClass}" ${isChecked ? "checked" : ""
            } ${disabledAttr}>
                        </div>
                        <div class="ml-3 text-sm">
                            <label for="leader_${letter}" class="font-medium text-gray-700 ${disabledClass}">${letter}</label>
                        </div>
                    `;

          container.appendChild(div);
        });

        // Add change event listeners to auto-update (only if editable)
        if (canEdit) {
          container
            .querySelectorAll(".leader-color-checkbox")
            .forEach((checkbox) => {
              checkbox.addEventListener("change", () => {
                // Mark as modified when leader colors change
                configsWereModified = true;
                renderAllAndPopulate();
              });
            });
        }
      }

      // Function to reset initial configurations from preset
      function resetInitialConfigurationsFromPreset() {
        if (!originalPresetConfigs) {
          console.log("No original preset configs to reset to");
          return;
        }

        // Reset the modification flag
        configsWereModified = false;

        // Regenerate with original preset data
        renderAllAndPopulate();
      }

      // --- Event Listeners ---

      generateBtn.addEventListener("click", () => {
        // Navigate to page 3 (Goals Simulator)
        // JSON will be generated when user navigates to page 4
        forceGoalsReload = true; // Force reload from Page 2 configs or preset
        currentPage = 3;
        updateUI();
      });

      nextBtn.addEventListener("click", () => {
        // Simple validation for Page 1
        const mode = genModeSelect.value;
        const valueStr = genModeValueInput.value;
        if (mode !== "All" && !valueStr) {
          showModal(`A value is required for Generation Mode: ${mode}`);
        } else {
          // Sync color map with current color picker values
          syncLetterColorMap();

          currentPage = 2;
          updateUI();

          // Disable/enable Add View button based on canEdit only
          const addGridBtn = document.getElementById("addGridBtn");
          if (addGridBtn) {
            addGridBtn.disabled = !canEdit;
            if (!canEdit) {
              addGridBtn.classList.add(
                "bg-gray-400",
                "cursor-not-allowed",
                "hover:bg-gray-400"
              );
              addGridBtn.classList.remove("bg-blue-600", "hover:bg-blue-700");
            } else {
              addGridBtn.classList.remove(
                "bg-gray-400",
                "cursor-not-allowed",
                "hover:bg-gray-400"
              );
              addGridBtn.classList.add("bg-blue-600", "hover:bg-blue-700");
            }
          }

          // Update grid size display
          updateGridSizeDisplay();
          // Populate leader colors from Page 1 or preset
          let presetData = null;
          if (currentPreset !== "custom") {
            const preset = algorithmPresets.find(p => p.id === currentPreset);
            if (preset) presetData = preset.data;
          }

          if (presetData) {
            populateLeaderColors(presetData.leader_colors);
          }
          // Populate robot palette
          populateRobotPalette();

          // Initialize collapsible Initial Configuration Editor state
          initializeInitialConfigState();

          // Clear any existing grids and add default initial grids
          const container = document.getElementById(
            "interactiveGridsContainer"
          );
          container.innerHTML = "";

          // Get default configs from preset
          let defaultConfigs;
          if (presetData && presetData.moving_on_space_pattern) {
            defaultConfigs = presetData.moving_on_space_pattern;
          } else {
            // For custom mode, check if we have loaded data
            const movingPatternTextarea = document.getElementById("moving_on_space_pattern");
            if (movingPatternTextarea && movingPatternTextarea.value.trim()) {
              try {
                const loadedPattern = JSON.parse(movingPatternTextarea.value);
                if (Array.isArray(loadedPattern) && loadedPattern.length > 0) {
                  // Check format and extract robot positions
                  const firstItem = loadedPattern[0];
                  if (Array.isArray(firstItem) && firstItem.length === 2 && typeof firstItem[1] === "boolean") {
                    // Old format: [[config, isLeader], ...]
                    defaultConfigs = loadedPattern.map(([config, isLeader]) => config.slice(1)); // Remove obstacle
                  } else {
                    // New format: [[robot, robot], ...]
                    defaultConfigs = loadedPattern;
                  }
                  console.log("Using loaded movement patterns:", defaultConfigs);
                } else {
                  // Fallback to generic defaults
                  defaultConfigs = [
                    [
                      ["L", 0, 0],
                      ["F", -2, 0],
                    ],
                    [
                      ["L", 0, 0],
                      ["F", -1, 0],
                    ],
                  ];
                }
              } catch (e) {
                console.error("Error parsing moving_on_space_pattern:", e);
                // Fallback to generic defaults
                defaultConfigs = [
                  [
                    ["L", 0, 0],
                    ["F", -2, 0],
                  ],
                  [
                    ["L", 0, 0],
                    ["F", -1, 0],
                  ],
                ];
              }
            } else {
              // No loaded data, use generic defaults
              defaultConfigs = [
                [
                  ["L", 0, 0],
                  ["F", -2, 0],
                ],
                [
                  ["L", 0, 0],
                  ["F", -1, 0],
                ],
              ];
            }
          }

          defaultConfigs.forEach((config, idx) => {
            const grid = createInteractiveGrid(idx, canEdit);
            container.appendChild(grid);

            // Populate the grid with robots
            const canvas = grid.querySelector("canvas");
            const robotsMap = canvas.robotsMap;
            config.forEach(([letter, x, y]) => {
              const key = `${x},${y}`;
              robotsMap.set(key, letter);
            });
            canvas.drawGridFunc();
          });

          // Don't mark as modified during initial population from preset
          updateGridData(false);
        }
      });

      prevBtn2.addEventListener("click", () => {
        currentPage = 1;
        updateUI();
      });

      prevBtn3.addEventListener("click", () => {
        currentPage = 2;
        updateUI();
      });

      nextBtn3.addEventListener("click", () => {
        // Capture simulation configs from embedded simulator before moving to export page
        // The simulator is embedded directly, so activeSimulationConfigs is available in this window
        if (window.activeSimulationConfigs) {
          console.log("=== Capturing goals from simulator ===");
          console.log(
            "Active simulation configs:",
            window.activeSimulationConfigs.length
          );

          // Convert simulator configs to goals format
          const capturedGoals = {
            simulation_configs: window.activeSimulationConfigs.map(
              (config) => {
                const boundaries = config.boundaries || {
                  xmin: -6,
                  xmax: 6,
                  ymin: -6,
                  ymax: 6,
                };
                const grids = config.grids || [];
                const gridSteps = config.gridSteps || [];
                const gridWaypoints = config.gridWaypoints || [];
                const gridExclusivePoints = config.gridExclusivePoints || [];
                const walls = config.walls || [];

                // Find vertical and horizontal walls
                let verticalWall = null,
                  horizontalWall = null;
                walls.forEach((wall) => {
                  if (wall.type === "vertical") {
                    verticalWall = wall.x1;
                  } else if (wall.type === "horizontal") {
                    horizontalWall = wall.y1;
                  }
                });

                // Format grids: starting grid as initial_positions, targets with steps
                let initialPositions = [];
                let targets = [];

                if (grids.length > 0) {
                  initialPositions = grids[0].map(([color, x, y]) => [
                    color,
                    x,
                    y,
                  ]);

                  for (let i = 1; i < grids.length; i++) {
                    const steps = (gridSteps && gridSteps[i]) || 5;
                    const robots = grids[i].map(([color, x, y]) => [
                      color,
                      x,
                      y,
                    ]);
                    const exclusivePoints = (
                      gridExclusivePoints[i] || []
                    ).map(([x, y]) => [x, y]);
                    const waypoints = (gridWaypoints[i] || []).map(
                      ([x, y]) => [x, y]
                    );
                    targets.push([steps, robots, exclusivePoints, waypoints]);
                  }
                }

                return {
                  initial_positions: initialPositions,
                  targets: targets,
                  boundary: [
                    boundaries.xmin,
                    boundaries.xmax,
                    boundaries.ymin,
                    boundaries.ymax,
                  ],
                  wall: [verticalWall, horizontalWall],
                };
              }
            ),
          };

          // Store in global variable for export
          collectedConfigurations = capturedGoals;
          console.log("Captured goals:", capturedGoals);
        } else {
          console.warn("No activeSimulationConfigs found in window");
        }

        currentPage = 4;
        updateUI();
      });

      prevBtn4.addEventListener("click", () => {
        forceGoalsReload = false; // Preserve existing goals state
        currentPage = 3;
        updateUI();
      });

      copyBtn.addEventListener("click", () => {
        const textToCopy = jsonOutput.textContent;

        // Use document.execCommand as navigator.clipboard might fail in iframes
        const textArea = document.createElement("textarea");
        textArea.value = textToCopy;
        textArea.style.position = "fixed"; // Avoid scrolling to bottom
        textArea.style.top = "0";
        textArea.style.left = "0";
        document.body.appendChild(textArea);

        textArea.focus();
        textArea.select();

        try {
          document.execCommand("copy");
          copyBtn.textContent = "Copied!";
          setTimeout(() => {
            copyBtn.textContent = "Copy";
          }, 2000);
        } catch (err) {
          console.error("Failed to copy text: ", err);
          showModal("Failed to copy text. Please copy manually.");
        }

        document.body.removeChild(textArea);
      });

      downloadBtn.addEventListener("click", () => {
        const jsonString = jsonOutput.textContent;
        const blob = new Blob([jsonString], { type: "application/json" });
        const url = URL.createObjectURL(blob);

        const a = document.createElement("a");
        a.href = url;
        a.download = "config.json";
        document.body.appendChild(a);
        a.click();

        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });

      // --- NEW PAGE 2 LISTENERS ---
      // Auto-generate is now triggered by updateGridData() and leader checkbox changes
      // --- END NEW LISTENERS ---

      // Load Config Button
      const loadConfigBtn = document.getElementById("loadConfigBtn");
      const loadConfigInput = document.getElementById("loadConfigInput");

      loadConfigBtn.addEventListener("click", () => {
        loadConfigInput.click();
      });

      loadConfigInput.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const loadedData = JSON.parse(event.target.result);
            console.log("Loaded config data:", loadedData);

            // FIRST: Add loaded config as temporary preset
            const presetSelect = document.getElementById("algorithm_preset");
            if (presetSelect) {
              // Create temporary preset from loaded config
              const customPreset = {
                title: "Custom loaded",
                description: `Loaded config file name: ${file.name}`,
                data: loadedData
              };

              // Remove old custom preset if exists
              const customIndex = algorithmPresets.findIndex(p => p.title === "Custom loaded");
              if (customIndex !== -1) {
                algorithmPresets.splice(customIndex, 1);
              }

              // Add new custom preset
              algorithmPresets.push(customPreset);
              const newIndex = algorithmPresets.length - 1;
              currentPreset = newIndex.toString();

              // Repopulate dropdown to include new preset
              populatePresetOptions();
              presetSelect.value = currentPreset;

              console.log("Added loaded config as temporary preset at index", newIndex);

              // Update preset description
              updatePresetDescription(currentPreset);
            }

            // SECOND: Populate Page 1 form fields (now that they're enabled)
            console.log("Populating form with loaded data...");
            populateForm(loadedData);

            // Populate Leader Colors checkboxes
            if (loadedData.leader_colors) {
              populateLeaderColors(loadedData.leader_colors);
            }

            // Sync color map after loading
            syncLetterColorMap();
            console.log("Form populated and color map synced");

            // Update robot palette with loaded colors
            populateRobotPalette();

            // Store goals for later loading into simulator
            // We'll load them when user navigates to Page 3
            if (loadedData.goals) {
              let goals = loadedData.goals;
              const targetObstacle = loadedData.obstacle || "O";

              // Normalize obstacle characters in goals to match the loaded obstacle type
              goals = goals.map(goal => {
                const newGoal = JSON.parse(JSON.stringify(goal));

                // Replace O or W with targetObstacle in initial_positions
                if (newGoal.initial_positions) {
                  newGoal.initial_positions.forEach(pos => {
                    if (pos[0] === "O" || pos[0] === "W") pos[0] = targetObstacle;
                  });
                }

                // Replace O or W with targetObstacle in targets
                if (newGoal.targets) {
                  newGoal.targets.forEach(target => {
                    if (target[1]) {
                      target[1].forEach(pos => {
                        if (pos[0] === "O" || pos[0] === "W") pos[0] = targetObstacle;
                      });
                    }
                  });
                }
                return newGoal;
              });

              // Store in global variable for simulator
              window.loadedGoalsData = goals;
              console.log("Stored goals for simulator:", window.loadedGoalsData);
            }

            // Switch to page 1 to show loaded configuration
            currentPage = 1;
            updateUI();

            alert("Configuration loaded successfully!");
            // Reset file input
            loadConfigInput.value = "";
          } catch (error) {
            console.error("Error loading config file:", error);
            alert(`Error loading config file: ${error.message}`);
            loadConfigInput.value = "";
          }
        };
        reader.readAsText(file);
      });



      // Set initial UI state
      updateUI();

      // ===================================================================
      // EMBEDDED GOALS SIMULATOR JAVASCRIPT
      // ===================================================================
      initializeGoalsSimulator();
    });

    // Goals Simulator Initialization Function
    function initializeGoalsSimulator() {
      console.log("Initializing embedded goals simulator...");
      console.log(
        "Using defaultSimulationConfigList with",
        JSON.parse(defaultSimulationConfigList).simulation_configs.length,
        "goals"
      );

      // === EMBEDDED GOALS SIMULATOR CODE START ===
      // Complete JavaScript from goals_simulator_v4.html embedded below
      // defaultSimulationConfigList is now a global variable
      // Function to parse and create simulation configs from defaultSimulationConfigList
      // OR from passed data
      function parseDefaultConfigs(inputData) {
        try {
          console.log("Parsing configs...");
          // Use inputData if provided, otherwise parse defaultSimulationConfigList
          let parsedData;
          if (inputData) {
            parsedData = inputData; // Assume inputData is already an object or array
            // If it's the full config object with 'goals' array (from config.json)
            if (Array.isArray(parsedData)) {
              // It's likely just the goals array
              parsedData = { simulation_configs: parsedData };
            } else if (parsedData.goals && Array.isArray(parsedData.goals)) {
              // It's the full config object
              parsedData = { simulation_configs: parsedData.goals };
            } else if (!parsedData.simulation_configs) {
              // Try to wrap it if it looks like a list of configs
              parsedData = { simulation_configs: parsedData };
            }
          } else {
            parsedData = JSON.parse(defaultSimulationConfigList);
          }

          console.log(
            "Parsed data has",
            parsedData.simulation_configs?.length || 0,
            "configs"
          );

          if (
            parsedData &&
            parsedData.simulation_configs &&
            Array.isArray(parsedData.simulation_configs)
          ) {
            return parsedData.simulation_configs.map((config, index) => {
              const boundaries = config.boundary || [-6, 6, -6, 6];
              const walls = [];

              // Convert wall array [vertical, horizontal] to wall objects
              if (config.wall && config.wall.length >= 2) {
                const [verticalWall, horizontalWall] = config.wall;

                if (verticalWall !== null) {
                  walls.push({
                    type: "vertical",
                    x1: verticalWall,
                    y1: boundaries[2] - 5, // ymin - 5
                    x2: verticalWall,
                    y2: boundaries[3] + 5, // ymax + 5
                  });
                }

                if (horizontalWall !== null) {
                  walls.push({
                    type: "horizontal",
                    x1: boundaries[0] - 5, // xmin - 5
                    y1: horizontalWall,
                    x2: boundaries[1] + 5, // xmax + 5
                    y2: horizontalWall,
                  });
                }
              }

              // Convert targets to grids format
              const grids = [config.initial_positions || []];
              const gridSteps = [0]; // Starting position
              const gridWaypoints = [[]]; // Starting grid has no waypoints
              const gridExclusivePoints = [[]]; // Starting grid has no exclusive points

              if (config.targets && Array.isArray(config.targets)) {
                config.targets.forEach((target) => {
                  if (Array.isArray(target) && target.length >= 4) {
                    const [steps, robots, exclusive, waypoints] = target;
                    grids.push(robots || []);
                    gridSteps.push(steps || 5);
                    gridWaypoints.push(waypoints || []);
                    gridExclusivePoints.push(exclusive || []);
                  }
                });
              }

              // Ensure at least one target grid
              if (grids.length < 2) {
                grids.push([]);
                gridSteps.push(5);
                gridWaypoints.push([]);
                gridExclusivePoints.push([]);
              }

              // Calculate total steps
              const totalSteps = gridSteps
                .slice(1)
                .reduce((sum, steps) => sum + steps, 0);

              return {
                id: `cfg-default-${Date.now()}-${index}`,
                grids,
                steps: totalSteps,
                gridSteps,
                gridWaypoints,
                gridExclusivePoints,
                boundaries: {
                  xmin: boundaries[0],
                  xmax: boundaries[1],
                  ymin: boundaries[2],
                  ymax: boundaries[3],
                },
                walls,
                needsRedraw: true,
              };
            });
          } else {
            throw new Error(
              "Invalid JSON format. Expected object with 'simulation_configs' array."
            );
          }
        } catch (error) {
          console.error("Error parsing configurations:", error);
          // Fallback to empty array
          return [];
        }
      }

      // Initialize with empty array - will be populated in initialize()
      // MAKE THIS GLOBAL so it's accessible from handleFormSubmit()
      window.activeSimulationConfigs = [];

      // EXPOSE FUNCTION TO LOAD GOALS
      window.loadGoalsIntoSimulator = function (goalsData) {
        console.log("Loading goals into simulator:", goalsData);
        window.activeSimulationConfigs = parseDefaultConfigs(goalsData);
        renderAllFrames();
        updateFullConfigTextArea();
      };
      // --- Initial Data ---
      /* let activeSimulationConfigs = [
      {
        id: `cfg-${Date.now()}-0`,
          [
            ["O", 0, 0],
            ["F", 0, 1],
            ["R", -1, 1],
          ],
          [
            ["O", 0, 0],
            ["R", -2, 1],
            ["F", -1, 1],
          ],
        ],
        steps: 1,
        boundaries: { xmin: -3, xmax: 1, ymin: -1, ymax: 2 },
        waypoints: [],
        exclusive_points: [],
      },
      {
        id: `cfg-${Date.now()}-1`,
        grids: [
          [
            ["O", 0, 0],
            ["F", 0, 1],
            ["L", -1, 1],
          ],
          [
            ["O", 0, 0],
            ["L", -2, 1],
            ["F", -1, 1],
          ],
        ],
        steps: 1,
        boundaries: { xmin: -3, xmax: 1, ymin: -1, ymax: 2 },
        waypoints: [],
        exclusive_points: [],
      },
    ].map((cfg) => ({ ...cfg, needsRedraw: true }));
*/
      // --- Constants and Config ---
      const FRAME_CANVAS_SIZE = 300;
      const FRAME_SCALE = 25;
      const FRAME_OFFSET = FRAME_CANVAS_SIZE / 2;
      const simConfig = {
        colors: {
          L: "#FF0000",
          R: "#008000",
          F: "#0000FF",
          O: "#FFA500",
          r: "#FF0000",
          g: "#008000",
          b: "#0000FF",
          o: "#FFA500",
          B: "#0000FF",
          G: "#008000",
          Y: "#FFFF00",
          P: "#800080",
          y: "#FFFF00",
          p: "#800080",
          W: "#333",
          w: "#333",
        },
        boundaryColor: "#666",
        boundaryWidth: 2,
        robotRadius: 8,
        boundaryHitThreshold: 10,
        waypointColor: "#0c2c67",
        exclusivePointColor: "#0c2c67",
        waypointRadius: 8,
        exclusivePointRadius: 8,
      };
      const SCROLL_ZONE_HEIGHT = 60;
      const SCROLL_SPEED = 10;

      // --- Global State Variables ---
      let frameElements = {};
      let draggedItem = null;
      let draggedRobotData = null;
      let draggedWaypointData = null;
      let draggedExclusivePointData = null;
      let draggedBoundaryEdge = null;
      let sourceCanvasElement = null;
      let sourceConfigId = null;
      let sourceGridIndex = -1;
      let sourceRobotsListRef = null;
      let sourceWaypointsListRef = null;
      let sourceExclusivePointsListRef = null;
      let draggedRobotIndex = -1;
      let draggedWaypointIndex = -1;
      let draggedExclusivePointIndex = -1;
      let isNewRobotFromPalette = false;
      let isNewWaypointFromPalette = false;
      let isNewExclusivePointFromPalette = false;
      let isNewWallFromPalette = false;
      let draggedWallData = null;
      let draggedFrameId = null;
      let dropIndicator = null;
      let scrollIntervalId = null;
      let currentPaletteDragSource = null;

      // --- Element References ---
      const simulatorColumn = document.getElementById("simulator-column");
      const simulationConfigListTextArea = document.getElementById(
        "simulationConfigList"
      );
      const dragGhost = document.getElementById("dragGhost");
      const boundaryGhost = document.getElementById("boundaryGhost");
      const loadModal = document.getElementById("loadModal");
      const newConfigEditor = document.getElementById("newConfigEditor");
      const addFrameBtn = document.getElementById("addFrameBtn");
      const resizeHandle = document.getElementById("resizeHandle");
      const toggleEditorBtn = document.getElementById("toggleEditorBtn");
      const editorColumn = document.getElementById("editor-column");
      const mainContainer = document.querySelector(".main-container");

      // --- Help Modal Elements ---
      const parametersHelpBtn = document.getElementById("parametersHelpBtn");
      const parametersHelpModal = document.getElementById("parametersHelpModal");
      const closeParametersHelpModal = document.getElementById("closeParametersHelpModal");

      const goalsHelpBtn = document.getElementById("goalsHelpBtn");
      const goalsHelpModal = document.getElementById("goalsHelpModal");
      const closeHelpModal = document.getElementById("closeHelpModal");

      const initialConfigHelpBtn = document.getElementById("initialConfigHelpBtn");
      const initialConfigHelpModal = document.getElementById("initialConfigHelpModal");
      const closeInitialConfigHelpModal = document.getElementById("closeInitialConfigHelpModal");

      // Open Parameters help modal
      if (parametersHelpBtn) {
        parametersHelpBtn.addEventListener("click", () => {
          parametersHelpModal.style.display = "block";
        });
      }

      // Close Parameters help modal
      if (closeParametersHelpModal) {
        closeParametersHelpModal.addEventListener("click", () => {
          parametersHelpModal.style.display = "none";
        });
      }

      // Close Parameters help modal when clicking outside
      if (parametersHelpModal) {
        parametersHelpModal.addEventListener("click", (e) => {
          if (e.target === parametersHelpModal) {
            parametersHelpModal.style.display = "none";
          }
        });
      }

      // Open Goals help modal
      if (goalsHelpBtn) {
        goalsHelpBtn.addEventListener("click", () => {
          goalsHelpModal.style.display = "block";
        });
      }

      // Close Goals help modal
      if (closeHelpModal) {
        closeHelpModal.addEventListener("click", () => {
          goalsHelpModal.style.display = "none";
        });
      }

      // Close Goals help modal when clicking outside
      if (goalsHelpModal) {
        goalsHelpModal.addEventListener("click", (e) => {
          if (e.target === goalsHelpModal) {
            goalsHelpModal.style.display = "none";
          }
        });
      }

      // Open Initial Config help modal
      if (initialConfigHelpBtn) {
        initialConfigHelpBtn.addEventListener("click", () => {
          initialConfigHelpModal.style.display = "block";
        });
      }

      // Close Initial Config help modal
      if (closeInitialConfigHelpModal) {
        closeInitialConfigHelpModal.addEventListener("click", () => {
          initialConfigHelpModal.style.display = "none";
        });
      }

      // Close Initial Config help modal when clicking outside
      if (initialConfigHelpModal) {
        initialConfigHelpModal.addEventListener("click", (e) => {
          if (e.target === initialConfigHelpModal) {
            initialConfigHelpModal.style.display = "none";
          }
        });
      }

      // Close help modals with Escape key
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          if (parametersHelpModal && parametersHelpModal.style.display === "block") {
            parametersHelpModal.style.display = "none";
          }
          if (goalsHelpModal && goalsHelpModal.style.display === "block") {
            goalsHelpModal.style.display = "none";
          }
          if (initialConfigHelpModal && initialConfigHelpModal.style.display === "block") {
            initialConfigHelpModal.style.display = "none";
          }
        }
      });

      // Disable Add Goal and Reset Goals buttons if canEdit is false
      if (!canEdit) {
        const addFrameBtn = document.getElementById("addFrameBtn");
        const resetConfigBtn = document.getElementById("resetConfigBtn");

        if (addFrameBtn) {
          addFrameBtn.disabled = true;
          addFrameBtn.style.opacity = "0.5";
          addFrameBtn.style.cursor = "not-allowed";
          addFrameBtn.title = "Editing is disabled";
        }

        if (resetConfigBtn) {
          resetConfigBtn.disabled = true;
          resetConfigBtn.style.opacity = "0.5";
          resetConfigBtn.style.cursor = "not-allowed";
          resetConfigBtn.title = "Editing is disabled";
        }
      }

      // --- Resize and Toggle Variables ---
      let isResizing = false;
      let isEditorHidden = true; // Changed to true - hidden by default
      const LAYOUT_STORAGE_KEY = "multiRobotSimLayout_v1";

      // --- Helper Functions ---
      function frameWorldToCanvas(x, y) {
        return {
          cx: FRAME_OFFSET + x * FRAME_SCALE,
          cy: FRAME_OFFSET - y * FRAME_SCALE,
        };
      }
      function frameCanvasToWorld(cx, cy) {
        return {
          x: (cx - FRAME_OFFSET) / FRAME_SCALE,
          y: (FRAME_OFFSET - cy) / FRAME_SCALE,
        };
      }
      function isWithinBoundaries(x, y, frameBoundaries) {
        if (!frameBoundaries) return false;
        return (
          x >= frameBoundaries.xmin &&
          x <= frameBoundaries.xmax &&
          y >= frameBoundaries.ymin &&
          y <= frameBoundaries.ymax
        );
      }

      function distancePointToLine(px, py, x1, y1, x2, y2) {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const lenSq = C * C + D * D;

        if (lenSq === 0) return Math.sqrt(A * A + B * B);

        let param = dot / lenSq;

        if (param < 0) {
          return Math.sqrt(A * A + B * B);
        } else if (param > 1) {
          const E = px - x2;
          const F = py - y2;
          return Math.sqrt(E * E + F * F);
        } else {
          const closestX = x1 + param * C;
          const closestY = y1 + param * D;
          const dx = px - closestX;
          const dy = py - closestY;
          return Math.sqrt(dx * dx + dy * dy);
        }
      }

      // --- Drawing Functions ---
      function drawGridLines(ctx) {
        if (!ctx) return;
        ctx.clearRect(0, 0, FRAME_CANVAS_SIZE, FRAME_CANVAS_SIZE);
        ctx.strokeStyle = "#e8e8e8";
        ctx.lineWidth = 1;
        ctx.setLineDash([]);
        const gridRange = 6;
        for (let i = -gridRange; i <= gridRange; i++) {
          if (i === 0) continue;
          const { cx } = frameWorldToCanvas(i, 0);
          ctx.beginPath();
          ctx.moveTo(cx + 0.5, 0);
          ctx.lineTo(cx + 0.5, FRAME_CANVAS_SIZE);
          ctx.stroke();
          const { cy } = frameWorldToCanvas(0, i);
          ctx.beginPath();
          ctx.moveTo(0, cy + 0.5);
          ctx.lineTo(FRAME_CANVAS_SIZE, cy + 0.5);
          ctx.stroke();
        }
        ctx.strokeStyle = "#b0b0b0";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, FRAME_OFFSET + 0.5);
        ctx.lineTo(FRAME_CANVAS_SIZE, FRAME_OFFSET + 0.5);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(FRAME_OFFSET + 0.5, 0);
        ctx.lineTo(FRAME_OFFSET + 0.5, FRAME_CANVAS_SIZE);
        ctx.stroke();
      }
      function drawBoundaries(ctx, frameBoundaries, rotation = 0) {
        if (!ctx || !frameBoundaries) return;

        ctx.save();
        // Apply rotation if specified
        if (rotation) {
          ctx.translate(CANVAS_CENTER_X, CANVAS_CENTER_Y);
          ctx.rotate((rotation * Math.PI) / 180);
          ctx.translate(-CANVAS_CENTER_X, -CANVAS_CENTER_Y);
        }

        ctx.strokeStyle = simConfig.boundaryColor;
        ctx.lineWidth = simConfig.boundaryWidth;
        ctx.setLineDash([5, 3]);
        const { cx: xmin_cx } = frameWorldToCanvas(frameBoundaries.xmin, 0);
        const { cx: xmax_cx } = frameWorldToCanvas(frameBoundaries.xmax, 0);
        const { cy: ymin_cy } = frameWorldToCanvas(0, frameBoundaries.ymin);
        const { cy: ymax_cy } = frameWorldToCanvas(0, frameBoundaries.ymax);
        ctx.strokeRect(
          xmin_cx,
          ymax_cy,
          xmax_cx - xmin_cx,
          ymin_cy - ymax_cy
        );
        ctx.setLineDash([]);

        ctx.restore();
      }
      function drawRobots(ctx, robots, frameBoundaries, rotation = 0) {
        if (!ctx || !robots) return;

        ctx.save();
        // Apply rotation if specified
        if (rotation) {
          ctx.translate(CANVAS_CENTER_X, CANVAS_CENTER_Y);
          ctx.rotate((rotation * Math.PI) / 180);
          ctx.translate(-CANVAS_CENTER_X, -CANVAS_CENTER_Y);
        }

        robots.forEach(([color, x, y]) => {
          const { cx, cy } = frameWorldToCanvas(x, y);
          const isInBounds = isWithinBoundaries(x, y, frameBoundaries);

          // Draw circle
          ctx.fillStyle = simConfig.colors[color] || "gray";
          ctx.beginPath();
          ctx.arc(cx, cy, simConfig.robotRadius, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = isInBounds ? "#000" : "#e53935";
          ctx.lineWidth = isInBounds ? 2 : 2;
          ctx.stroke();

          // Draw letter inside
          ctx.fillStyle = "#fff";
          ctx.font = "bold 14px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(color, cx, cy);
        });

        ctx.restore();
      }

      function drawWaypoints(ctx, waypoints, frameBoundaries, rotation = 0) {
        if (!ctx || !waypoints) return;

        ctx.save();
        // Apply rotation if specified
        if (rotation) {
          ctx.translate(CANVAS_CENTER_X, CANVAS_CENTER_Y);
          ctx.rotate((rotation * Math.PI) / 180);
          ctx.translate(-CANVAS_CENTER_X, -CANVAS_CENTER_Y);
        }

        waypoints.forEach(([x, y]) => {
          const { cx, cy } = frameWorldToCanvas(x, y);
          const isInBounds = isWithinBoundaries(x, y, frameBoundaries);

          // Draw circle background
          const size = simConfig.waypointRadius;
          ctx.fillStyle = simConfig.waypointColor;
          ctx.beginPath();
          ctx.arc(cx, cy, size, 0, Math.PI * 2);
          ctx.fill();

          // Draw location pin icon
          ctx.fillStyle = "#fff";
          const pinSize = size * 1.3;
          const pinTop = cy - pinSize * 0.4;
          const pinRadius = pinSize * 0.4;

          // Pin head
          ctx.beginPath();
          ctx.arc(cx, pinTop, pinRadius, 0, Math.PI * 2);
          ctx.fill();

          // Pin point
          ctx.beginPath();
          ctx.moveTo(cx - pinRadius * 0.3, pinTop + pinRadius * 0.7);
          ctx.lineTo(cx, cy + pinSize * 0.3);
          ctx.lineTo(cx + pinRadius * 0.3, pinTop + pinRadius * 0.7);
          ctx.closePath();
          ctx.fill();

          // Inner dot
          ctx.fillStyle = simConfig.waypointColor;
          ctx.beginPath();
          ctx.arc(cx, pinTop, pinRadius * 0.4, 0, Math.PI * 2);
          ctx.fill();

          // Border
          ctx.strokeStyle = isInBounds ? "#333" : "#e53935";
          ctx.lineWidth = isInBounds ? 1.5 : 2;
          ctx.beginPath();
          ctx.arc(cx, cy, size, 0, Math.PI * 2);
          ctx.stroke();
        });

        ctx.restore();
      }

      function drawExclusivePoints(
        ctx,
        exclusivePoints,
        frameBoundaries,
        rotation = 0
      ) {
        if (!ctx || !exclusivePoints) return;

        ctx.save();
        // Apply rotation if specified
        if (rotation) {
          ctx.translate(CANVAS_CENTER_X, CANVAS_CENTER_Y);
          ctx.rotate((rotation * Math.PI) / 180);
          ctx.translate(-CANVAS_CENTER_X, -CANVAS_CENTER_Y);
        }

        exclusivePoints.forEach(([x, y]) => {
          const { cx, cy } = frameWorldToCanvas(x, y);
          const isInBounds = isWithinBoundaries(x, y, frameBoundaries);

          // Draw circle background
          const size = simConfig.exclusivePointRadius;
          ctx.fillStyle = simConfig.exclusivePointColor;
          ctx.beginPath();
          ctx.arc(cx, cy, size, 0, Math.PI * 2);
          ctx.fill();

          // Draw X inside
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(cx - size * 0.6, cy - size * 0.6);
          ctx.lineTo(cx + size * 0.6, cy + size * 0.6);
          ctx.moveTo(cx + size * 0.6, cy - size * 0.6);
          ctx.lineTo(cx - size * 0.6, cy + size * 0.6);
          ctx.stroke();

          // Border
          ctx.strokeStyle = isInBounds ? "#333" : "#e53935";
          ctx.lineWidth = isInBounds ? 1.5 : 2;
          ctx.beginPath();
          ctx.arc(cx, cy, size, 0, Math.PI * 2);
          ctx.stroke();
        });

        ctx.restore();
      }

      function drawWalls(ctx, walls, frameBoundaries, rotation = 0) {
        if (!ctx || !walls) return;

        ctx.save();
        // Apply rotation if specified
        if (rotation) {
          ctx.translate(FRAME_OFFSET, FRAME_OFFSET);
          ctx.rotate((rotation * Math.PI) / 180);
          ctx.translate(-FRAME_OFFSET, -FRAME_OFFSET);
        }

        // Find all intersection points
        const intersections = [];
        for (let i = 0; i < walls.length; i++) {
          for (let j = i + 1; j < walls.length; j++) {
            const wall1 = walls[i];
            const wall2 = walls[j];

            const intersection = findWallIntersection(wall1, wall2);
            if (intersection) {
              intersections.push({
                x: intersection.x,
                y: intersection.y,
                wall1: wall1,
                wall2: wall2,
              });
            }
          }
        }

        // Draw each wall, trimming at intersections
        walls.forEach((wall) => {
          // Find intersections that affect this wall
          const wallIntersections = intersections.filter(
            (intersection) =>
              intersection.wall1 === wall || intersection.wall2 === wall
          );

          if (wallIntersections.length === 0) {
            // No intersections, draw the full wall
            const { cx: cx1, cy: cy1 } = frameWorldToCanvas(wall.x1, wall.y1);
            const { cx: cx2, cy: cy2 } = frameWorldToCanvas(wall.x2, wall.y2);

            ctx.strokeStyle = "#000";
            ctx.lineWidth = 4;
            ctx.lineCap = "butt";
            ctx.beginPath();
            ctx.moveTo(cx1, cy1);
            ctx.lineTo(cx2, cy2);
            ctx.stroke();
          } else {
            // Find the closest intersection point to trim the wall
            let startPoint = { x: wall.x1, y: wall.y1 };
            let endPoint = { x: wall.x2, y: wall.y2 };

            // For each intersection, determine if it should replace start or end point
            wallIntersections.forEach((intersection) => {
              const intPoint = { x: intersection.x, y: intersection.y };

              // Check if intersection is closer to start or end
              const distToStart =
                Math.abs(intPoint.x - wall.x1) +
                Math.abs(intPoint.y - wall.y1);
              const distToEnd =
                Math.abs(intPoint.x - wall.x2) +
                Math.abs(intPoint.y - wall.y2);

              if (distToStart < distToEnd) {
                // Intersection is closer to start, so trim from start
                if (wall.y1 === wall.y2) {
                  // Horizontal wall - check if intersection is between start and end
                  if (
                    intPoint.x >= Math.min(wall.x1, wall.x2) &&
                    intPoint.x <= Math.max(wall.x1, wall.x2)
                  ) {
                    startPoint = intPoint;
                  }
                } else {
                  // Vertical wall - check if intersection is between start and end
                  if (
                    intPoint.y >= Math.min(wall.y1, wall.y2) &&
                    intPoint.y <= Math.max(wall.y1, wall.y2)
                  ) {
                    startPoint = intPoint;
                  }
                }
              } else {
                // Intersection is closer to end, so trim from end
                if (wall.y1 === wall.y2) {
                  // Horizontal wall
                  if (
                    intPoint.x >= Math.min(wall.x1, wall.x2) &&
                    intPoint.x <= Math.max(wall.x1, wall.x2)
                  ) {
                    endPoint = intPoint;
                  }
                } else {
                  // Vertical wall
                  if (
                    intPoint.y >= Math.min(wall.y1, wall.y2) &&
                    intPoint.y <= Math.max(wall.y1, wall.y2)
                  ) {
                    endPoint = intPoint;
                  }
                }
              }
            });

            // Draw the trimmed wall
            const { cx: cx1, cy: cy1 } = frameWorldToCanvas(
              startPoint.x,
              startPoint.y
            );
            const { cx: cx2, cy: cy2 } = frameWorldToCanvas(
              endPoint.x,
              endPoint.y
            );

            ctx.strokeStyle = "#000";
            ctx.lineWidth = 4;
            ctx.lineCap = "butt";
            ctx.beginPath();
            ctx.moveTo(cx1, cy1);
            ctx.lineTo(cx2, cy2);
            ctx.stroke();
          }
        });

        // Draw small squares at intersection points for better corner visualization
        intersections.forEach((intersection) => {
          const { cx, cy } = frameWorldToCanvas(
            intersection.x,
            intersection.y
          );

          ctx.fillStyle = "#000";
          ctx.fillRect(cx - 2, cy - 2, 4, 4);
        });

        ctx.restore();
      }

      // Helper function to find intersection between two walls
      function findWallIntersection(wall1, wall2) {
        const { x1: x1a, y1: y1a, x2: x2a, y2: y2a } = wall1;
        const { x1: x1b, y1: y1b, x2: x2b, y2: y2b } = wall2;

        // Check if wall1 is horizontal and wall2 is vertical
        if (y1a === y2a && x1b === x2b) {
          const wallY = y1a;
          const wallX = x1b;

          // Check if intersection point is within both wall segments
          if (
            wallX >= Math.min(x1a, x2a) &&
            wallX <= Math.max(x1a, x2a) &&
            wallY >= Math.min(y1b, y2b) &&
            wallY <= Math.max(y1b, y2b)
          ) {
            return { x: wallX, y: wallY };
          }
        }

        // Check if wall1 is vertical and wall2 is horizontal
        if (x1a === x2a && y1b === y2b) {
          const wallX = x1a;
          const wallY = y1b;

          // Check if intersection point is within both wall segments
          if (
            wallX >= Math.min(x1b, x2b) &&
            wallX <= Math.max(x1b, x2b) &&
            wallY >= Math.min(y1a, y2a) &&
            wallY <= Math.max(y1a, y2a)
          ) {
            return { x: wallX, y: wallY };
          }
        }

        return null;
      }

      // --- Core Frame Rendering and Updating ---
      function redrawFrame(configId) {
        const frameData = frameElements[configId];
        const config = activeSimulationConfigs.find((c) => c.id === configId);
        if (!frameData || !config) return;

        const boundaries = config.boundaries || {
          xmin: -6,
          xmax: 6,
          ymin: -6,
          ymax: 6,
        };
        const rotation = config.rotation || 0;

        // Redraw each canvas for the frame
        frameData.canvases.forEach((canvas, gridIndex) => {
          const ctx = canvas.getContext("2d");
          const robots = config.grids[gridIndex] || [];
          const gridWaypoints =
            (config.gridWaypoints && config.gridWaypoints[gridIndex]) || [];
          const gridExclusivePoints =
            (config.gridExclusivePoints &&
              config.gridExclusivePoints[gridIndex]) ||
            [];

          drawGridLines(ctx);
          drawBoundaries(ctx, boundaries, rotation);
          drawWaypoints(ctx, gridWaypoints, boundaries, rotation);
          drawExclusivePoints(ctx, gridExclusivePoints, boundaries, rotation);
          drawWalls(ctx, config.walls || [], boundaries, rotation);
          drawRobots(ctx, robots, boundaries, rotation);
        });

        // Update boundary info text
        const boundsInfo = frameData.frameDiv.querySelector(".boundary-info");
        if (boundsInfo) {
          boundsInfo.querySelector("span.xmin").textContent = boundaries.xmin;
          boundsInfo.querySelector("span.xmax").textContent = boundaries.xmax;
          boundsInfo.querySelector("span.ymin").textContent = boundaries.ymin;
          boundsInfo.querySelector("span.ymax").textContent = boundaries.ymax;
        }
        if (frameData.stepsInput) {
          frameData.stepsInput.value = config.steps;
        }
        config.needsRedraw = false;
      }

      function createFrameElement(configData, index) {
        const frameDiv = document.createElement("div");
        frameDiv.className = "simulation-frame";
        frameDiv.dataset.configId = configData.id;
        frameDiv.draggable = true;

        // --- Header ---
        const headerDiv = document.createElement("div");
        headerDiv.className = "frame-header";
        const dragHandle = document.createElement("div");
        dragHandle.className = "drag-handle";
        dragHandle.title = "Drag to reorder frames";
        const title = document.createElement("h4");

        // Calculate total steps for the title
        let totalSteps = 0;
        if (configData.gridSteps && configData.gridSteps.length > 1) {
          totalSteps = configData.gridSteps
            .slice(1)
            .reduce((sum, steps) => sum + steps, 0);
        } else if (configData.steps) {
          totalSteps = configData.steps;
        }

        // Add title text (normal color)
        title.textContent = `Simulation ${index + 1
          } (Total Steps: ${totalSteps})`;

        const rotateBtn = document.createElement("button");
        rotateBtn.className = "btn btn-light btn-sm rotate-btn";
        rotateBtn.title = "Rotate frame 90Â°";
        rotateBtn.innerHTML = `<svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24">
            <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
        </svg>`;
        rotateBtn.onclick = () => rotateFrame(configData.id);
        const closeBtn = document.createElement("button");
        closeBtn.className = "close-frame-btn";
        closeBtn.innerHTML = `<svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24">
            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
        </svg>`;
        closeBtn.title = "Close this simulation frame";
        closeBtn.onclick = () => closeFrame(configData.id);

        // Disable close button if not in edit mode
        if (!canEdit) {
          closeBtn.disabled = true;
          closeBtn.style.opacity = '0.5';
          closeBtn.style.cursor = 'not-allowed';
          closeBtn.title = 'Edit mode required';
        }
        headerDiv.append(dragHandle, title, rotateBtn, closeBtn);
        frameDiv.appendChild(headerDiv);

        // --- Grids Wrapper ---
        const gridsWrapper = document.createElement("div");
        gridsWrapper.className = "grids-wrapper";
        frameDiv.appendChild(gridsWrapper);

        // --- Canvas Creation ---
        const boundaries = configData.boundaries || {
          xmin: -6,
          xmax: 6,
          ymin: -6,
          ymax: 6,
        };
        const canvases = [];

        (configData.grids || []).forEach((grid, gridIndex) => {
          const container = document.createElement("div");
          container.className = "frame-canvas-container";
          container.dataset.gridIndex = gridIndex;
          container.dataset.configId = configData.id;

          // Create title with proper naming
          const titleDiv = document.createElement("h5");
          if (gridIndex === 0) {
            titleDiv.textContent = "Starting Position";
          } else {
            titleDiv.textContent = `Target ${gridIndex}`;
          }
          container.appendChild(titleDiv);

          // Add delete button (only show for target grids, not starting position, and only if more than 2 total grids)
          if (gridIndex > 0 && configData.grids.length > 2) {
            const deleteBtn = document.createElement("button");
            deleteBtn.className = "grid-delete-btn";
            deleteBtn.innerHTML = "Ã—";
            deleteBtn.title = "Delete this grid";
            deleteBtn.onclick = (e) => {
              e.stopPropagation();
              deleteGrid(configData.id, gridIndex);
            };
            container.appendChild(deleteBtn);
          }
          const canvas = document.createElement("canvas");
          canvas.id = `canvas-${configData.id}-${gridIndex}`;
          canvas.width = FRAME_CANVAS_SIZE;
          canvas.height = FRAME_CANVAS_SIZE;
          canvas.dataset.gridIndex = gridIndex; // Store index
          container.appendChild(canvas);
          canvases.push(canvas);

          // Add boundary info only to the first canvas
          if (gridIndex === 0) {
            const boundsInfo = document.createElement("div");
            boundsInfo.className = "boundary-info";
            boundsInfo.innerHTML = `Bounds: x:[<span class="xmin">${boundaries.xmin}</span>,<span class="xmax">${boundaries.xmax}</span>] y:[<span class="ymin">${boundaries.ymin}</span>,<span class="ymax">${boundaries.ymax}</span>]`;
            container.appendChild(boundsInfo);
          } else {
            // Add step control for non-starting grids (positioned like boundary info)
            const stepsContainer = document.createElement("div");
            stepsContainer.className = "grid-steps-control";
            stepsContainer.style.cssText = `
              font-family: monospace;
              font-size: 0.8em;
              color: #5f6b7a;
              margin-top: 5px;
              text-align: center;
              display: flex;
              align-items: center;
              justify-content: center;
              gap: 5px;
            `;

            const stepsLabel = document.createElement("label");
            stepsLabel.textContent = "Steps:";
            stepsLabel.style.cssText = "margin: 0; font-weight: 500;";

            const stepsInput = document.createElement("input");
            stepsInput.type = "number";
            stepsInput.min = "0";
            stepsInput.value =
              (configData.gridSteps && configData.gridSteps[gridIndex]) || 5;
            stepsInput.style.cssText = `
              width: 50px;
              padding: 2px 4px;
              border: 1px solid #ccc;
              border-radius: 3px;
              font-size: 0.8em;
              font-family: monospace;
            `;
            // Simulation goal steps should be editable when canEdit is true
            if (!canEdit) {
              stepsInput.disabled = true;
              stepsInput.style.opacity = "0.5";
              stepsInput.style.cursor = "not-allowed";
            }
            stepsInput.addEventListener("change", (e) => {
              updateGridSteps(
                configData.id,
                gridIndex,
                parseInt(e.target.value) || 0
              );
            });

            stepsContainer.appendChild(stepsLabel);
            stepsContainer.appendChild(stepsInput);
            container.appendChild(stepsContainer);
          }
          gridsWrapper.appendChild(container);
          canvas.addEventListener("mousedown", handleCanvasMouseDown);
        });

        // --- Add Grid Button ---
        const addGridContainer = document.createElement("div");
        addGridContainer.className = "add-grid-btn-container";
        const addGridBtn = document.createElement("button");
        addGridBtn.className = "add-grid-btn";
        addGridBtn.innerHTML = `<svg width="24" height="24" fill="currentColor" viewBox="0 0 24 24">
            <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
        </svg>`;
        addGridBtn.title = "Add new grid";
        addGridBtn.onclick = () => addNewGrid(configData.id);
        if (!canEdit) {
          addGridBtn.disabled = true;
          addGridBtn.style.opacity = "0.5";
          addGridBtn.style.cursor = "not-allowed";
        }
        addGridContainer.appendChild(addGridBtn);
        gridsWrapper.appendChild(addGridContainer);

        // --- Store References ---
        frameElements[configData.id] = {
          frameDiv,
          canvases,
          titleElement: title,
        };

        // --- Attach Frame Drag Listeners ---
        frameDiv.addEventListener("mousedown", (e) => {
          const handle = e.target.closest(".drag-handle");
          frameDiv.dataset.dragReady = handle ? "true" : "false";
        });
        frameDiv.addEventListener("dragstart", handleFrameDragStart);
        frameDiv.addEventListener("dragend", handleFrameDragEnd);

        return frameDiv;
      }

      function renderAllFrames() {
        const palette = simulatorColumn.querySelector(".robot-palette");
        if (!palette) return;

        // Store scroll positions of grids wrappers before re-rendering
        const scrollPositions = {};
        const existingFrames =
          simulatorColumn.querySelectorAll(".simulation-frame");
        existingFrames.forEach((frame) => {
          const configId = frame.dataset.configId;
          const gridsWrapper = frame.querySelector(".grids-wrapper");
          if (gridsWrapper && configId) {
            scrollPositions[configId] = gridsWrapper.scrollLeft;
          }
        });

        // Clear existing frames
        const framesToRemove =
          simulatorColumn.querySelectorAll(".simulation-frame");
        framesToRemove.forEach((frame) => simulatorColumn.removeChild(frame));
        frameElements = {};

        // Create and append frames
        activeSimulationConfigs.forEach((config, index) => {
          const frameDiv = createFrameElement(config, index);
          simulatorColumn.appendChild(frameDiv);
          redrawFrame(config.id);

          // Restore scroll position for this frame's grids wrapper
          if (scrollPositions[config.id] !== undefined) {
            const gridsWrapper = frameDiv.querySelector(".grids-wrapper");
            if (gridsWrapper) {
              // Use setTimeout to ensure DOM is fully rendered before setting scroll
              setTimeout(() => {
                gridsWrapper.scrollLeft = scrollPositions[config.id];
              }, 0);
            }
          }
        });

        updateFullConfigTextArea();
        saveConfigsToLocalStorage();
      }

      function addNewGrid(configId) {
        if (!canEdit) return;
        const config = activeSimulationConfigs.find(
          (cfg) => cfg.id === configId
        );
        if (config) {
          if (!config.grids) {
            config.grids = [];
          }
          config.grids.push([]); // Add a new empty grid

          // Initialize or extend gridSteps array
          if (!config.gridSteps) {
            config.gridSteps = Array(config.grids.length).fill(0);
            config.gridSteps[1] = 5; // Default for first target
          } else {
            config.gridSteps.push(5); // Default step count for new grid
          }

          // Update total steps
          const totalSteps = config.gridSteps
            .slice(1)
            .reduce((sum, steps) => sum + steps, 0);
          config.steps = totalSteps;

          // Instead of full re-render, just update this specific frame
          updateSingleFrame(configId);
        }
      }

      function deleteGrid(configId, gridIndex) {
        const config = activeSimulationConfigs.find(
          (cfg) => cfg.id === configId
        );
        if (
          config &&
          config.grids &&
          config.grids.length > 2 &&
          gridIndex > 0
        ) {
          // Remove the grid at the specified index
          config.grids.splice(gridIndex, 1);

          // Also remove corresponding gridSteps entry
          if (config.gridSteps && config.gridSteps.length > gridIndex) {
            config.gridSteps.splice(gridIndex, 1);
          }

          // Remove corresponding gridWaypoints entry
          if (
            config.gridWaypoints &&
            config.gridWaypoints.length > gridIndex
          ) {
            config.gridWaypoints.splice(gridIndex, 1);
          }

          // Remove corresponding gridExclusivePoints entry
          if (
            config.gridExclusivePoints &&
            config.gridExclusivePoints.length > gridIndex
          ) {
            config.gridExclusivePoints.splice(gridIndex, 1);
          }

          // Update total steps
          if (config.gridSteps) {
            const totalSteps = config.gridSteps
              .slice(1)
              .reduce((sum, steps) => sum + steps, 0);
            config.steps = totalSteps;
          }

          // Update this specific frame
          updateSingleFrame(configId);
        }
      }

      function updateSingleFrame(configId) {
        const config = activeSimulationConfigs.find(
          (cfg) => cfg.id === configId
        );
        const frameData = frameElements[configId];
        if (!config || !frameData) return;

        // Store current scroll position
        const gridsWrapper =
          frameData.frameDiv.querySelector(".grids-wrapper");
        const currentScrollLeft = gridsWrapper ? gridsWrapper.scrollLeft : 0;

        // Get the grids wrapper to update
        if (gridsWrapper) {
          // Clear existing canvas containers (but keep the add button)
          const existingContainers = gridsWrapper.querySelectorAll(
            ".frame-canvas-container"
          );
          existingContainers.forEach((container) => container.remove());

          // Re-create canvas containers for all grids
          const boundaries = config.boundaries || {
            xmin: -6,
            xmax: 6,
            ymin: -6,
            ymax: 6,
          };
          const newCanvases = [];

          config.grids.forEach((grid, gridIndex) => {
            const container = document.createElement("div");
            container.className = "frame-canvas-container";
            container.dataset.gridIndex = gridIndex;
            container.dataset.configId = config.id;

            // Create title with proper naming
            const titleDiv = document.createElement("h5");
            if (gridIndex === 0) {
              titleDiv.textContent = "Starting Position";
            } else {
              titleDiv.textContent = `Target ${gridIndex}`;
            }
            container.appendChild(titleDiv);

            // Add delete button (only show for target grids, not starting position, and only if more than 2 total grids)
            if (gridIndex > 0 && config.grids.length > 2) {
              const deleteBtn = document.createElement("button");
              deleteBtn.className = "grid-delete-btn";
              deleteBtn.innerHTML = "Ã—";
              deleteBtn.title = "Delete this grid";
              deleteBtn.onclick = (e) => {
                e.stopPropagation();
                deleteGrid(config.id, gridIndex);
              };
              container.appendChild(deleteBtn);
            }
            const canvas = document.createElement("canvas");
            canvas.id = `canvas-${config.id}-${gridIndex}`;
            canvas.width = FRAME_CANVAS_SIZE;
            canvas.height = FRAME_CANVAS_SIZE;
            canvas.dataset.gridIndex = gridIndex;
            container.appendChild(canvas);
            newCanvases.push(canvas);

            // Add boundary info only to the first canvas
            if (gridIndex === 0) {
              const boundsInfo = document.createElement("div");
              boundsInfo.className = "boundary-info";
              boundsInfo.style.cssText = `
                font-family: monospace;
                font-size: 0.8em;
                color: #5f6b7a;
                margin-top: 5px;
                text-align: center;
              `;
              boundsInfo.innerHTML = `Bounds: x:[<span class="xmin">${boundaries.xmin}</span>,<span class="xmax">${boundaries.xmax}</span>] y:[<span class="ymin">${boundaries.ymin}</span>,<span class="ymax">${boundaries.ymax}</span>]`;
              container.appendChild(boundsInfo);
            } else {
              // Add step control for non-starting grids (positioned like boundary info)
              const stepsContainer = document.createElement("div");
              stepsContainer.className = "grid-steps-control";
              stepsContainer.style.cssText = `
                font-family: monospace;
                font-size: 0.8em;
                color: #5f6b7a;
                margin-top: 5px;
                text-align: center;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 5px;
              `;

              const stepsLabel = document.createElement("label");
              stepsLabel.textContent = "Steps:";
              stepsLabel.style.cssText = "margin: 0; font-weight: 500;";

              const stepsInput = document.createElement("input");
              stepsInput.type = "number";
              stepsInput.min = "0";
              stepsInput.value =
                (config.gridSteps && config.gridSteps[gridIndex]) || 5;
              stepsInput.style.cssText = `
                width: 50px;
                padding: 2px 4px;
                border: 1px solid #ccc;
                border-radius: 3px;
                font-size: 0.8em;
                font-family: monospace;
              `;
              // Simulation goal steps should be editable when canEdit is true
              if (!canEdit) {
                stepsInput.disabled = true;
                stepsInput.style.opacity = "0.5";
                stepsInput.style.cursor = "not-allowed";
              }
              stepsInput.addEventListener("change", (e) => {
                updateGridSteps(
                  config.id,
                  gridIndex,
                  parseInt(e.target.value) || 0
                );
              });

              stepsContainer.appendChild(stepsLabel);
              stepsContainer.appendChild(stepsInput);
              container.appendChild(stepsContainer);
            }

            // Insert before the add button
            const addGridContainer = gridsWrapper.querySelector(
              ".add-grid-btn-container"
            );
            gridsWrapper.insertBefore(container, addGridContainer);
            canvas.addEventListener("mousedown", handleCanvasMouseDown);
          });

          // Update stored canvas references
          frameData.canvases = newCanvases;

          // Redraw all canvases for this frame
          redrawFrame(configId);

          // Restore scroll position immediately
          gridsWrapper.scrollLeft = currentScrollLeft;
        }

        // Update the text area and save
        updateFullConfigTextArea();
        saveConfigsToLocalStorage();
      }

      function closeFrame(configId) {
        activeSimulationConfigs = activeSimulationConfigs.filter(
          (cfg) => cfg.id !== configId
        );
        delete frameElements[configId];
        renderAllFrames();
      }

      function updateSteps(configId, newValue) {
        const config = activeSimulationConfigs.find(
          (cfg) => cfg.id === configId
        );
        if (config) {
          config.steps = Math.max(0, newValue);
          if (frameElements[configId]?.stepsInput) {
            frameElements[configId].stepsInput.value = config.steps;
          }
          updateFullConfigTextArea();
        }
      }

      function updateGridSteps(configId, gridIndex, newValue) {
        const config = activeSimulationConfigs.find(
          (cfg) => cfg.id === configId
        );
        if (config) {
          // Initialize gridSteps if it doesn't exist
          if (!config.gridSteps) {
            config.gridSteps = Array(config.grids.length).fill(0);
            config.gridSteps[1] = 5; // Default for first target
          }

          // Update the specific grid's steps
          config.gridSteps[gridIndex] = Math.max(0, newValue);

          // Calculate total steps (sum of all grid steps except starting position)
          const totalSteps = config.gridSteps
            .slice(1)
            .reduce((sum, steps) => sum + steps, 0);
          config.steps = totalSteps;

          // Update frame title to show total steps
          updateFrameTitle(configId);

          updateFullConfigTextArea();
          saveConfigsToLocalStorage();
        }
      }

      function updateFrameTitle(configId) {
        const config = activeSimulationConfigs.find(
          (cfg) => cfg.id === configId
        );
        if (config && frameElements[configId]?.titleElement) {
          const frameIndex =
            activeSimulationConfigs.findIndex((cfg) => cfg.id === configId) +
            1;
          const totalSteps = config.steps || 0;

          // Update title text
          frameElements[configId].titleElement.textContent = `Simulation ${frameIndex} (Total Steps: ${totalSteps})`;
        }
      }

      // --- Editor Display (Shows Full List, Read-Only) ---
      function updateFullConfigTextArea() {
        if (!simulationConfigListTextArea) return;
        if (activeSimulationConfigs.length === 0) {
          simulationConfigListTextArea.value = JSON.stringify(
            {
              simulation_configs: [],
            },
            null,
            2
          );
          return;
        }

        try {
          // Generate JSON format (existing logic)
          const simulationConfigs = activeSimulationConfigs.map((config) => {
            const boundaries = config.boundaries || {
              xmin: -6,
              xmax: 6,
              ymin: -6,
              ymax: 6,
            };
            const grids = config.grids || [];
            const gridSteps = config.gridSteps || [];
            const gridWaypoints = config.gridWaypoints || [];
            const gridExclusivePoints = config.gridExclusivePoints || [];
            const walls = config.walls || [];

            // Find vertical and horizontal walls
            let verticalWall = null,
              horizontalWall = null;
            walls.forEach((wall) => {
              if (wall.type === "vertical") {
                verticalWall = wall.x1; // x position of vertical wall
              } else if (wall.type === "horizontal") {
                horizontalWall = wall.y1; // y position of horizontal wall
              }
            });

            // Format grids: starting grid as initial_positions, targets with steps, exclusive points, and waypoints
            let initialPositions = [];
            let targets = [];

            if (grids.length > 0) {
              // Starting position (first grid)
              initialPositions = grids[0].map(([color, x, y]) => [
                color,
                x,
                y,
              ]);

              // Target grids with steps, exclusive points, and waypoints (remaining grids)
              for (let i = 1; i < grids.length; i++) {
                const steps = (gridSteps && gridSteps[i]) || 5;
                const robots = grids[i].map(([color, x, y]) => [color, x, y]);
                const exclusivePoints = (gridExclusivePoints[i] || []).map(
                  ([x, y]) => [x, y]
                );
                const waypoints = (gridWaypoints[i] || []).map(([x, y]) => [
                  x,
                  y,
                ]);
                targets.push([steps, robots, exclusivePoints, waypoints]);
              }
            }

            return {
              initial_positions: initialPositions,
              targets: targets,
              boundary: [
                boundaries.xmin,
                boundaries.xmax,
                boundaries.ymin,
                boundaries.ymax,
              ],
              wall: [verticalWall, horizontalWall],
              // is_essential removed - not needed in output
            };
          });

          const fullConfig = {
            simulation_configs: simulationConfigs,
          };

          // Custom JSON stringify to keep position arrays on single lines
          const customStringify = (obj, indent = 0) => {
            const spaces = "  ".repeat(indent);

            if (Array.isArray(obj)) {
              // Check if this is a position array (contains [color, x, y] tuples)
              const isPositionArray =
                obj.length > 0 &&
                obj.every(
                  (item) =>
                    Array.isArray(item) &&
                    item.length === 3 &&
                    typeof item[0] === "string" &&
                    typeof item[1] === "number" &&
                    typeof item[2] === "number"
                );

              // Check if this is a boundary array (4 numbers)
              const isBoundaryArray =
                obj.length === 4 &&
                obj.every((item) => typeof item === "number");

              // Check if this is a wall array (2 values, can be null or number)
              const isWallArray =
                obj.length === 2 &&
                obj.every(
                  (item) => item === null || typeof item === "number"
                );

              if (isPositionArray) {
                // Format position arrays on single line
                return (
                  "[" +
                  obj
                    .map(
                      (pos) =>
                        `[${JSON.stringify(pos[0])}, ${pos[1]}, ${pos[2]}]`
                    )
                    .join(", ") +
                  "]"
                );
              } else if (isBoundaryArray || isWallArray) {
                // Format boundary and wall arrays on single line
                return (
                  "[" +
                  obj
                    .map((item) => (item === null ? "null" : item))
                    .join(", ") +
                  "]"
                );
              } else {
                // Check if this is a targets array with position sub-arrays
                const isTargetsArray =
                  obj.length > 0 &&
                  obj.every(
                    (item) =>
                      Array.isArray(item) &&
                      item.length >= 2 &&
                      Array.isArray(item[1])
                  );

                if (isTargetsArray) {
                  // Format targets array with proper indentation but keep position sub-arrays on single lines
                  const items = obj.map((target) => {
                    const [steps, robots, exclusive, waypoints] = target;
                    const robotsStr = Array.isArray(robots)
                      ? "[" +
                      robots
                        .map(
                          (pos) =>
                            `[${JSON.stringify(pos[0])}, ${pos[1]}, ${pos[2]
                            }]`
                        )
                        .join(", ") +
                      "]"
                      : JSON.stringify(robots);
                    const exclusiveStr = Array.isArray(exclusive)
                      ? "[" +
                      exclusive
                        .map((pos) => `[${pos[0]}, ${pos[1]}]`)
                        .join(", ") +
                      "]"
                      : JSON.stringify(exclusive);
                    const waypointsStr = Array.isArray(waypoints)
                      ? "[" +
                      waypoints
                        .map((pos) => `[${pos[0]}, ${pos[1]}]`)
                        .join(", ") +
                      "]"
                      : JSON.stringify(waypoints);

                    return `${spaces}  [${steps}, ${robotsStr}, ${exclusiveStr}, ${waypointsStr}]`;
                  });
                  return "[\n" + items.join(",\n") + `\n${spaces}]`;
                } else {
                  // Regular array formatting
                  const items = obj.map((item) =>
                    customStringify(item, indent)
                  );
                  return (
                    "[\n" +
                    items.map((item) => spaces + "  " + item).join(",\n") +
                    `\n${spaces}]`
                  );
                }
              }
            } else if (typeof obj === "object" && obj !== null) {
              const entries = Object.entries(obj);
              const items = entries.map(([key, value]) => {
                const formattedValue = customStringify(value, indent + 1);
                return `${spaces}  "${key}": ${formattedValue}`;
              });
              return "{\n" + items.join(",\n") + `\n${spaces}}`;
            } else {
              return JSON.stringify(obj);
            }
          };

          simulationConfigListTextArea.value = customStringify(fullConfig);
        } catch (error) {
          console.error("Error formatting config for text area:", error);
          simulationConfigListTextArea.value = JSON.stringify(
            {
              error: "Error generating configuration JSON.",
            },
            null,
            2
          );
        }
      }

      // --- Rotation Helper Functions ---
      function rotate_point(x, y, angle) {
        // angle: 0, 90, 180, 270
        switch (angle) {
          case 0:
            return [x, y];
          case 90:
            return [y, -x];
          case 180:
            return [-x, -y];
          case 270:
            return [-y, x];
          default:
            return [x, y];
        }
      }

      function nextAngle(angle) {
        // 0 -> 90 -> 180 -> 270 -> 0
        return (angle + 90) % 360;
      }

      function rotateFrame(configId) {
        const config = activeSimulationConfigs.find(
          (cfg) => cfg.id === configId
        );
        if (!config) return;

        const oldRotation = config.rotation || 0;
        const newRotation = nextAngle(oldRotation);
        const rotationDelta = newRotation - oldRotation;

        // Transform ALL coordinate data
        if (config.grids) {
          config.grids.forEach((grid) => {
            for (let i = 0; i < grid.length; i++) {
              const [color, x, y] = grid[i];
              const [newX, newY] = rotate_point(x, y, rotationDelta);
              grid[i] = [color, newX, newY];
            }
          });
        }

        // Transform waypoints if they exist (per-grid format)
        if (config.gridWaypoints) {
          config.gridWaypoints.forEach((waypoints, gridIndex) => {
            if (waypoints && waypoints.length > 0) {
              config.gridWaypoints[gridIndex] = waypoints.map((waypoint) => {
                if (waypoint.length === 2) {
                  // Old format [x, y]
                  const [x, y] = waypoint;
                  const [newX, newY] = rotate_point(x, y, rotationDelta);
                  return [newX, newY];
                } else if (waypoint.length === 4) {
                  // New format [symbol, x, y, direction]
                  const [symbol, x, y, direction] = waypoint;
                  const [newX, newY] = rotate_point(x, y, rotationDelta);
                  const newDirection = (direction + rotationDelta) % 360;
                  return [symbol, newX, newY, newDirection];
                }
                return waypoint;
              });
            }
          });
        }

        // Transform exclusive points if they exist (per-grid format)
        if (config.gridExclusivePoints) {
          config.gridExclusivePoints.forEach((exclusivePoints, gridIndex) => {
            if (exclusivePoints && exclusivePoints.length > 0) {
              config.gridExclusivePoints[gridIndex] = exclusivePoints.map(
                (exclusivePoint) => {
                  if (exclusivePoint.length === 2) {
                    // Old format [x, y]
                    const [x, y] = exclusivePoint;
                    const [newX, newY] = rotate_point(x, y, rotationDelta);
                    return [newX, newY];
                  } else if (exclusivePoint.length === 4) {
                    // New format [symbol, x, y, direction]
                    const [symbol, x, y, direction] = exclusivePoint;
                    const [newX, newY] = rotate_point(x, y, rotationDelta);
                    const newDirection = (direction + rotationDelta) % 360;
                    return [symbol, newX, newY, newDirection];
                  }
                  return exclusivePoint;
                }
              );
            }
          });
        }

        // Transform waypoints if they exist (legacy format)
        if (config.waypoints) {
          config.waypoints = config.waypoints.map(([x, y]) => {
            const [newX, newY] = rotate_point(x, y, rotationDelta);
            return [newX, newY];
          });
        }

        // Transform exclusive points if they exist (legacy format)
        if (config.exclusive_points) {
          config.exclusive_points = config.exclusive_points.map(([x, y]) => {
            const [newX, newY] = rotate_point(x, y, rotationDelta);
            return [newX, newY];
          });
        }

        // Transform walls if they exist
        if (config.walls) {
          config.walls = config.walls.map((wall) => {
            const [newX1, newY1] = rotate_point(
              wall.x1,
              wall.y1,
              rotationDelta
            );
            const [newX2, newY2] = rotate_point(
              wall.x2,
              wall.y2,
              rotationDelta
            );

            // Determine new wall type based on rotation
            const isHorizontal =
              Math.abs(newX2 - newX1) > Math.abs(newY2 - newY1);

            return {
              type: isHorizontal ? "horizontal" : "vertical",
              x1: newX1,
              y1: newY1,
              x2: newX2,
              y2: newY2,
            };
          });
        }

        // Transform boundaries
        if (config.boundaries) {
          const { xmin, xmax, ymin, ymax } = config.boundaries;

          // Get all four corners
          const corners = [
            [xmin, ymin],
            [xmax, ymin],
            [xmax, ymax],
            [xmin, ymax],
          ];

          // Rotate all corners
          const rotatedCorners = corners.map(([x, y]) =>
            rotate_point(x, y, rotationDelta)
          );

          // Find new boundaries
          const allX = rotatedCorners.map(([x, y]) => x);
          const allY = rotatedCorners.map(([x, y]) => y);

          config.boundaries = {
            xmin: Math.min(...allX),
            xmax: Math.max(...allX),
            ymin: Math.min(...allY),
            ymax: Math.max(...allY),
          };
        }

        // Reset rotation to 0 since coordinates are transformed
        config.rotation = 0;

        // Redraw the frame - use renderAllFrames to ensure frameElements are properly set up
        renderAllFrames();
        updateFullConfigTextArea();
        saveConfigsToLocalStorage();
      }

      // --- Drag Event Handlers (Robot/Boundary) ---
      function getFrameConfigFromElement(element) {
        const frameDiv = element.closest(".simulation-frame");
        if (!frameDiv) return null;
        const configId = frameDiv.dataset.configId;
        return activeSimulationConfigs.find((cfg) => cfg.id === configId);
      }

      function handlePaletteDragStart(e) {
        if (!canEdit) {
          e.preventDefault();
          return;
        }
        const paletteElement = e.target.closest(
          ".palette-robot, .palette-waypoint, .palette-exclusive-point, .palette-wall-horizontal, .palette-wall-vertical"
        );
        if (!paletteElement) return;

        currentPaletteDragSource = paletteElement;
        const color = paletteElement.dataset.color;
        const type = paletteElement.dataset.type;

        if (color) {
          // Robot drag
          draggedItem = "robot";
          draggedRobotData = [color, 0, 0];
          isNewRobotFromPalette = true;
          sourceCanvasElement = null;
          sourceConfigId = null;
          sourceGridIndex = -1;
          sourceRobotsListRef = null;
          draggedRobotIndex = -1;

          dragGhost.style.backgroundColor = simConfig.colors[color] || "gray";
          dragGhost.style.display = "block";
          dragGhost.style.left = `${e.clientX}px`;
          dragGhost.style.top = `${e.clientY}px`;
          dragGhost.style.width = `${simConfig.robotRadius * 2}px`;
          dragGhost.style.height = `${simConfig.robotRadius * 2}px`;
          dragGhost.style.borderRadius = "50%";
          dragGhost.style.transform = "translate(-50%, -50%)";
        } else if (type === "waypoint") {
          // Waypoint drag
          draggedItem = "waypoint";
          draggedWaypointData = [0, 0];
          isNewWaypointFromPalette = true;
          sourceCanvasElement = null;
          sourceConfigId = null;

          dragGhost.style.backgroundColor = simConfig.waypointColor;
          dragGhost.style.display = "block";
          dragGhost.style.left = `${e.clientX}px`;
          dragGhost.style.top = `${e.clientY}px`;
          dragGhost.style.width = `${simConfig.waypointRadius * 2}px`;
          dragGhost.style.height = `${simConfig.waypointRadius * 2}px`;
          dragGhost.style.borderRadius = "50%";
          dragGhost.style.transform = "translate(-50%, -50%)";
        } else if (type === "exclusive_point") {
          // Exclusive point drag
          draggedItem = "exclusive_point";
          draggedExclusivePointData = [0, 0];
          isNewExclusivePointFromPalette = true;
          sourceCanvasElement = null;
          sourceConfigId = null;

          dragGhost.style.backgroundColor = simConfig.exclusivePointColor;
          dragGhost.style.display = "block";
          dragGhost.style.left = `${e.clientX}px`;
          dragGhost.style.top = `${e.clientY}px`;
          dragGhost.style.width = `${simConfig.exclusivePointRadius * 2}px`;
          dragGhost.style.height = `${simConfig.exclusivePointRadius * 2}px`;
          dragGhost.style.borderRadius = "50%";
          dragGhost.style.transform = "translate(-50%, -50%)";
        } else if (type === "wall_horizontal") {
          // Horizontal wall drag
          draggedItem = "wall_horizontal";
          draggedWallData = {
            type: "horizontal",
            x1: 0,
            y1: 0,
            x2: 1,
            y2: 0,
          };
          isNewWallFromPalette = true;
          sourceCanvasElement = null;
          sourceConfigId = null;

          dragGhost.style.backgroundColor = "#000";
          dragGhost.style.display = "block";
          dragGhost.style.left = `${e.clientX}px`;
          dragGhost.style.top = `${e.clientY}px`;
          dragGhost.style.width = "30px";
          dragGhost.style.height = "4px";
          dragGhost.style.borderRadius = "2px";
          dragGhost.style.transform = "translate(-50%, -50%)";
        } else if (type === "wall_vertical") {
          // Vertical wall drag
          draggedItem = "wall_vertical";
          draggedWallData = { type: "vertical", x1: 0, y1: 0, x2: 0, y2: 1 };
          isNewWallFromPalette = true;
          sourceCanvasElement = null;
          sourceConfigId = null;

          dragGhost.style.backgroundColor = "#000";
          dragGhost.style.display = "block";
          dragGhost.style.left = `${e.clientX}px`;
          dragGhost.style.top = `${e.clientY}px`;
          dragGhost.style.width = "4px";
          dragGhost.style.height = "30px";
          dragGhost.style.borderRadius = "2px";
          dragGhost.style.transform = "translate(-50%, -50%)";
        }

        e.preventDefault();
        document.addEventListener("mousemove", handleDragMove);
        document.addEventListener("mouseup", handleDragEnd, { once: true });
      }

      function handleCanvasMouseDown(e) {
        if (!canEdit) return;
        const canvas = e.target;
        const config = getFrameConfigFromElement(canvas);
        if (!config) return;
        if (!config.boundaries) {
          config.boundaries = { xmin: -6, xmax: 6, ymin: -6, ymax: 6 };
          config.needsRedraw = true;
        }

        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const gridIndex = parseInt(canvas.dataset.gridIndex, 10);

        // Check for Boundary Drag
        const boundaryEdge = getBoundaryEdgeAtPosition(
          mouseX,
          mouseY,
          config.boundaries
        );
        if (boundaryEdge) {
          draggedItem = "boundary";
          draggedBoundaryEdge = boundaryEdge;
          sourceConfigId = config.id;
          sourceCanvasElement = canvas;
          boundaryGhost.style.display = "block";
          updateBoundaryGhostPosition(e.clientX, e.clientY, canvas, rect);
          document.addEventListener("mousemove", handleDragMove);
          document.addEventListener("mouseup", handleDragEnd, { once: true });
          return;
        }

        // Check for Waypoint Drag
        const gridWaypoints =
          (config.gridWaypoints && config.gridWaypoints[gridIndex]) || [];
        for (let i = gridWaypoints.length - 1; i >= 0; i--) {
          const [wX, wY] = gridWaypoints[i];
          const { cx: waypointCX, cy: waypointCY } = frameWorldToCanvas(
            wX,
            wY
          );
          const distance = Math.sqrt(
            (mouseX - waypointCX) ** 2 + (mouseY - waypointCY) ** 2
          );

          if (distance <= simConfig.waypointRadius + 2) {
            draggedItem = "waypoint";
            draggedWaypointData = [...gridWaypoints[i]];
            isNewWaypointFromPalette = false;
            sourceConfigId = config.id;
            sourceGridIndex = gridIndex;
            sourceCanvasElement = canvas;
            sourceWaypointsListRef = gridWaypoints;
            draggedWaypointIndex = i;

            dragGhost.style.backgroundColor = simConfig.waypointColor;
            dragGhost.style.display = "block";
            dragGhost.style.left = `${e.clientX}px`;
            dragGhost.style.top = `${e.clientY}px`;
            dragGhost.style.width = `${simConfig.waypointRadius * 2}px`;
            dragGhost.style.height = `${simConfig.waypointRadius * 2}px`;
            dragGhost.style.borderRadius = "50%";
            dragGhost.style.transform = "translate(-50%, -50%)";
            canvas.classList.add("dragging-source-canvas");

            // Remove waypoint from source grid
            gridWaypoints.splice(i, 1);
            redrawFrame(config.id);

            document.addEventListener("mousemove", handleDragMove);
            document.addEventListener("mouseup", handleDragEnd, {
              once: true,
            });
            return;
          }
        }

        // Check for Exclusive Point Drag
        const gridExclusivePoints =
          (config.gridExclusivePoints &&
            config.gridExclusivePoints[gridIndex]) ||
          [];
        for (let i = gridExclusivePoints.length - 1; i >= 0; i--) {
          const [eX, eY] = gridExclusivePoints[i];
          const { cx: exclusiveCX, cy: exclusiveCY } = frameWorldToCanvas(
            eX,
            eY
          );
          const distance = Math.sqrt(
            (mouseX - exclusiveCX) ** 2 + (mouseY - exclusiveCY) ** 2
          );

          if (distance <= simConfig.exclusivePointRadius + 2) {
            draggedItem = "exclusive_point";
            draggedExclusivePointData = [...gridExclusivePoints[i]];
            isNewExclusivePointFromPalette = false;
            sourceConfigId = config.id;
            sourceGridIndex = gridIndex;
            sourceCanvasElement = canvas;
            sourceExclusivePointsListRef = gridExclusivePoints;
            draggedExclusivePointIndex = i;

            dragGhost.style.backgroundColor = simConfig.exclusivePointColor;
            dragGhost.style.display = "block";
            dragGhost.style.left = `${e.clientX}px`;
            dragGhost.style.top = `${e.clientY}px`;
            dragGhost.style.width = `${simConfig.exclusivePointRadius * 2}px`;
            dragGhost.style.height = `${simConfig.exclusivePointRadius * 2
              }px`;
            dragGhost.style.borderRadius = "50%";
            dragGhost.style.transform = "translate(-50%, -50%)";
            canvas.classList.add("dragging-source-canvas");

            // Remove exclusive point from source grid
            gridExclusivePoints.splice(i, 1);
            redrawFrame(config.id);

            document.addEventListener("mousemove", handleDragMove);
            document.addEventListener("mouseup", handleDragEnd, {
              once: true,
            });
            return;
          }
        }

        // Check for Wall Drag
        const walls = config.walls || [];
        for (let i = walls.length - 1; i >= 0; i--) {
          const wall = walls[i];
          const { cx: cx1, cy: cy1 } = frameWorldToCanvas(wall.x1, wall.y1);
          const { cx: cx2, cy: cy2 } = frameWorldToCanvas(wall.x2, wall.y2);

          // Check if mouse is near the wall line
          const distanceToWall = distancePointToLine(
            mouseX,
            mouseY,
            cx1,
            cy1,
            cx2,
            cy2
          );

          if (distanceToWall <= 5) {
            // 5 pixel tolerance
            draggedItem =
              wall.type === "horizontal"
                ? "wall_horizontal"
                : "wall_vertical";
            draggedWallData = { ...wall };
            isNewWallFromPalette = false;
            sourceConfigId = config.id;
            sourceCanvasElement = canvas;

            dragGhost.style.backgroundColor = "#000";
            dragGhost.style.display = "block";
            dragGhost.style.left = `${e.clientX}px`;
            dragGhost.style.top = `${e.clientY}px`;
            dragGhost.style.width =
              wall.type === "horizontal" ? "30px" : "4px";
            dragGhost.style.height =
              wall.type === "horizontal" ? "4px" : "30px";
            dragGhost.style.borderRadius = "2px";
            dragGhost.style.transform = "translate(-50%, -50%)";
            canvas.classList.add("dragging-source-canvas");

            // Remove wall from source
            walls.splice(i, 1);
            redrawFrame(config.id);

            document.addEventListener("mousemove", handleDragMove);
            document.addEventListener("mouseup", handleDragEnd, {
              once: true,
            });
            return;
          }
        }

        // Check for Robot Drag
        const currentRobots = config.grids[gridIndex];
        if (!currentRobots) return;

        for (let i = currentRobots.length - 1; i >= 0; i--) {
          const [color, rX, rY] = currentRobots[i];
          const { cx: robotCX, cy: robotCY } = frameWorldToCanvas(rX, rY);
          const distance = Math.sqrt(
            (mouseX - robotCX) ** 2 + (mouseY - robotCY) ** 2
          );

          if (distance <= simConfig.robotRadius + 2) {
            draggedItem = "robot";
            draggedRobotData = [...currentRobots[i]];
            isNewRobotFromPalette = false;
            sourceConfigId = config.id;
            sourceGridIndex = gridIndex;
            sourceCanvasElement = canvas;
            sourceRobotsListRef = currentRobots;
            draggedRobotIndex = i;

            dragGhost.style.backgroundColor =
              simConfig.colors[draggedRobotData[0]] || "gray";
            dragGhost.style.display = "block";
            dragGhost.style.left = `${e.clientX}px`;
            dragGhost.style.top = `${e.clientY}px`;
            dragGhost.style.width = `${simConfig.robotRadius * 2}px`;
            dragGhost.style.height = `${simConfig.robotRadius * 2}px`;
            dragGhost.style.borderRadius = "50%";
            dragGhost.style.transform = "translate(-50%, -50%)";
            canvas.classList.add("dragging-source-canvas");
            document.addEventListener("mousemove", handleDragMove);
            document.addEventListener("mouseup", handleDragEnd, {
              once: true,
            });
            return;
          }
        }
      }

      function handleDragMove(e) {
        if (
          draggedItem !== "robot" &&
          draggedItem !== "boundary" &&
          draggedItem !== "waypoint" &&
          draggedItem !== "exclusive_point" &&
          draggedItem !== "wall_horizontal" &&
          draggedItem !== "wall_vertical"
        )
          return;
        const currentX = e.clientX;
        const currentY = e.clientY;

        if (
          draggedItem === "robot" ||
          draggedItem === "waypoint" ||
          draggedItem === "exclusive_point" ||
          draggedItem === "wall_horizontal" ||
          draggedItem === "wall_vertical"
        ) {
          dragGhost.style.left = `${currentX}px`;
          dragGhost.style.top = `${currentY}px`;
          dragGhost.style.transform = "translate(-50%, -50%)";
        } else if (draggedItem === "boundary") {
          const targetElement = document.elementFromPoint(currentX, currentY);
          const frameCanvas = targetElement?.closest(
            ".simulation-frame canvas"
          );
          if (frameCanvas) {
            const rect = frameCanvas.getBoundingClientRect();
            updateBoundaryGhostPosition(
              currentX,
              currentY,
              frameCanvas,
              rect
            );
          } else {
            boundaryGhost.style.display = "none";
          }
        }

        document
          .querySelectorAll(".simulation-frame canvas")
          .forEach((canvas) => {
            canvas.classList.remove("drop-target-canvas");
          });
        const targetElement = document.elementFromPoint(currentX, currentY);
        const targetCanvas = targetElement?.closest(
          ".simulation-frame canvas"
        );
        if (
          targetCanvas &&
          (targetCanvas !== sourceCanvasElement ||
            isNewRobotFromPalette ||
            isNewWaypointFromPalette ||
            isNewExclusivePointFromPalette ||
            isNewWallFromPalette ||
            draggedItem === "boundary")
        ) {
          targetCanvas.classList.add("drop-target-canvas");
        }
      }

      function animateGhostReturn() {
        if (!currentPaletteDragSource || !dragGhost) {
          dragGhost.style.display = "none";
          return;
        }

        const paletteRect = currentPaletteDragSource.getBoundingClientRect();
        const ghostRect = dragGhost.getBoundingClientRect();

        // Calculate target position (center of palette element)
        const targetX = paletteRect.left + paletteRect.width / 2;
        const targetY = paletteRect.top + paletteRect.height / 2;

        // Set initial position for animation (current ghost position)
        dragGhost.style.transition = "none"; // Disable transition temporarily
        dragGhost.style.left = `${ghostRect.left + ghostRect.width / 2}px`;
        dragGhost.style.top = `${ghostRect.top + ghostRect.height / 2}px`;
        dragGhost.style.transform = "translate(-50%, -50%)";
        dragGhost.style.display = "block"; // Ensure it's visible for animation

        // Force reflow to apply initial position without transition
        dragGhost.offsetWidth;

        // Apply transition and target position
        dragGhost.style.transition = "left 0.3s ease-out, top 0.3s ease-out, transform 0.3s ease-out";
        dragGhost.style.left = `${targetX}px`;
        dragGhost.style.top = `${targetY}px`;
        dragGhost.style.transform = "translate(-50%, -50%) scale(0.5)"; // Shrink slightly

        // Hide after animation
        dragGhost.addEventListener('transitionend', function handler() {
          dragGhost.style.display = 'none';
          dragGhost.style.transition = 'none'; // Reset transition
          dragGhost.style.transform = "translate(-50%, -50%)"; // Reset transform
          dragGhost.removeEventListener('transitionend', handler);
        }, { once: true });
      }

      function handleDragEnd(e) {
        if (
          draggedItem !== "robot" &&
          draggedItem !== "boundary" &&
          draggedItem !== "waypoint" &&
          draggedItem !== "exclusive_point" &&
          draggedItem !== "wall_horizontal" &&
          draggedItem !== "wall_vertical"
        )
          return;

        // Always remove mousemove listener
        document.removeEventListener("mousemove", handleDragMove);
        const currentX = e.clientX;
        const currentY = e.clientY;
        const targetElement = document.elementFromPoint(currentX, currentY);
        const targetCanvas = targetElement?.closest(".simulation-frame canvas");

        // Logic to determine if we should animate return to palette
        // We animate if:
        // 1. It's a new item from palette
        // 2. AND (no target canvas OR invalid drop condition)
        // Since handleRobotDrop etc. handle the logic, we can check if targetCanvas is null here.
        // If targetCanvas is NOT null, handleRobotDrop will determine if it's valid.
        // But we need to know BEFORE hiding the ghost.

        // Let's change the order. We will NOT hide ghost here if we might animate.

        let shouldAnimateReturn = false;
        let isFromPalette =
          isNewRobotFromPalette ||
          isNewWaypointFromPalette ||
          isNewExclusivePointFromPalette ||
          isNewWallFromPalette;

        if (isFromPalette && !targetCanvas) {
          shouldAnimateReturn = true;
        }

        // If we have a target canvas, we need to check if it's a valid drop location
        // This duplicates some logic from handleRobotDrop etc but is necessary for animation decision
        if (isFromPalette && targetCanvas) {
          const config = getFrameConfigFromElement(targetCanvas);
          if (config) {
            const rect = targetCanvas.getBoundingClientRect();
            const mouseX = currentX - rect.left;
            const mouseY = currentY - rect.top;
            const dropCoords = frameCanvasToWorld(mouseX, mouseY);
            const boundaries = config.boundaries || { xmin: -6, xmax: 6, ymin: -6, ymax: 6 };

            // Check if inside boundaries
            const isInside = isWithinBoundaries(dropCoords.x, dropCoords.y, boundaries);
            if (!isInside) {
              shouldAnimateReturn = true;
            }

            // For Waypoints/Exclusive points, also check if grid 0 (start grid)
            // This rule means waypoints/exclusive points cannot be dropped on grid 0
            if ((draggedItem === "waypoint" || draggedItem === "exclusive_point") && parseInt(targetCanvas.dataset.gridIndex, 10) === 0) {
              shouldAnimateReturn = true;
            }
          } else {
            shouldAnimateReturn = true;
          }
        }

        if (shouldAnimateReturn) {
          animateGhostReturn();
          // Don't hide ghost immediately, animation will handle it
        } else {
          dragGhost.style.display = "none";
        }

        boundaryGhost.style.display = "none";

        if (draggedItem === "robot") {
          handleRobotDrop(targetCanvas, currentX, currentY);
        } else if (draggedItem === "boundary") {
          const targetConfig = getFrameConfigFromElement(targetCanvas);
          handleBoundaryDrop(targetCanvas, targetConfig, currentX, currentY);
        } else if (draggedItem === "waypoint") {
          handleWaypointDrop(targetCanvas, currentX, currentY);
        } else if (draggedItem === "exclusive_point") {
          handleExclusivePointDrop(targetCanvas, currentX, currentY);
        } else if (
          draggedItem === "wall_horizontal" ||
          draggedItem === "wall_vertical"
        ) {
          handleWallDrop(targetCanvas, currentX, currentY);
        }

        // Cleanup
        // Save configId before clearing
        const tempSourceConfigId = sourceConfigId;
        draggedItem = null;
        draggedRobotData = null;
        draggedRobotIndex = -1;
        isNewRobotFromPalette = false;
        const tempSourceCanvas = sourceCanvasElement;
        sourceCanvasElement = null;
        sourceConfigId = null;
        sourceGridIndex = -1;
        sourceRobotsListRef = null;

        if (tempSourceCanvas) {
          tempSourceCanvas.classList.remove("dragging-source-canvas");
        }

        // Always redraw the source frame if it was a robot drag
        if (tempSourceConfigId) {
          redrawFrame(tempSourceConfigId);
        }

        document
          .querySelectorAll(".simulation-frame canvas")
          .forEach((canvas) => {
            canvas.classList.remove("drop-target-canvas");
          });
        updateFullConfigTextArea();
      }

      function handleRobotDrop(targetCanvas, currentX, currentY) {
        const targetConfig = getFrameConfigFromElement(targetCanvas);
        let droppedInsideValidCanvas = targetCanvas && targetConfig;
        let roundedDropCoords = { x: 0, y: 0 };
        let isDropInsideTargetBoundaries = false;
        let targetGridIndex = -1;

        if (droppedInsideValidCanvas) {
          const rect = targetCanvas.getBoundingClientRect();
          const mouseX = currentX - rect.left;
          const mouseY = currentY - rect.top;
          const dropCoords = frameCanvasToWorld(mouseX, mouseY);
          roundedDropCoords = {
            x: Math.round(dropCoords.x),
            y: Math.round(dropCoords.y),
          };
          targetGridIndex = parseInt(targetCanvas.dataset.gridIndex, 10);
          const targetBoundaries = targetConfig.boundaries || {
            xmin: -6,
            xmax: 6,
            ymin: -6,
            ymax: 6,
          };
          isDropInsideTargetBoundaries = isWithinBoundaries(
            roundedDropCoords.x,
            roundedDropCoords.y,
            targetBoundaries
          );
        }


        // Check if dropped in valid location
        const isValidDrop = droppedInsideValidCanvas && isDropInsideTargetBoundaries;

        // Remove robot from source if it was dragged from the grid (not from palette)
        if (
          !isNewRobotFromPalette &&
          sourceRobotsListRef &&
          draggedRobotIndex !== -1
        ) {
          sourceRobotsListRef.splice(draggedRobotIndex, 1);
        }
        // If invalid drop and not from palette, robot stays in original position

        // Add robot to target
        if (isValidDrop) {
          const targetRobotsList = targetConfig.grids[targetGridIndex];
          if (targetRobotsList) {
            // Remove all items at this position in the target grid
            removeAllItemsAtGridPosition(
              targetConfig,
              targetGridIndex,
              roundedDropCoords.x,
              roundedDropCoords.y
            );

            // Add the new robot at the position
            targetRobotsList.push([
              draggedRobotData[0],
              roundedDropCoords.x,
              roundedDropCoords.y,
            ]);
          }
        }

        // Redraw only the affected frames since we now use per-grid targeting
        if (isValidDrop) {
          redrawFrame(targetConfig.id);
        } else {
          // Only redraw the affected frames for robot-to-robot moves
          const affectedConfigIds = new Set();
          if (sourceConfigId) affectedConfigIds.add(sourceConfigId);
          if (targetConfig) affectedConfigIds.add(targetConfig.id);

          affectedConfigIds.forEach((configId) => {
            redrawFrame(configId);
          });
        }

        updateFullConfigTextArea();
        saveConfigsToLocalStorage();
      }

      // Helper function to remove all items at a specific position in a specific grid
      function removeAllItemsAtGridPosition(config, gridIndex, x, y) {
        // Remove robots from the specific grid
        if (config.grids && config.grids[gridIndex]) {
          const existingRobotIndex = config.grids[gridIndex].findIndex(
            ([color, rx, ry]) => rx === x && ry === y
          );
          if (existingRobotIndex !== -1) {
            config.grids[gridIndex].splice(existingRobotIndex, 1);
          }
        }

        // Remove waypoints from the specific grid
        if (config.gridWaypoints && config.gridWaypoints[gridIndex]) {
          const existingWaypointIndex = config.gridWaypoints[
            gridIndex
          ].findIndex(([wx, wy]) => wx === x && wy === y);
          if (existingWaypointIndex !== -1) {
            config.gridWaypoints[gridIndex].splice(existingWaypointIndex, 1);
          }
        }

        // Remove exclusive points from the specific grid
        if (
          config.gridExclusivePoints &&
          config.gridExclusivePoints[gridIndex]
        ) {
          const existingExclusiveIndex = config.gridExclusivePoints[
            gridIndex
          ].findIndex(([ex, ey]) => ex === x && ey === y);
          if (existingExclusiveIndex !== -1) {
            config.gridExclusivePoints[gridIndex].splice(
              existingExclusiveIndex,
              1
            );
          }
        }
      }

      function handleWaypointDrop(targetCanvas, currentX, currentY) {
        const targetConfig = getFrameConfigFromElement(targetCanvas);
        let droppedInsideValidCanvas = targetCanvas && targetConfig;
        let roundedDropCoords = { x: 0, y: 0 };
        let isDropInsideTargetBoundaries = false;
        let targetGridIndex = -1;

        if (droppedInsideValidCanvas) {
          const rect = targetCanvas.getBoundingClientRect();
          const mouseX = currentX - rect.left;
          const mouseY = currentY - rect.top;
          const dropCoords = frameCanvasToWorld(mouseX, mouseY);
          roundedDropCoords = {
            x: Math.round(dropCoords.x),
            y: Math.round(dropCoords.y),
          };
          targetGridIndex = parseInt(targetCanvas.dataset.gridIndex, 10);
          const targetBoundaries = targetConfig.boundaries || {
            xmin: -6,
            xmax: 6,
            ymin: -6,
            ymax: 6,
          };
          isDropInsideTargetBoundaries = isWithinBoundaries(
            roundedDropCoords.x,
            roundedDropCoords.y,
            targetBoundaries
          );
        }

        // Remove waypoint from source if re-dragging
        if (
          !isNewWaypointFromPalette &&
          sourceWaypointsListRef &&
          draggedWaypointIndex !== -1
        ) {
          // Note: already removed in handleCanvasMouseDown, no need to remove again
        }

        // Prevent dropping on starting grid (index 0)
        if (droppedInsideValidCanvas && targetGridIndex === 0) {
          alert(
            "Waypoints cannot be placed on the starting grid. Please place them on target grids only."
          );
          // Restore waypoint to source if it was a re-drag
          if (!isNewWaypointFromPalette && sourceWaypointsListRef) {
            sourceWaypointsListRef.splice(
              draggedWaypointIndex,
              0,
              draggedWaypointData
            );
            if (sourceConfigId) {
              redrawFrame(sourceConfigId);
            }
          }
          return;
        }

        // Add waypoint to target
        if (droppedInsideValidCanvas && isDropInsideTargetBoundaries) {
          // Initialize per-grid waypoints array if needed
          if (!targetConfig.gridWaypoints) {
            targetConfig.gridWaypoints = [];
          }
          if (!targetConfig.gridWaypoints[targetGridIndex]) {
            targetConfig.gridWaypoints[targetGridIndex] = [];
          }

          // Remove all items at this position in the target grid
          removeAllItemsAtGridPosition(
            targetConfig,
            targetGridIndex,
            roundedDropCoords.x,
            roundedDropCoords.y
          );

          // Add the new waypoint at the position
          targetConfig.gridWaypoints[targetGridIndex].push([
            roundedDropCoords.x,
            roundedDropCoords.y,
          ]);

          // Redraw only this frame
          redrawFrame(targetConfig.id);
        } else if (
          droppedInsideValidCanvas &&
          !isDropInsideTargetBoundaries
        ) {
          // Drop was outside grid boundaries - remove waypoint completely (same as robots)
          // Don't restore to source, just discard it
          if (targetConfig) {
            redrawFrame(targetConfig.id);
          }
          if (
            sourceConfigId &&
            sourceConfigId !== (targetConfig ? targetConfig.id : null)
          ) {
            redrawFrame(sourceConfigId);
          }
        } else {
          // Drop was outside any canvas or invalid - discard waypoint (do not restore to source)
          // No need to modify source lists; just redraw affected frames if necessary
          if (targetConfig) {
            redrawFrame(targetConfig.id);
          }
          if (sourceConfigId && sourceConfigId !== (targetConfig ? targetConfig.id : null)) {
            redrawFrame(sourceConfigId);
          }
        }

        updateFullConfigTextArea();
        saveConfigsToLocalStorage();
      }

      function handleExclusivePointDrop(targetCanvas, currentX, currentY) {
        const targetConfig = getFrameConfigFromElement(targetCanvas);
        let droppedInsideValidCanvas = targetCanvas && targetConfig;
        let roundedDropCoords = { x: 0, y: 0 };
        let isDropInsideTargetBoundaries = false;
        let targetGridIndex = -1;

        if (droppedInsideValidCanvas) {
          const rect = targetCanvas.getBoundingClientRect();
          const mouseX = currentX - rect.left;
          const mouseY = currentY - rect.top;
          const dropCoords = frameCanvasToWorld(mouseX, mouseY);
          roundedDropCoords = {
            x: Math.round(dropCoords.x),
            y: Math.round(dropCoords.y),
          };
          targetGridIndex = parseInt(targetCanvas.dataset.gridIndex, 10);
          const targetBoundaries = targetConfig.boundaries || {
            xmin: -6,
            xmax: 6,
            ymin: -6,
            ymax: 6,
          };
          isDropInsideTargetBoundaries = isWithinBoundaries(
            roundedDropCoords.x,
            roundedDropCoords.y,
            targetBoundaries
          );
        }

        // Remove exclusive point from source if re-dragging
        if (
          !isNewExclusivePointFromPalette &&
          sourceExclusivePointsListRef &&
          draggedExclusivePointIndex !== -1
        ) {
          // Note: already removed in handleCanvasMouseDown, no need to remove again
        }

        // Prevent dropping on starting grid (index 0)
        if (droppedInsideValidCanvas && targetGridIndex === 0) {
          alert(
            "Exclusive points cannot be placed on the starting grid. Please place them on target grids only."
          );
          // Restore exclusive point to source if it was a re-drag
          if (
            !isNewExclusivePointFromPalette &&
            sourceExclusivePointsListRef
          ) {
            sourceExclusivePointsListRef.splice(
              draggedExclusivePointIndex,
              0,
              draggedExclusivePointData
            );
            if (sourceConfigId) {
              redrawFrame(sourceConfigId);
            }
          }
          return;
        }

        // Add exclusive point to target
        if (droppedInsideValidCanvas && isDropInsideTargetBoundaries) {
          // Initialize per-grid exclusive points array if needed
          if (!targetConfig.gridExclusivePoints) {
            targetConfig.gridExclusivePoints = [];
          }
          if (!targetConfig.gridExclusivePoints[targetGridIndex]) {
            targetConfig.gridExclusivePoints[targetGridIndex] = [];
          }

          // Remove all items at this position in the target grid
          removeAllItemsAtGridPosition(
            targetConfig,
            targetGridIndex,
            roundedDropCoords.x,
            roundedDropCoords.y
          );

          // Add the new exclusive point at the position
          targetConfig.gridExclusivePoints[targetGridIndex].push([
            roundedDropCoords.x,
            roundedDropCoords.y,
          ]);

          // Redraw only this frame
          redrawFrame(targetConfig.id);
        } else if (
          droppedInsideValidCanvas &&
          !isDropInsideTargetBoundaries
        ) {
          // Drop was outside grid boundaries - remove exclusive point completely (same as robots)
          // Don't restore to source, just discard it
          if (targetConfig) {
            redrawFrame(targetConfig.id);
          }
          if (
            sourceConfigId &&
            sourceConfigId !== (targetConfig ? targetConfig.id : null)
          ) {
            redrawFrame(sourceConfigId);
          }
        } else {
          // Drop was outside any canvas or invalid - restore exclusive point to source if it was a re-drag
          if (
            !isNewExclusivePointFromPalette &&
            sourceExclusivePointsListRef
          ) {
            sourceExclusivePointsListRef.splice(
              draggedExclusivePointIndex,
              0,
              draggedExclusivePointData
            );
            if (sourceConfigId) {
              redrawFrame(sourceConfigId);
            }
          }
        }

        updateFullConfigTextArea();
        saveConfigsToLocalStorage();
      }

      function handleWallDrop(targetCanvas, currentX, currentY) {
        // Only consider it a valid drop if we actually have a canvas element under the mouse
        let droppedInsideValidCanvas = false;
        let roundedDropCoords = { x: 0, y: 0 };
        let targetConfig = null;

        // Check if we have a canvas AND if the mouse is actually over that canvas
        if (targetCanvas) {
          const rect = targetCanvas.getBoundingClientRect();
          const mouseX = currentX - rect.left;
          const mouseY = currentY - rect.top;

          // Ensure mouse is within canvas bounds
          if (
            mouseX >= 0 &&
            mouseX <= rect.width &&
            mouseY >= 0 &&
            mouseY <= rect.height
          ) {
            targetConfig = getFrameConfigFromElement(targetCanvas);
            if (targetConfig) {
              droppedInsideValidCanvas = true;
              const dropCoords = frameCanvasToWorld(mouseX, mouseY);
              roundedDropCoords = {
                x: Math.round(dropCoords.x),
                y: Math.round(dropCoords.y),
              };
            }
          }
        }

        // Add wall ONLY if dropped inside a valid canvas area
        if (droppedInsideValidCanvas && draggedWallData) {
          if (!targetConfig.walls) {
            targetConfig.walls = [];
          }

          const boundaries = targetConfig.boundaries || {
            xmin: -6,
            xmax: 6,
            ymin: -6,
            ymax: 6,
          };

          // Extend walls beyond boundaries to allow outside placement
          const extendedBounds = {
            xmin: boundaries.xmin - 5,
            xmax: boundaries.xmax + 5,
            ymin: boundaries.ymin - 5,
            ymax: boundaries.ymax + 5,
          };

          // Remove existing wall of the same type (max one vertical, max one horizontal)
          targetConfig.walls = targetConfig.walls.filter(
            (wall) => wall.type !== draggedWallData.type
          );

          let newWall;
          if (draggedWallData.type === "horizontal") {
            newWall = {
              type: "horizontal",
              x1: extendedBounds.xmin,
              y1: roundedDropCoords.y,
              x2: extendedBounds.xmax,
              y2: roundedDropCoords.y,
            };
          } else {
            newWall = {
              type: "vertical",
              x1: roundedDropCoords.x,
              y1: extendedBounds.ymin,
              x2: roundedDropCoords.x,
              y2: extendedBounds.ymax,
            };
          }

          targetConfig.walls.push(newWall);
        }

        // If NOT droppedInsideValidCanvas, the wall is automatically deleted
        // (it was already removed from source during drag start)

        // Redraw all frames
        activeSimulationConfigs.forEach((config) => {
          redrawFrame(config.id);
        });

        updateFullConfigTextArea();
        saveConfigsToLocalStorage();

        // Reset palette state
        isNewWallFromPalette = false;
        draggedWallData = null;
      }

      function handleBoundaryDrop(
        targetCanvas,
        targetConfig,
        currentX,
        currentY
      ) {
        if (
          !targetCanvas ||
          !targetConfig ||
          !draggedBoundaryEdge ||
          targetConfig.id !== sourceConfigId
        ) {
          return;
        }
        if (!targetConfig.boundaries) {
          targetConfig.boundaries = { xmin: -6, xmax: 6, ymin: -6, ymax: 6 };
        }

        const rect = targetCanvas.getBoundingClientRect();
        const mouseX = currentX - rect.left;
        const mouseY = currentY - rect.top;
        let worldValue =
          draggedBoundaryEdge === "xmin" || draggedBoundaryEdge === "xmax"
            ? frameCanvasToWorld(mouseX, mouseY).x
            : frameCanvasToWorld(mouseX, mouseY).y;
        let newBoundaryValue = Math.round(worldValue);

        const hardLimit = 15;
        const currentBoundaries = targetConfig.boundaries;
        let finalClampedValue = newBoundaryValue;
        switch (draggedBoundaryEdge) {
          case "xmin":
            finalClampedValue = Math.max(
              -hardLimit,
              Math.min(
                newBoundaryValue,
                (currentBoundaries.xmax ?? hardLimit) - 1
              )
            );
            break;
          case "xmax":
            finalClampedValue = Math.min(
              hardLimit,
              Math.max(
                newBoundaryValue,
                (currentBoundaries.xmin ?? -hardLimit) + 1
              )
            );
            break;
          case "ymin":
            finalClampedValue = Math.max(
              -hardLimit,
              Math.min(
                newBoundaryValue,
                (currentBoundaries.ymax ?? hardLimit) - 1
              )
            );
            break;
          case "ymax":
            finalClampedValue = Math.min(
              hardLimit,
              Math.max(
                newBoundaryValue,
                (currentBoundaries.ymin ?? -hardLimit) + 1
              )
            );
            break;
        }

        if (currentBoundaries[draggedBoundaryEdge] !== finalClampedValue) {
          currentBoundaries[draggedBoundaryEdge] = finalClampedValue;
          // Filter out robots that are now outside the new boundaries
          targetConfig.grids.forEach((grid) => {
            const filteredGrid = grid.filter(([_, x, y]) =>
              isWithinBoundaries(x, y, targetConfig.boundaries)
            );
            grid.length = 0; // Clear original grid
            grid.push(...filteredGrid); // Push back filtered robots
          });

          // Filter waypoints and exclusive points
          if (targetConfig.waypoints) {
            targetConfig.waypoints = targetConfig.waypoints.filter(([x, y]) =>
              isWithinBoundaries(x, y, targetConfig.boundaries)
            );
          }
          if (targetConfig.exclusive_points) {
            targetConfig.exclusive_points =
              targetConfig.exclusive_points.filter(([x, y]) =>
                isWithinBoundaries(x, y, targetConfig.boundaries)
              );
          }

          // Only redraw the affected frame instead of full re-render
          redrawFrame(targetConfig.id);
          updateFullConfigTextArea();
          saveConfigsToLocalStorage();
        }
      }

      function getBoundaryEdgeAtPosition(canvasX, canvasY, frameBoundaries) {
        const threshold = simConfig.boundaryHitThreshold;
        if (!frameBoundaries) return null;
        const { cx: xmin_cx } = frameWorldToCanvas(frameBoundaries.xmin, 0);
        const { cx: xmax_cx } = frameWorldToCanvas(frameBoundaries.xmax, 0);
        const { cy: ymin_cy } = frameWorldToCanvas(0, frameBoundaries.ymin);
        const { cy: ymax_cy } = frameWorldToCanvas(0, frameBoundaries.ymax);
        if (
          Math.abs(canvasX - xmin_cx) < threshold &&
          canvasY >= ymax_cy &&
          canvasY <= ymin_cy
        )
          return "xmin";
        if (
          Math.abs(canvasX - xmax_cx) < threshold &&
          canvasY >= ymax_cy &&
          canvasY <= ymin_cy
        )
          return "xmax";
        if (
          Math.abs(canvasY - ymin_cy) < threshold &&
          canvasX >= xmin_cx &&
          canvasX <= xmax_cx
        )
          return "ymin";
        if (
          Math.abs(canvasY - ymax_cy) < threshold &&
          canvasX >= xmin_cx &&
          canvasX <= xmax_cx
        )
          return "ymax";
        return null;
      }

      function updateBoundaryGhostPosition(clientX, clientY, canvas, rect) {
        if (!draggedBoundaryEdge || !boundaryGhost) return;
        const mouseX_canvas = clientX - rect.left;
        const mouseY_canvas = clientY - rect.top;
        boundaryGhost.style.display = "block";
        const canvasSize = canvas.width;
        const boundaryWidthPx = simConfig.boundaryWidth;
        switch (draggedBoundaryEdge) {
          case "xmin":
          case "xmax":
            boundaryGhost.style.left = `${mouseX_canvas + rect.left - boundaryWidthPx / 2
              }px`;
            boundaryGhost.style.top = `${rect.top}px`;
            boundaryGhost.style.width = `${boundaryWidthPx}px`;
            boundaryGhost.style.height = `${canvasSize}px`;
            break;
          case "ymin":
          case "ymax":
            boundaryGhost.style.left = `${rect.left}px`;
            boundaryGhost.style.top = `${mouseY_canvas + rect.top - boundaryWidthPx / 2
              }px`;
            boundaryGhost.style.width = `${canvasSize}px`;
            boundaryGhost.style.height = `${boundaryWidthPx}px`;
            break;
        }
      }

      // --- Frame Reordering Handlers ---
      function handleFrameDragStart(e) {
        if (e.currentTarget.dataset.dragReady !== "true") {
          e.preventDefault();
          return;
        }
        delete e.currentTarget.dataset.dragReady;
        draggedItem = "frame";
        const frame = e.currentTarget;
        draggedFrameId = frame.dataset.configId;
        if (!draggedFrameId) {
          e.preventDefault();
          return;
        }
        e.dataTransfer.setData("text/plain", draggedFrameId);
        e.dataTransfer.effectAllowed = "move";
        setTimeout(() => {
          if (frame.isConnected) frame.classList.add("dragging");
        }, 0);
      }

      function handleFrameDragOver(e) {
        e.preventDefault();
        if (draggedItem !== "frame" || !simulatorColumn) return;
        e.dataTransfer.dropEffect = "move";
        const draggingFrame = simulatorColumn.querySelector(
          ".simulation-frame.dragging"
        );
        if (!draggingFrame) {
          stopScrolling();
          return;
        }
        const colRect = simulatorColumn.getBoundingClientRect();
        const mouseY = e.clientY;
        if (mouseY < colRect.top + SCROLL_ZONE_HEIGHT)
          startScrolling(-SCROLL_SPEED);
        else if (mouseY > colRect.bottom - SCROLL_ZONE_HEIGHT)
          startScrolling(SCROLL_SPEED);
        else stopScrolling();
        const targetElement = getDragAfterElement(simulatorColumn, e.clientY);
        if (!dropIndicator) {
          dropIndicator = document.createElement("div");
          dropIndicator.className = "drop-indicator";
        }
        if (targetElement == null) {
          if (!dropIndicator.parentNode || dropIndicator.nextSibling)
            simulatorColumn.appendChild(dropIndicator);
        } else {
          if (dropIndicator !== targetElement.previousSibling)
            simulatorColumn.insertBefore(dropIndicator, targetElement);
        }
      }

      function handleFrameDragLeave(e) {
        if (
          !simulatorColumn.contains(e.relatedTarget) &&
          draggedItem === "frame"
        ) {
          removeDropIndicator();
          stopScrolling();
        }
      }

      function handleFrameDrop(e) {
        e.preventDefault();
        stopScrolling();
        if (draggedItem !== "frame" || !draggedFrameId) {
          removeDropIndicator();
          return;
        }
        const droppedConfigId = e.dataTransfer.getData("text/plain");
        if (droppedConfigId !== draggedFrameId) {
          removeDropIndicator();
          return;
        }
        const targetElement = getDragAfterElement(simulatorColumn, e.clientY);
        const draggedIndex = activeSimulationConfigs.findIndex(
          (cfg) => cfg.id === droppedConfigId
        );
        if (draggedIndex === -1) {
          removeDropIndicator();
          return;
        }
        const [draggedConfig] = activeSimulationConfigs.splice(
          draggedIndex,
          1
        );
        if (targetElement) {
          const targetId = targetElement.dataset.configId;
          const targetIndex = activeSimulationConfigs.findIndex(
            (cfg) => cfg.id === targetId
          );
          if (targetIndex !== -1)
            activeSimulationConfigs.splice(targetIndex, 0, draggedConfig);
          else activeSimulationConfigs.push(draggedConfig);
        } else {
          activeSimulationConfigs.push(draggedConfig);
        }
        removeDropIndicator();
        renderAllFrames();
      }

      function handleFrameDragEnd(e) {
        const frame = e.target.closest(".simulation-frame");
        if (frame) {
          delete frame.dataset.dragReady;
          frame.classList.remove("dragging");
        }
        removeDropIndicator();
        stopScrolling();
        if (draggedItem === "frame") draggedItem = null;
        draggedFrameId = null;
      }

      function getDragAfterElement(container, y) {
        const draggableElements = [
          ...container.querySelectorAll(".simulation-frame:not(.dragging)"),
        ];
        return draggableElements.reduce(
          (closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            if (offset < 0 && offset > closest.offset)
              return { offset: offset, element: child };
            else return closest;
          },
          { offset: Number.NEGATIVE_INFINITY }
        ).element;
      }

      function removeDropIndicator() {
        if (dropIndicator && dropIndicator.parentNode) {
          dropIndicator.parentNode.removeChild(dropIndicator);
        }
        dropIndicator = null;
      }

      function startScrolling(speed) {
        if (scrollIntervalId === null) {
          scrollIntervalId = setInterval(() => {
            if (simulatorColumn) simulatorColumn.scrollTop += speed;
            else stopScrolling();
          }, 30);
        }
      }
      function stopScrolling() {
        if (scrollIntervalId !== null) {
          clearInterval(scrollIntervalId);
          scrollIntervalId = null;
        }
      }

      // --- Resize and Toggle Functionality ---
      function initializeResizeAndToggle() {
        // Resize functionality
        resizeHandle.addEventListener("mousedown", (e) => {
          isResizing = true;
          document.body.style.cursor = "col-resize";
          document.body.style.userSelect = "none";
          e.preventDefault();
        });

        document.addEventListener("mousemove", (e) => {
          if (!isResizing || isEditorHidden) return;

          const containerRect = mainContainer.getBoundingClientRect();
          const mouseX = e.clientX - containerRect.left;
          const totalWidth = containerRect.width;

          // Calculate new widths as percentages
          const simulatorWidth = Math.max(
            30,
            Math.min(70, (mouseX / totalWidth) * 100)
          );
          const editorWidth = 100 - simulatorWidth;

          // Apply new widths
          simulatorColumn.style.flex = `0 0 ${simulatorWidth}%`;
          editorColumn.style.flex = `0 0 ${editorWidth}%`;
        });

        document.addEventListener("mouseup", () => {
          if (isResizing) {
            isResizing = false;
            document.body.style.cursor = "";
            document.body.style.userSelect = "";
            // Save layout after resize
            saveLayoutToLocalStorage();
          }
        });

        // Toggle functionality
        toggleEditorBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          toggleEditor();
        });
      }

      function toggleEditor() {
        isEditorHidden = !isEditorHidden;

        if (isEditorHidden) {
          // Hide editor
          editorColumn.style.display = "none";
          resizeHandle.style.cursor = "pointer";
          simulatorColumn.style.flex = "1";
          toggleEditorBtn.textContent = "â–¸";
          toggleEditorBtn.title = "Show editor panel";
        } else {
          // Show editor
          editorColumn.style.display = "flex";
          resizeHandle.style.cursor = "col-resize";
          simulatorColumn.style.flex = "0 0 50%";
          editorColumn.style.flex = "0 0 50%";
          toggleEditorBtn.textContent = "â—‚";
          toggleEditorBtn.title = "Hide editor panel";
        }

        // Save layout state
        saveLayoutToLocalStorage();
      }

      // --- Add New Frame & Local Storage ---
      function addNewFrame() {
        // Get the obstacle type from the dropdown
        const obstacleChar = document.getElementById("obstacle_type")?.value || "O";

        const newConfig = {
          id: `cfg-new-${Date.now()}`,
          grids: [[[obstacleChar, 0, 0]], [[obstacleChar, 0, 0]]], // Start with obstacle at (0,0) in both grids
          steps: 5, // This will become total steps (sum of grid steps)
          gridSteps: [0, 5], // Steps for each grid: [starting=0, target1=5]
          gridWaypoints: [[], []], // No waypoints by default
          gridExclusivePoints: [[], []], // No exclusive points by default
          boundaries: { xmin: -6, xmax: 6, ymin: -6, ymax: 6 },
          waypoints: [],
          exclusive_points: [],
          walls: [], // Array of wall objects: {type: 'horizontal'|'vertical', x1, y1, x2, y2}
          needsRedraw: true,
        };
        activeSimulationConfigs.push(newConfig);
        renderAllFrames();
        const newFrameElement = frameElements[newConfig.id]?.frameDiv;
        if (newFrameElement) {
          newFrameElement.scrollIntoView({
            behavior: "smooth",
            block: "nearest",
          });
        }
      }

      // --- LocalStorage Functions (DISABLED) ---
      const LOCAL_STORAGE_KEY = "multiRobotSimConfigs_v3";
      function saveConfigsToLocalStorage() {
        // Disabled - no localStorage usage
      }
      function loadConfigsFromLocalStorage() {
        // Disabled - no localStorage usage
        return null;
        /*
      try {
        const raw = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return null;
        return parsed.map((cfg, idx) => ({
          id: cfg.id || `cfg-cached-${Date.now()}-${idx}`,
          grids: Array.isArray(cfg.grids) ? cfg.grids : [[], []],
          steps: typeof cfg.steps === "number" ? cfg.steps : 0,
          gridSteps: Array.isArray(cfg.gridSteps) ? cfg.gridSteps : [],
          gridWaypoints: Array.isArray(cfg.gridWaypoints)
            ? cfg.gridWaypoints
            : [],
          gridExclusivePoints: Array.isArray(cfg.gridExclusivePoints)
            ? cfg.gridExclusivePoints
            : [],
          boundaries: cfg.boundaries || {
            xmin: -6,
            xmax: 6,
            ymin: -6,
            ymax: 6,
          },
          waypoints: Array.isArray(cfg.waypoints) ? cfg.waypoints : [],
          exclusive_points: Array.isArray(cfg.exclusive_points)
            ? cfg.exclusive_points
            : [],
          walls: Array.isArray(cfg.walls) ? cfg.walls : [],
          needsRedraw: true,
        }));
      } catch (e) {
        console.error("Failed to load configs:", e);
        return null;
      }
      */
      }
      function clearConfigsFromLocalStorage() {
        // Disabled - no localStorage usage
        /*
      localStorage.removeItem(LOCAL_STORAGE_KEY);
      */
      }

      // --- Layout Storage Functions ---
      function saveLayoutToLocalStorage() {
        // Disabled - no localStorage usage
        /*
      try {
        const layout = {
          isEditorHidden: isEditorHidden,
          simulatorWidth: simulatorColumn.style.flex || "0 0 50%",
          editorWidth: editorColumn.style.flex || "0 0 50%",
        };
        localStorage.setItem(LAYOUT_STORAGE_KEY, JSON.stringify(layout));
      } catch (e) {
        console.error("Failed to save layout:", e);
      }
      */
      }

      function loadLayoutFromLocalStorage() {
        // Disabled - no localStorage usage
        return null;
        /*
      try {
        const raw = localStorage.getItem(LAYOUT_STORAGE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch (e) {
        console.error("Failed to load layout:", e);
        return null;
      }
      */
      }

      function applyLayoutFromStorage() {
        const layout = loadLayoutFromLocalStorage();
        if (!layout) return;

        // Apply saved layout
        if (layout.simulatorWidth) {
          simulatorColumn.style.flex = layout.simulatorWidth;
        }
        if (layout.editorWidth) {
          editorColumn.style.flex = layout.editorWidth;
        }

        // Apply editor visibility state
        if (layout.isEditorHidden) {
          isEditorHidden = false; // Reset state first
          toggleEditor(); // This will set it to hidden and update UI
        }
      }

      // --- Modal and Parser Logic ---
      function setupModalAndParser() {
        const copyBtn = document.getElementById("copyConfigBtn");
        const loadBtn = document.getElementById("loadConfigBtn");
        const loadMissingGoalsBtn = document.getElementById(
          "loadMissingGoalsBtn"
        );
        const closeModalBtn = document.getElementById("closeModalBtn");
        const submitConfigBtn = document.getElementById("submitConfigBtn");
        const resetBtn = document.getElementById("resetConfigBtn");

        if (copyBtn)
          copyBtn.addEventListener("click", () => {
            if (!simulationConfigListTextArea) return;
            navigator.clipboard
              .writeText(simulationConfigListTextArea.value)
              .then(() => {
                const originalText = copyBtn.innerHTML;
                copyBtn.innerHTML = `Copied!`;
                setTimeout(() => {
                  copyBtn.innerHTML = originalText;
                }, 1500);
              })
              .catch((err) => console.error("Failed to copy:", err));
          });

        if (loadBtn)
          loadBtn.addEventListener("click", () => {
            loadModal.style.display = "flex";
            if (newConfigEditor) {
              newConfigEditor.value = "";
              newConfigEditor.focus();
            }
          });

        if (loadMissingGoalsBtn)
          loadMissingGoalsBtn.addEventListener("click", () => {
            // Set modal to "add goals" mode
            loadModal.dataset.mode = "add-goals";
            loadModal.querySelector("h3").textContent =
              "Add Missing Goal Configurations";
            loadModal.querySelector("p").innerHTML =
              'Paste goal configurations to add to the end of your current list:<br />â€¢ JSON array of goal objects: <code>[{"initial_positions": [...], "targets": [...], ...}]</code>';
            loadModal.querySelector("#versionSelector").style.display =
              "none";
            loadModal.querySelector("#submitConfigBtn").textContent =
              "Add Goals";

            loadModal.style.display = "flex";
            if (newConfigEditor) {
              newConfigEditor.value = "";
              newConfigEditor.placeholder =
                'Paste your missing goal configurations here...\n\nExample:\n[\n  {\n    "initial_positions": [["O", 0, 0], ["L", 0, 2], ["F", -2, 2]],\n    "targets": [\n      [3, [["L", 3, 2], ["F", 1, 2], ["O", 0, 0]], [], []]\n    ],\n    "boundary": [-3, 4, -1, 3],\n    "wall": [null, null]\n  }\n]';
              newConfigEditor.focus();
            }
          });

        if (closeModalBtn)
          closeModalBtn.addEventListener("click", () => {
            loadModal.style.display = "none";
            // Reset modal to default "load" mode
            loadModal.dataset.mode = "load";
            loadModal.querySelector("h3").textContent =
              "Load New Configuration";
            loadModal.querySelector("p").innerHTML =
              'You can paste either:<br />â€¢ JSON: <code>{"simulation_configs": [...]}</code><br />â€¢ Complete HTML simulation file';
            loadModal.querySelector("#versionSelector").style.display =
              "block";
            loadModal.querySelector("#submitConfigBtn").textContent =
              "Load Configuration";
            if (newConfigEditor) {
              newConfigEditor.placeholder =
                "Paste your JSON configuration here, or paste a complete HTML simulation file...";
            }
          });

        if (submitConfigBtn)
          submitConfigBtn.addEventListener("click", () => {
            const newConfigText = newConfigEditor.value;
            const selectedFormat = versionSelector.value; // "json" or "rust"
            const isAddGoalsMode = loadModal.dataset.mode === "add-goals";

            if (!newConfigText.trim()) return;

            try {
              if (isAddGoalsMode) {
                // Handle adding goal configurations to existing list
                let newGoals = [];

                try {
                  // Try to parse as JSON array of goal objects
                  newGoals = JSON.parse(newConfigText.trim());
                  if (!Array.isArray(newGoals)) {
                    throw new Error(
                      "Expected an array of goal configuration objects"
                    );
                  }
                } catch (jsonError) {
                  throw new Error(
                    `Invalid JSON format for goal configurations: ${jsonError.message}`
                  );
                }

                // Convert each goal configuration to internal format and add to existing configs
                const convertedGoals = newGoals.map((goalConfig, index) => {
                  const boundaries = goalConfig.boundary || [-6, 6, -6, 6];
                  const walls = [];

                  // Convert wall array [vertical, horizontal] to wall objects
                  if (goalConfig.wall && goalConfig.wall.length >= 2) {
                    const [verticalWall, horizontalWall] = goalConfig.wall;

                    if (verticalWall !== null) {
                      walls.push({
                        type: "vertical",
                        x1: verticalWall,
                        y1: boundaries[2] - 5, // ymin - 5
                        x2: verticalWall,
                        y2: boundaries[3] + 5, // ymax + 5
                      });
                    }

                    if (horizontalWall !== null) {
                      walls.push({
                        type: "horizontal",
                        x1: boundaries[0] - 5, // xmin - 5
                        y1: horizontalWall,
                        x2: boundaries[1] + 5, // xmax + 5
                        y2: horizontalWall,
                      });
                    }
                  }

                  // Convert targets to grids format
                  const grids = [goalConfig.initial_positions || []];
                  const gridSteps = [0]; // Starting position
                  const gridWaypoints = [[]]; // Starting grid has no waypoints
                  const gridExclusivePoints = [[]]; // Starting grid has no exclusive points

                  if (
                    goalConfig.targets &&
                    Array.isArray(goalConfig.targets)
                  ) {
                    goalConfig.targets.forEach((target) => {
                      if (Array.isArray(target) && target.length >= 4) {
                        const [steps, robots, exclusive, waypoints] = target;
                        grids.push(robots || []);
                        gridSteps.push(steps || 5);
                        gridWaypoints.push(waypoints || []);
                        gridExclusivePoints.push(exclusive || []);
                      }
                    });
                  }

                  // Ensure at least one target grid
                  if (grids.length < 2) {
                    grids.push([]);
                    gridSteps.push(5);
                    gridWaypoints.push([]);
                    gridExclusivePoints.push([]);
                  }

                  // Calculate total steps
                  const totalSteps = gridSteps
                    .slice(1)
                    .reduce((sum, steps) => sum + steps, 0);

                  return {
                    id: `cfg-added-${Date.now()}-${index}`,
                    grids,
                    steps: totalSteps,
                    gridSteps,
                    gridWaypoints,
                    gridExclusivePoints,
                    boundaries: {
                      xmin: boundaries[0],
                      xmax: boundaries[1],
                      ymin: boundaries[2],
                      ymax: boundaries[3],
                    },
                    walls,
                    needsRedraw: true,
                  };
                });

                // Add the new configurations to the existing list
                activeSimulationConfigs.push(...convertedGoals);

                console.log(
                  `Successfully added ${convertedGoals.length} goal configurations`
                );
              } else if (selectedFormat === "json") {
                // Parse as JSON format
                let parsedData = JSON.parse(newConfigText.trim());

                // Check if it's the expected format with simulation_configs
                if (
                  parsedData &&
                  parsedData.simulation_configs &&
                  Array.isArray(parsedData.simulation_configs)
                ) {
                  // Convert JSON format to internal format
                  activeSimulationConfigs = parsedData.simulation_configs.map(
                    (config, index) => {
                      const boundaries = config.boundary || [-6, 6, -6, 6];
                      const walls = [];

                      // Convert wall array [vertical, horizontal] to wall objects
                      if (config.wall && config.wall.length >= 2) {
                        const [verticalWall, horizontalWall] = config.wall;

                        if (verticalWall !== null) {
                          walls.push({
                            type: "vertical",
                            x1: verticalWall,
                            y1: boundaries[2] - 5, // ymin - 5
                            x2: verticalWall,
                            y2: boundaries[3] + 5, // ymax + 5
                          });
                        }

                        if (horizontalWall !== null) {
                          walls.push({
                            type: "horizontal",
                            x1: boundaries[0] - 5, // xmin - 5
                            y1: horizontalWall,
                            x2: boundaries[1] + 5, // xmax + 5
                            y2: horizontalWall,
                          });
                        }
                      }

                      // Convert targets to grids format
                      const grids = [config.initial_positions || []];
                      const gridSteps = [0]; // Starting position
                      const gridWaypoints = [[]]; // Starting grid has no waypoints
                      const gridExclusivePoints = [[]]; // Starting grid has no exclusive points

                      if (config.targets && Array.isArray(config.targets)) {
                        config.targets.forEach((target) => {
                          if (Array.isArray(target) && target.length >= 4) {
                            const [steps, robots, exclusive, waypoints] =
                              target;
                            grids.push(robots || []);
                            gridSteps.push(steps || 5);
                            gridWaypoints.push(waypoints || []);
                            gridExclusivePoints.push(exclusive || []);
                          }
                        });
                      }

                      // Ensure at least one target grid
                      if (grids.length < 2) {
                        grids.push([]);
                        gridSteps.push(5);
                        gridWaypoints.push([]);
                        gridExclusivePoints.push([]);
                      }

                      // Calculate total steps
                      const totalSteps = gridSteps
                        .slice(1)
                        .reduce((sum, steps) => sum + steps, 0);

                      return {
                        id: `cfg-loaded-${Date.now()}-${index}`,
                        grids,
                        steps: totalSteps,
                        gridSteps,
                        gridWaypoints,
                        gridExclusivePoints,
                        boundaries: {
                          xmin: boundaries[0],
                          xmax: boundaries[1],
                          ymin: boundaries[2],
                          ymax: boundaries[3],
                        },
                        walls,
                        needsRedraw: true,
                      };
                    }
                  );

                  console.log(
                    "Successfully loaded",
                    activeSimulationConfigs.length,
                    "configurations from JSON format"
                  );
                } else {
                  throw new Error(
                    "Invalid JSON format. Expected object with 'simulation_configs' array."
                  );
                }
              } else if (selectedFormat === "rust") {
                // Parse as Rust format
                console.log("Parsing as Rust format...");
                const parsedConfigs =
                  parseSimulationConfigList(newConfigText);

                // Ensure each config has proper structure and IDs
                activeSimulationConfigs = parsedConfigs.map((cfg, index) => ({
                  id: `cfg-loaded-${Date.now()}-${index}`,
                  grids: cfg.grids || [[], []],
                  steps: cfg.steps || 0,
                  gridSteps: cfg.gridSteps || [0, 5],
                  gridWaypoints: cfg.gridWaypoints || [[], []],
                  gridExclusivePoints: cfg.gridExclusivePoints || [[], []],
                  boundaries: cfg.boundaries || {
                    xmin: -6,
                    xmax: 6,
                    ymin: -6,
                    ymax: 6,
                  },
                  walls: cfg.walls || [],
                  needsRedraw: true,
                }));

                console.log(
                  "Successfully loaded",
                  activeSimulationConfigs.length,
                  "configurations from Rust format"
                );
              } else {
                throw new Error(`Unknown format selected: ${selectedFormat}`);
              }

              // Render the frames and update UI
              renderAllFrames();
              updateFullConfigTextArea();
              saveConfigsToLocalStorage();

              loadModal.style.display = "none";

              // Reset modal to default "load" mode after successful operation
              loadModal.dataset.mode = "load";
              loadModal.querySelector("h3").textContent =
                "Load New Configuration";
              loadModal.querySelector("p").innerHTML =
                'You can paste either:<br />â€¢ JSON: <code>{"simulation_configs": [...]}</code><br />â€¢ Complete HTML simulation file';
              loadModal.querySelector("#versionSelector").style.display =
                "block";
              loadModal.querySelector("#submitConfigBtn").textContent =
                "Load Configuration";
              if (newConfigEditor) {
                newConfigEditor.placeholder =
                  "Paste your JSON configuration here, or paste a complete HTML simulation file...";
              }
            } catch (error) {
              console.error(
                `Error parsing ${isAddGoalsMode ? "goal" : selectedFormat.toUpperCase()
                } configuration:`,
                error
              );
              alert(
                `Error parsing ${isAddGoalsMode ? "goal" : selectedFormat.toUpperCase()
                } configuration:\n${error.message
                }\n\nPlease check the format and try again.`
              );
            }
          });

        if (resetBtn)
          resetBtn.addEventListener("click", () => {
            // Using a custom modal for confirm would be better, but for simplicity:
            if (
              window.confirm(
                "Are you sure you want to reset to default goals? This will reload the goals based on your selected algorithm."
              )
            ) {
              // Reload goals from defaultSimulationConfigList without reloading the page
              try {
                console.log(
                  "Resetting goals from defaultSimulationConfigList..."
                );
                activeSimulationConfigs = parseDefaultConfigs();
                console.log(
                  "Loaded",
                  activeSimulationConfigs.length,
                  "simulation configs"
                );

                // Refresh UI
                renderAllFrames();
                updateFullConfigTextArea();
                saveConfigsToLocalStorage();

                // Show success feedback on the button
                const originalText = resetBtn.innerHTML;
                const originalClass = resetBtn.className;
                resetBtn.innerHTML = "âœ“ Reset!";
                resetBtn.className = "btn btn-success btn-sm";
                resetBtn.style.padding = "5px 10px";
                resetBtn.style.fontSize = "0.9em";
                setTimeout(() => {
                  resetBtn.innerHTML = originalText;
                  resetBtn.className = originalClass;
                  resetBtn.style.padding = "5px 10px";
                  resetBtn.style.fontSize = "0.9em";
                }, 2000);
              } catch (error) {
                console.error("Error resetting configurations:", error);
                alert("Failed to reset goals: " + error.message);
              }
            }
          });
      }

      function parseSimulationConfigList(inputText) {
        // First, check if the input is HTML content
        const trimmedInput = inputText.trim();
        if (
          trimmedInput.startsWith("<!DOCTYPE html") ||
          trimmedInput.startsWith("<html")
        ) {
          // Extract the embedded defaultSimulationConfigList from HTML
          const defaultConfigMatch = inputText.match(
            /let\s+defaultSimulationConfigList\s*=\s*`([\s\S]*?)`;/
          );
          if (defaultConfigMatch) {
            const embeddedConfig = defaultConfigMatch[1];
            // Recursively parse the extracted v2 config
            return parseSimulationConfigList(embeddedConfig);
          }

          // Fallback: Extract JavaScript configuration from HTML
          const scriptMatch = inputText.match(
            /<script[\s\S]*?>([\s\S]*?)<\/script>/i
          );
          if (scriptMatch) {
            const scriptContent = scriptMatch[1];

            // Look for activeSimulationConfigs array in the script
            const configMatch = scriptContent.match(
              /let\s+activeSimulationConfigs\s*=\s*\[([\s\S]*?)\]\.map\(/
            );
            if (configMatch) {
              const configContent = configMatch[1];

              // Parse the JavaScript configuration objects
              try {
                // Create a safe eval context for the configuration
                const configString = `[${configContent}]`;
                const jsConfigs = eval(configString);

                // Convert JS format to our internal format
                return jsConfigs.map((config, index) => ({
                  grids: config.grids || [[], []],
                  steps: config.steps || 0,
                  boundaries: config.boundaries || {
                    xmin: -6,
                    xmax: 6,
                    ymin: -6,
                    ymax: 6,
                  },
                  waypoints: config.waypoints || [],
                  exclusive_points: config.exclusive_points || [],
                }));
              } catch (error) {
                console.error(
                  "Error parsing JavaScript configuration:",
                  error
                );
                throw new Error("Invalid JavaScript configuration format");
              }
            }
          }
          throw new Error("No valid configuration found in HTML content");
        }

        // Robust v2 Rust parsing logic with depth-aware tokenization
        const configs = [];

        // Clean input: remove comments and normalize whitespace
        let cleanInput = inputText
          .replace(/\/\*[\s\S]*?\*\/|\/\/[^\r\n]*/g, "") // Remove comments
          .replace(/\s+/g, " ") // Normalize whitespace
          .trim();

        // Remove outer vec![] wrapper if present
        const vecMatch = cleanInput.match(
          /^\s*vec!\s*\[\s*([\s\S]*)\s*\]\s*$/
        );
        if (vecMatch) {
          cleanInput = vecMatch[1].trim();
        }

        // Depth-aware tokenizer to find SimulationConfig::new(...) blocks
        const findSimulationConfigs = (text) => {
          const configs = [];
          let pos = 0;

          while (pos < text.length) {
            // Find next SimulationConfig::new
            const configStart = text.indexOf("SimulationConfig::new", pos);
            if (configStart === -1) break;

            // Find opening parenthesis
            const parenStart = text.indexOf("(", configStart);
            if (parenStart === -1) break;

            // Track depth to find matching closing parenthesis
            let depth = 0;
            let inString = false;
            let escapeNext = false;
            let configEnd = parenStart;

            for (let i = parenStart; i < text.length; i++) {
              const char = text[i];

              if (escapeNext) {
                escapeNext = false;
                continue;
              }

              if (char === "\\" && inString) {
                escapeNext = true;
                continue;
              }

              if (char === "'" && !escapeNext) {
                inString = !inString;
                continue;
              }

              if (!inString) {
                if (char === "(" || char === "[") {
                  depth++;
                } else if (char === ")" || char === "]") {
                  depth--;
                  if (depth === 0) {
                    configEnd = i;
                    break;
                  }
                }
              }
            }

            if (depth === 0) {
              const configBlock = text.substring(parenStart + 1, configEnd);
              configs.push(configBlock.trim());
              pos = configEnd + 1;
            } else {
              throw new Error(
                `Unmatched parentheses in SimulationConfig starting at position ${configStart}`
              );
            }
          }

          return configs;
        };

        // Parse each SimulationConfig block
        const configBlocks = findSimulationConfigs(cleanInput);
        if (configBlocks.length === 0) {
          throw new Error(
            "No valid SimulationConfig::new blocks found in the input"
          );
        }

        configBlocks.forEach((blockContent, blockIndex) => {
          try {
            // Parse parameters with depth-aware comma splitting
            const parseParameters = (content) => {
              const params = [];
              let currentParam = "";
              let depth = 0;
              let inString = false;
              let escapeNext = false;

              for (let i = 0; i < content.length; i++) {
                const char = content[i];

                if (escapeNext) {
                  currentParam += char;
                  escapeNext = false;
                  continue;
                }

                if (char === "\\" && inString) {
                  currentParam += char;
                  escapeNext = true;
                  continue;
                }

                if (char === "'" && !escapeNext) {
                  inString = !inString;
                  currentParam += char;
                  continue;
                }

                if (!inString) {
                  if (char === "(" || char === "[") {
                    depth++;
                  } else if (char === ")" || char === "]") {
                    depth--;
                  } else if (char === "," && depth === 0) {
                    params.push(currentParam.trim());
                    currentParam = "";
                    continue;
                  }
                }

                currentParam += char;
              }

              if (currentParam.trim()) {
                params.push(currentParam.trim());
              }

              return params;
            };

            const params = parseParameters(blockContent);
            if (params.length < 4) {
              throw new Error(
                `Frame ${blockIndex}: Expected at least 4 parameters, got ${params.length}`
              );
            }

            // Helper functions for parsing specific data types
            const parseRobotVec = (vecStr) => {
              if (!vecStr || vecStr.trim() === "vec![]") return [];

              const tuples = [];
              const content = vecStr
                .replace(/^vec!\s*\[\s*/, "")
                .replace(/\s*\]\s*$/, "");
              if (!content.trim()) return [];

              const tupleRegex =
                /\(\s*'([RGBOLF])'\s*,\s*(-?\d+)\s*,\s*(-?\d+)\s*\)/g;
              let tupleMatch;
              while ((tupleMatch = tupleRegex.exec(content)) !== null) {
                tuples.push([
                  tupleMatch[1],
                  Number(tupleMatch[2]),
                  Number(tupleMatch[3]),
                ]);
              }
              return tuples;
            };

            const parsePointVec = (vecStr) => {
              if (
                !vecStr ||
                vecStr.trim() === "vec![]" ||
                vecStr.trim() === "None"
              )
                return [];

              const points = [];
              const content = vecStr
                .replace(/^vec!\s*\[\s*/, "")
                .replace(/\s*\]\s*$/, "");
              if (!content.trim()) return [];

              const pointRegex = /\(\s*(-?\d+)\s*,\s*(-?\d+)\s*\)/g;
              let pointMatch;
              while ((pointMatch = pointRegex.exec(content)) !== null) {
                points.push([Number(pointMatch[1]), Number(pointMatch[2])]);
              }
              return points;
            };

            const parseTargetsVec = (vecStr) => {
              if (!vecStr || vecStr.trim() === "vec![]") return [];

              const targets = [];
              const content = vecStr
                .replace(/^vec!\s*\[\s*/, "")
                .replace(/\s*\]\s*$/, "");
              if (!content.trim()) return [];

              // Parse target tuples: (steps, robots_vec, exclusive_vec, waypoints_vec)
              const targetParams = parseParameters(content);

              for (const targetParam of targetParams) {
                const trimmed = targetParam.trim();
                if (!trimmed.startsWith("(") || !trimmed.endsWith(")"))
                  continue;

                const tupleContent = trimmed.substring(1, trimmed.length - 1);
                const tupleParams = parseParameters(tupleContent);

                if (tupleParams.length !== 4) {
                  throw new Error(
                    `Target tuple expected 4 elements (steps, robots, exclusive, waypoints), got ${tupleParams.length}`
                  );
                }

                const steps = Math.max(0, Number(tupleParams[0]) || 5); // Clamp to >= 0, default 5
                const robots = parseRobotVec(tupleParams[1]);
                const exclusive = parsePointVec(tupleParams[2]);
                const waypoints = parsePointVec(tupleParams[3]);

                targets.push({ steps, robots, exclusive, waypoints });
              }

              return targets;
            };

            const parseBoundaries = (boundariesStr) => {
              const defaultBounds = { xmin: -6, xmax: 6, ymin: -6, ymax: 6 };

              if (!boundariesStr || boundariesStr.trim() === "None") {
                return defaultBounds;
              }

              // Extract tuple from Some((...))
              const someMatch = boundariesStr.match(
                /Some\s*\(\s*\(\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(-?\d+)\s*\)\s*\)/
              );
              if (someMatch) {
                let xmin = Number(someMatch[1]);
                let xmax = Number(someMatch[2]);
                let ymin = Number(someMatch[3]);
                let ymax = Number(someMatch[4]);

                // Ensure proper ordering
                if (xmin > xmax) [xmin, xmax] = [xmax, xmin];
                if (ymin > ymax) [ymin, ymax] = [ymax, ymin];

                return { xmin, xmax, ymin, ymax };
              }

              return defaultBounds;
            };

            const parseWalls = (wallsStr, boundaries) => {
              const walls = [];
              if (
                !wallsStr ||
                wallsStr.trim() === "(None,None)" ||
                wallsStr.trim() === "(None, None)"
              ) {
                return walls;
              }

              // Remove outer parentheses and split by comma
              const wallContent = wallsStr
                .replace(/^\(\s*/, "")
                .replace(/\s*\)$/, "");
              const wallParams = parseParameters(wallContent);

              if (wallParams.length >= 2) {
                // Parse vertical wall (first parameter)
                const verticalParam = wallParams[0].trim();
                const verticalMatch = verticalParam.match(
                  /Some\s*\(\s*(-?\d+)\s*\)/
                );
                if (verticalMatch) {
                  const x = Number(verticalMatch[1]);
                  walls.push({
                    type: "vertical",
                    x1: x,
                    y1: boundaries.ymin - 5, // Extend beyond boundaries
                    x2: x,
                    y2: boundaries.ymax + 5,
                  });
                }

                // Parse horizontal wall (second parameter)
                const horizontalParam = wallParams[1].trim();
                const horizontalMatch = horizontalParam.match(
                  /Some\s*\(\s*(-?\d+)\s*\)/
                );
                if (horizontalMatch) {
                  const y = Number(horizontalMatch[1]);
                  walls.push({
                    type: "horizontal",
                    x1: boundaries.xmin - 5, // Extend beyond boundaries
                    y1: y,
                    x2: boundaries.xmax + 5,
                    y2: y,
                  });
                }
              }

              return walls;
            };

            // Parse v2 format: starting_grid, targets_vec, boundaries, walls
            const startingGridStr = params[0];
            const targetsStr = params[1];
            const boundariesStr = params[2];
            const wallsStr = params[3];

            // Parse boundaries first (needed for wall extension)
            const boundaries = parseBoundaries(boundariesStr);

            // Parse starting grid
            const startingGrid = parseRobotVec(startingGridStr);

            // Parse targets
            const targets = parseTargetsVec(targetsStr);

            // Parse walls
            const walls = parseWalls(wallsStr, boundaries);

            // Build internal data structure
            const grids = [startingGrid];
            const gridSteps = [0]; // Starting position always has 0 steps
            const gridWaypoints = [[]]; // Starting grid has no waypoints
            const gridExclusivePoints = [[]]; // Starting grid has no exclusive points

            // Add target grids
            targets.forEach((target) => {
              grids.push(target.robots);
              gridSteps.push(target.steps);
              gridWaypoints.push(target.waypoints);
              gridExclusivePoints.push(target.exclusive);
            });

            // Ensure we have at least 2 grids (starting + 1 target)
            while (grids.length < 2) {
              grids.push([]);
              gridSteps.push(5); // Default steps
              gridWaypoints.push([]);
              gridExclusivePoints.push([]);
            }

            // Calculate total steps (sum of target grid steps)
            const totalSteps = gridSteps
              .slice(1)
              .reduce((sum, steps) => sum + steps, 0);

            configs.push({
              id: `cfg-loaded-${Date.now()}-${blockIndex}`,
              grids,
              steps: totalSteps,
              gridSteps,
              gridWaypoints,
              gridExclusivePoints,
              boundaries,
              walls,
              needsRedraw: true,
            });
          } catch (error) {
            throw new Error(`Frame ${blockIndex}: ${error.message}`);
          }
        });

        if (configs.length === 0) {
          throw new Error(
            "No valid SimulationConfig::new blocks found in the input"
          );
        }

        // Validate and fix any structural issues
        configs.forEach((config, index) => {
          // Ensure minimum grid count
          while (config.grids.length < 2) {
            config.grids.push([]);
          }

          // Ensure gridSteps, gridWaypoints, gridExclusivePoints match grids length
          while (config.gridSteps.length < config.grids.length) {
            config.gridSteps.push(5);
          }
          while (config.gridWaypoints.length < config.grids.length) {
            config.gridWaypoints.push([]);
          }
          while (config.gridExclusivePoints.length < config.grids.length) {
            config.gridExclusivePoints.push([]);
          }

          // Recalculate total steps
          config.steps = config.gridSteps
            .slice(1)
            .reduce((sum, steps) => sum + steps, 0);
        });

        return configs;
      }

      // --- Initialization ---
      function initialize() {
        console.log("=== Initialize called ===");
        console.log(
          "Current defaultSimulationConfigList length:",
          defaultSimulationConfigList.length
        );

        // Parse configs from defaultSimulationConfigList OR window.loadedGoalsData at initialization time
        let initialData = undefined;
        if (window.loadedGoalsData) {
          console.log("Using window.loadedGoalsData for initialization");
          initialData = window.loadedGoalsData;
        }
        window.activeSimulationConfigs = parseDefaultConfigs(initialData);
        console.log(
          "Loaded",
          window.activeSimulationConfigs.length,
          "simulation configs"
        );

        // Check if running in iframe
        if (window.self !== window.top) {
          document.body.classList.add("in-iframe");
          // Hide editor panel by default in iframe mode
          if (!isEditorHidden) {
            toggleEditor();
          }
        }

        // No localStorage loading - configs come from postMessage only
        // const cached = loadConfigsFromLocalStorage();
        // if (cached && cached.length > 0) {
        //   activeSimulationConfigs = cached;
        // }

        // Migrate old data format if necessary
        window.activeSimulationConfigs.forEach((config) => {
          if (config.startRobots || config.endRobots) {
            config.grids = [];
            if (config.startRobots) config.grids.push(config.startRobots);
            if (config.endRobots) config.grids.push(config.endRobots);
            delete config.startRobots;
            delete config.endRobots;
          }
          // Ensure waypoints and exclusive_points exist
          if (!config.waypoints) config.waypoints = [];
          if (!config.exclusive_points) config.exclusive_points = [];
          if (!config.walls) config.walls = [];

          // Migrate to new per-grid waypoints/exclusive points format
          if (!config.gridWaypoints || !config.gridExclusivePoints) {
            const gridCount = Math.max(2, (config.grids || []).length);
            config.gridWaypoints = new Array(gridCount)
              .fill(null)
              .map(() => []);
            config.gridExclusivePoints = new Array(gridCount)
              .fill(null)
              .map(() => []);

            // If there were legacy global waypoints/exclusive_points, distribute them to target grids
            if (config.waypoints && config.waypoints.length > 0) {
              for (let i = 1; i < gridCount; i++) {
                config.gridWaypoints[i] = [...config.waypoints];
              }
            }
            if (
              config.exclusive_points &&
              config.exclusive_points.length > 0
            ) {
              for (let i = 1; i < gridCount; i++) {
                config.gridExclusivePoints[i] = [...config.exclusive_points];
              }
            }
          }

          // Migrate to new gridSteps format
          if (!config.gridSteps || config.gridSteps.length === 0) {
            config.gridSteps = Array(config.grids.length).fill(0);
            // Set starting position to 0, and distribute remaining steps among target grids
            if (config.gridSteps.length > 1) {
              const totalSteps = config.steps || 5;
              const numTargetGrids = config.gridSteps.length - 1;
              const stepsPerGrid = Math.floor(totalSteps / numTargetGrids);
              const remainder = totalSteps % numTargetGrids;

              for (let i = 1; i < config.gridSteps.length; i++) {
                config.gridSteps[i] = stepsPerGrid;
                // Add remainder to the last grid
                if (i === config.gridSteps.length - 1) {
                  config.gridSteps[i] += remainder;
                }
              }

              // Update total steps to match calculated gridSteps
              config.steps = config.gridSteps
                .slice(1)
                .reduce((sum, steps) => sum + steps, 0);
            }
          } else if (config.gridSteps.length !== config.grids.length) {
            // Handle case where gridSteps array length doesn't match grids length
            const oldGridSteps = [...config.gridSteps];
            config.gridSteps = Array(config.grids.length).fill(0);

            // Copy existing values where possible
            for (
              let i = 0;
              i < Math.min(oldGridSteps.length, config.gridSteps.length);
              i++
            ) {
              config.gridSteps[i] = oldGridSteps[i];
            }

            // If we have more grids than gridSteps, distribute remaining steps
            if (config.grids.length > oldGridSteps.length) {
              const totalSteps = config.steps || 5;
              const currentTotal = config.gridSteps
                .slice(1)
                .reduce((sum, steps) => sum + steps, 0);
              const remainingSteps = Math.max(0, totalSteps - currentTotal);
              const numNewGrids = config.grids.length - oldGridSteps.length;

              if (numNewGrids > 0 && remainingSteps > 0) {
                const stepsPerNewGrid = Math.floor(
                  remainingSteps / numNewGrids
                );
                const remainder = remainingSteps % numNewGrids;

                for (
                  let i = oldGridSteps.length;
                  i < config.gridSteps.length;
                  i++
                ) {
                  config.gridSteps[i] = stepsPerNewGrid;
                  if (i === config.gridSteps.length - 1) {
                    config.gridSteps[i] += remainder;
                  }
                }
              }
            }
          }

          // Ensure steps is properly calculated from gridSteps
          if (config.gridSteps && config.gridSteps.length > 1) {
            config.steps = config.gridSteps
              .slice(1)
              .reduce((sum, steps) => sum + steps, 0);
          }
        });

        if (simulatorColumn) {
          simulatorColumn.addEventListener("dragover", handleFrameDragOver);
          simulatorColumn.addEventListener("dragleave", handleFrameDragLeave);
          simulatorColumn.addEventListener("drop", handleFrameDrop);
        }
        if (addFrameBtn) {
          addFrameBtn.addEventListener("click", addNewFrame);
        }
        document
          .querySelector(".robot-palette")
          ?.addEventListener("mousedown", handlePaletteDragStart);

        setupModalAndParser();
        initializeResizeAndToggle();
        applyLayoutFromStorage();
        renderAllFrames();

        // Update all frame titles to ensure they show correct total steps
        activeSimulationConfigs.forEach((config) => {
          updateFrameTitle(config.id);
        });

        // Ensure event listeners are attached after a short delay to handle any timing issues
        setTimeout(() => {
          // Re-attach canvas event listeners as a safety measure
          document
            .querySelectorAll(".simulation-frame canvas")
            .forEach((canvas) => {
              // Remove existing listener first to avoid duplicates
              canvas.removeEventListener("mousedown", handleCanvasMouseDown);
              // Add the listener
              canvas.addEventListener("mousedown", handleCanvasMouseDown);
            });
        }, 100);
      }

      // Global mouseup handler for wall drag operations
      document.addEventListener("mouseup", (e) => {
        if (draggedWallData) {
          // Find the exact element under mouse cursor
          const elementUnderMouse = document.elementFromPoint(
            e.clientX,
            e.clientY
          );

          // Check if the element is a canvas (or contained within a canvas)
          let targetCanvas = null;
          if (elementUnderMouse) {
            if (elementUnderMouse.tagName === "CANVAS") {
              targetCanvas = elementUnderMouse;
            } else {
              // Check if clicked element is inside a canvas container
              const canvasParent =
                elementUnderMouse.closest(".frame-container");
              if (canvasParent) {
                targetCanvas = canvasParent.querySelector("canvas");
              }
            }
          }

          // Handle wall drop (adds to target canvas or deletes if outside)
          handleWallDrop(targetCanvas, e.clientX, e.clientY);
        }
      });

      // Expose initialize function to be called from main page
      window.initializeEmbeddedGoalsSimulator = initialize;

      // Auto-initialize if this code is being run standalone (not embedded)
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initialize);
      } else {
        // DOM already loaded, initialize immediately if standalone
        if (!document.getElementById("page-1")) {
          initialize();
        }
      }

      // --- Message Listener for Iframe Communication ---
      window.addEventListener("message", (event) => {
        if (event.data && event.data.type === "LOAD_CONFIG") {
          console.log("Received config via postMessage:", event.data.payload);
          const newConfigs = event.data.payload;

          if (Array.isArray(newConfigs) && newConfigs.length > 0) {
            // Update active configs
            window.activeSimulationConfigs = newConfigs;

            // Ensure all configs have necessary properties
            window.activeSimulationConfigs.forEach((config) => {
              if (!config.needsRedraw) config.needsRedraw = true;
              // Ensure grids/steps/waypoints arrays are consistent
              if (!config.gridSteps)
                config.gridSteps = config.grids.map(() => 5);
              if (!config.gridWaypoints)
                config.gridWaypoints = config.grids.map(() => []);
              if (!config.gridExclusivePoints)
                config.gridExclusivePoints = config.grids.map(() => []);
            });

            // Refresh UI
            renderAllFrames();
            updateFullConfigTextArea();
            saveConfigsToLocalStorage();

            // Update titles
            activeSimulationConfigs.forEach((config) => {
              updateFrameTitle(config.id);
            });
          }
        } else if (
          event.data &&
          event.data.type === "UPDATE_DEFAULT_CONFIG"
        ) {
          console.log(
            "Updating defaultSimulationConfigList:",
            event.data.payload
          );
          // Update the default simulation config list with new goals data
          defaultSimulationConfigList = event.data.payload;

          // Also update localStorage with the new default
          try {
            const parsedData = JSON.parse(defaultSimulationConfigList);
            if (
              parsedData &&
              parsedData.simulation_configs &&
              Array.isArray(parsedData.simulation_configs)
            ) {
              const defaultConfigs = parsedData.simulation_configs.map(
                (config, index) => {
                  const boundaries = config.boundary || [-6, 6, -6, 6];
                  const walls = [];

                  if (config.wall && config.wall.length >= 2) {
                    const [verticalWall, horizontalWall] = config.wall;

                    if (verticalWall !== null) {
                      walls.push({
                        type: "vertical",
                        x1: verticalWall,
                        y1: boundaries[2] - 5,
                        x2: verticalWall,
                        y2: boundaries[3] + 5,
                      });
                    }

                    if (horizontalWall !== null) {
                      walls.push({
                        type: "horizontal",
                        x1: boundaries[0] - 5,
                        y1: horizontalWall,
                        x2: boundaries[1] + 5,
                        y2: horizontalWall,
                      });
                    }
                  }

                  const grids = [config.initial_positions || []];
                  const gridSteps = [0];
                  const gridWaypoints = [[]];
                  const gridExclusivePoints = [[]];

                  if (config.targets && Array.isArray(config.targets)) {
                    config.targets.forEach((target) => {
                      if (Array.isArray(target) && target.length >= 4) {
                        const [steps, robots, exclusive, waypoints] = target;
                        grids.push(robots || []);
                        gridSteps.push(steps || 5);
                        gridWaypoints.push(waypoints || []);
                        gridExclusivePoints.push(exclusive || []);
                      }
                    });
                  }

                  if (grids.length < 2) {
                    grids.push([]);
                    gridSteps.push(5);
                    gridWaypoints.push([]);
                    gridExclusivePoints.push([]);
                  }

                  const totalSteps = gridSteps
                    .slice(1)
                    .reduce((sum, steps) => sum + steps, 0);

                  return {
                    id: `cfg-default-${Date.now()}-${index}`,
                    grids,
                    steps: totalSteps,
                    gridSteps,
                    gridWaypoints,
                    gridExclusivePoints,
                    boundaries: {
                      xmin: boundaries[0],
                      xmax: boundaries[1],
                      ymin: boundaries[2],
                      ymax: boundaries[3],
                    },
                    walls,
                    needsRedraw: true,
                  };
                }
              );

              localStorage.setItem(
                LOCAL_STORAGE_KEY,
                JSON.stringify(defaultConfigs)
              );
              window.activeSimulationConfigs = defaultConfigs;
              renderAllFrames();
              updateFullConfigTextArea();
            }
          } catch (e) {
            console.error("Error updating default config:", e);
          }
        }
      });
      // === EMBEDDED GOALS SIMULATOR CODE END ===
    }

    // Ensure Help Modal Functionality
    document.addEventListener('DOMContentLoaded', () => {
      const setupModal = (btnId, modalId, closeId) => {
        const btn = document.getElementById(btnId);
        const modal = document.getElementById(modalId);
        const close = document.getElementById(closeId);

        if (btn && modal) {
          // Remove existing listeners to avoid duplicates if any (though difficult without reference)
          // Just add new one, as display='block' is idempotent
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            modal.style.display = 'block';
          });
        }

        if (close && modal) {
          close.addEventListener('click', () => {
            modal.style.display = 'none';
          });
        }

        if (modal) {
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              modal.style.display = 'none';
            }
          });
        }
      };

      setupModal('parametersHelpBtn', 'parametersHelpModal', 'closeParametersHelpModal');
      setupModal('initialConfigHelpBtn', 'initialConfigHelpModal', 'closeInitialConfigHelpModal');
      setupModal('goalsHelpBtn', 'goalsHelpModal', 'closeHelpModal');
    });
  </script>
</body>

</html>